/*
 * SimpleModal @VERSION - jQuery Plugin
 * http://simplemodal.com/
 * Copyright (c) 2014 Eric Martin
 * Licensed under MIT and GPL
 * Date:
 * modified by V. Suschev. Not compatible
 */

/**
 * SimpleModal is a lightweight jQuery plugin that provides a simple
 * interface to create a modal dialog.
 *
 * The goal of SimpleModal is to provide developers with a cross-browser
 * overlay and container that will be populated with data provided to
 * SimpleModal.
 *
 * There are two ways to call SimpleModal:
 * 1) As a chained function on a jQuery object, like $('#myDiv').modal();.
 * This call would place the DOM object, #myDiv, inside a modal dialog.
 * Chaining requires a jQuery object. An optional options object can be
 * passed as a parameter.
 *
 * @example $('<div>my data</div>').modal({options});
 * @example $('#myDiv').modal({options});
 * @example jQueryObject.modal({options});
 *
 * 2) As a stand-alone function, like $.modal(data). The data parameter
 * is required and an optional options object can be passed as a second
 * parameter. This method provides more flexibility in the types of data
 * that are allowed. The data could be a DOM object, a jQuery object, HTML
 * or a string.
 *
 * @example $.modal('<div>my data</div>', {options});
 * @example $.modal('my data', {options});
 * @example $.modal($('#myDiv'), {options});
 * @example $.modal(jQueryObject, {options});
 * @example $.modal(document.getElementById('myDiv'), {options});
 *
 * A SimpleModal call can contain multiple elements, but only one modal
 * dialog can be created at a time. Which means that all of the matched
 * elements will be displayed within the modal container.
 *
 * SimpleModal internally sets the CSS needed to display the modal dialog
 * properly in all browsers, yet provides the developer with the flexibility
 * to easily control the look and feel. The styling for SimpleModal can be
 * done through external stylesheets, or through SimpleModal, using the
 * overlayCss, containerCss, and dataCss options.
 *
 * SimpleModal has been tested in the following browsers:
 * - IE 6+
 * - Firefox 2+
 * - Opera 9+
 * - Safari 3+
 * - Chrome 1+
 *
 * @name SimpleModal
 * @type jQuery
 * @requires jQuery v1.3
 * @cat Plugins/Windows and Overlays
 * @author Eric Martin (http://ericmmartin.com)
 * @version @VERSION
 */

;(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else {
        // Browser globals
        factory(jQuery);
    }
}
(function ($) {
    var d = [],
        doc = $(document),
        ua = navigator.userAgent.toLowerCase(),
        wndw = $(window),
        w = [];

    var browser = {
        ieQuirks: null,
        msie: /msie/.test(ua) && !/opera/.test(ua),
        opera: /opera/.test(ua)
    };
    browser.ie6 = browser.msie && /msie 6./.test(ua) && typeof window['XMLHttpRequest'] !== 'object';
    browser.ie7 = browser.msie && /msie 7.0/.test(ua);
    browser.boxModel = (document.compatMode === "CSS1Compat");

    /*
     * Create and display a modal dialog.
     *
     * @param {string, object} data A string, jQuery object or DOM object
     * @param {object} [options] An optional object containing options overrides
     */
    $.modal = function (data, options) {
        return $.modal.impl.init(data, options);
    };

    /*
     * Close the modal dialog.
     */
    $.modal.close = function () {
        $.modal.impl.close();
    };

    /*
     * Set focus on first or last visible input in the modal dialog. To focus on the last
     * element, call $.modal.focus('last'). If no input elements are found, focus is placed
     * on the data wrapper element.
     */
    $.modal.focus = function (pos) {
        $.modal.impl.focus(pos);
    };

    /*
     * Determine and set the dimensions of the modal dialog container.
     * setPosition() is called if the autoPosition option is true.
     */
    $.modal.setContainerDimensions = function () {
        $.modal.impl.setContainerDimensions();
    };

    /*
     * Re-position the modal dialog.
     */
    $.modal.setPosition = function () {
        $.modal.impl.setPosition();
    };

    /*
     * Update the modal dialog. If new dimensions are passed, they will be used to determine
     * the dimensions of the container.
     *
     * setContainerDimensions() is called, which in turn calls setPosition(), if enabled.
     * Lastly, focus() is called is the focus option is true.
     */
    $.modal.update = function (height, width) {
        $.modal.impl.update(height, width);
    };

    /*
     * Chained function to create a modal dialog.
     *
     * @param {object} [options] An optional object containing options overrides
     */
    $.fn.modal = function (options) {
        return $.modal.impl.init(this, options);
    };

    /*
     * SimpleModal default options
     *
     * appendTo:		(String:'body') The jQuery selector to append the elements to. For .NET, use 'form'.
     * focus:			(Boolean:true) Focus in the first visible, enabled element?
     * opacity:			(Number:50) The opacity value for the overlay div, from 0 - 100
     * overlayId:		(String:'simplemodal-overlay') The DOM element id for the overlay div
     * overlayCss:		(Object:{}) The CSS styling for the overlay div
     * containerId:		(String:'simplemodal-container') The DOM element id for the container div
     * containerCss:	(Object:{}) The CSS styling for the container div
     * dataId:			(String:'simplemodal-data') The DOM element id for the data div
     * dataCss:			(Object:{}) The CSS styling for the data div
     * minHeight:		(Number:null) The minimum height for the container
     * minWidth:		(Number:null) The minimum width for the container
     * maxHeight:		(Number:null) The maximum height for the container. If not specified, the window height is used.
     * maxWidth:		(Number:null) The maximum width for the container. If not specified, the window width is used.
     * autoResize:		(Boolean:false) Automatically resize the container if it exceeds the browser window dimensions?
     * autoPosition:	(Boolean:true) Automatically position the container upon creation and on window resize?
     * zIndex:			(Number: 1000) Starting z-index value
     * close:			(Boolean:true) If true, closeHTML, escClose and overClose will be used if set.
     If false, none of them will be used.
     * closeHTML:		(String:'<a class="modalCloseImg" title="Close"></a>') The HTML for the default close link.
     SimpleModal will automatically add the closeClass to this element.
     * closeClass:		(String:'simplemodal-close') The CSS class used to bind to the close event
     * escClose:		(Boolean:true) Allow Esc keypress to close the dialog?
     * overlayClose:	(Boolean:false) Allow click on overlay to close the dialog?
     * fixed:			(Boolean:true) If true, the container will use a fixed position. If false, it will use a
     absolute position (the dialog will scroll with the page)
     * position:		(Array:null) Position of container [top, left]. Can be number of pixels or percentage
     * persist:			(Boolean:false) Persist the data across modal calls? Only used for existing
     DOM elements. If true, the data will be maintained across modal calls, if false,
     the data will be reverted to its original state.
     * modal:			(Boolean:true) User will be unable to interact with the page below the modal or tab away from the dialog.
     If false, the overlay, iframe, and certain events will be disabled allowing the user to interact
     with the page below the dialog.
     * onOpen:			(Function:null) The callback function used in place of SimpleModal's open
     * onShow:			(Function:null) The callback function used after the modal dialog has opened
     * onClose:			(Function:null) The callback function used in place of SimpleModal's close
     */
    $.modal.defaults = {
        appendTo: 'body',
        focus: true,
        opacity: 50,
        overlayId: 'simplemodal-overlay',
        overlayCss: {},
        containerId: 'simplemodal-container',
        containerCss: {},
        title: '',
        titleId: 'simplemodal-title',
        titleCss: {},
        dataId: 'simplemodal-data',
        dataCss: {},
        minHeight: null,
        minWidth: null,
        maxHeight: null,
        maxWidth: null,
        autoResize: false,
        autoPosition: true,
        zIndex: 1000,
        close: true,
        closeHTML: '<a class="modalCloseImg" title="Close"></a>',
        closeClass: 'uk-icon-close',
        escClose: true,
        overlayClose: false,
        fixed: true,
        position: null,
        persist: false,
        draggable: false,
        modal: true,
        onOpen: null,
        onShow: null,
        onClose: null
    };

    /*
     * Main modal object
     * o = options
     */
    $.modal.impl = {
        /*
         * Contains the modal dialog elements and is the object passed
         * back to the callback (onOpen, onShow, onClose) functions
         */
        d: {},
        /*
         * Initialize the modal dialog
         */
        init: function (data, options) {
            var s = this;

            // don't allow multiple calls
            if (s.d.data) {
                return s;
            }

            browser.ieQuirks = browser.msie && !browser.boxModel;

            // merge defaults and user options
            s.o = $.extend({}, $.modal.defaults, options);

            // keep track of z-index
            s.zIndex = s.o.zIndex;

            // set the onClose callback flag
            s.occb = false;

            // determine how to handle the data based on its type
            if (typeof data === 'object') {
                // convert DOM object to a jQuery object
                data = data instanceof $ ? data : $(data);
                s.d.placeholder = false;

                // if the object came from the DOM, keep track of its parent
                if (data.parent().parent().length > 0) {
                    data.before($('<span></span>')
                        .attr('id', 'simplemodal-placeholder')
                        .css({display: 'none'}));

                    s.d.placeholder = true;
                    s.display = data.css('display');

                    // persist changes? if not, make a clone of the element
                    if (!s.o.persist) {
                        s.d.orig = data.clone(true);
                    }
                }
            }
            else if (typeof data === 'string' || typeof data === 'number') {
                // just insert the data as innerHTML
                data = $('<div></div>').html(data);
            }
            else {
                // unsupported data type!
                alert('SimpleModal Error: Unsupported data type: ' + typeof data);
                return s;
            }

            // create the modal overlay, container and, if necessary, iframe
            s.create(data);
            data = null;

            // display the modal dialog
            s.open();

            // useful for adding events/manipulating data in the modal dialog
            if ($.isFunction(s.o.onShow)) {
                s.o.onShow.apply(s, [s.d]);
            }

            // don't break the chain =)
            return s;
        },
        /*
         * Create and add the modal overlay and container to the page
         */
        create: function (data) {
            var s = this;

            // get the window properties
            s.getDimensions();

            // add an iframe to prevent select options from bleeding through
            if (s.o.modal && browser.ie6) {
                s.d.iframe = $('<iframe src="javascript:false;"></iframe>')
                    .css($.extend(s.o.iframeCss, {
                        display: 'none',
                        opacity: 0,
                        position: 'fixed',
                        height: w[0],
                        width: w[1],
                        zIndex: s.o.zIndex,
                        top: 0,
                        left: 0
                    }))
                    .appendTo(s.o.appendTo);
            }

            // create the overlay
            s.d.overlay = $('<div></div>')
                .attr('id', s.o.overlayId)
                .addClass('simplemodal-overlay')
                .css($.extend(s.o.overlayCss, {
                    display: 'none',
                    opacity: s.o.opacity / 100,
                    height: s.o.modal ? d[0] : 0,
                    width: s.o.modal ? d[1] : 0,
                    position: 'fixed',
                    left: 0,
                    top: 0,
                    zIndex: s.o.zIndex + 1
                }))
                .appendTo(s.o.appendTo);

            // create the container
            s.d.container = $('<div></div>')
                .attr('id', s.o.containerId)
                .addClass('simplemodal-container')
                .css($.extend(
                    {position: s.o.fixed ? 'fixed' : 'absolute'},
                    s.o.containerCss,
                    {display: 'none', zIndex: s.o.zIndex + 2}
                ))
                .append(s.o.close && s.o.closeHTML
                    ? $(s.o.closeHTML).addClass(s.o.closeClass)
                    : '')
                .appendTo(s.o.appendTo);

            s.d.title = $('<div></div>')
                .attr('id', s.o.titleId)
                .addClass('simplemodal-title')
                .css($.extend({/*height: '30px', width: '100%'*/}, s.o.titleCss))
                .append(s.o.title)
                .appendTo(s.d.container);

            s.d.wrap = $('<div></div>')
                .attr('tabIndex', -1)
                .addClass('simplemodal-wrap')
                .appendTo(s.d.container);

            // add styling and attributes to the data
            // append to body to get correct dimensions, then move to wrap
            s.d.data = data
                .attr('id', data.attr('id') || s.o.dataId)
                .addClass('simplemodal-data')
                .css($.extend(s.o.dataCss, {
                    display: 'none'
                }))
                .appendTo('body');
            data = null;

            s.setContainerDimensions();
            s.d.data.appendTo(s.d.wrap);

            if(s.o.draggable && typeof s.d.container.draggable == "function") {
                //TODO Будет ли jqueryUI включен в либу...
                s.d.container.draggable({
                    handle: s.d.title,
                    snap: false
                });
            }

            // fix issues with IE
            if (browser.ie6 || browser.ieQuirks) {
                s.fixIE();
            }
        },
        /*
         * Bind events
         */
        bindEvents: function () {
            var s = this;

            // bind the close event to any element with the closeClass class
            $('.' + s.o.closeClass).bind('click.simplemodal', function (e) {
                e.preventDefault();
                s.close();
            });

            // bind the overlay click to the close function, if enabled
            if (s.o.modal && s.o.close && s.o.overlayClose) {
                s.d.overlay.bind('click.simplemodal', function (e) {
                    e.preventDefault();
                    s.close();
                });
            }

            // bind keydown events
            doc.bind('keydown.simplemodal', function (e) {
                if (s.o.modal && e.keyCode === 9) { // TAB
                    s.watchTab(e);
                }
                else if ((s.o.close && s.o.escClose) && e.keyCode === 27) { // ESC
                    e.preventDefault();
                    s.close();
                }
            });

            // update window size
            wndw.bind('resize.simplemodal orientationchange.simplemodal', function () {
                // redetermine the window width/height
                s.getDimensions();

                // reposition the dialog
                s.o.autoResize ? s.setContainerDimensions() : s.o.autoPosition && s.setPosition();

                if (browser.ie6 || browser.ieQuirks) {
                    s.fixIE();
                }
                else if (s.o.modal) {
                    // update the iframe & overlay
                    s.d.iframe && s.d.iframe.css({height: w[0], width: w[1]});
                    s.d.overlay.css({height: d[0], width: d[1]});
                }
            });
        },
        /*
         * Unbind events
         */
        unbindEvents: function () {
            $('.' + this.o.closeClass).unbind('click.simplemodal');
            doc.unbind('keydown.simplemodal');
            wndw.unbind('.simplemodal');
            this.d.overlay.unbind('click.simplemodal');
        },
        /*
         * Fix issues in IE6 and IE7 in quirks mode
         */
        fixIE: function () {
            var s = this, p = s.o.position;

            // simulate fixed position - adapted from BlockUI
            $.each([s.d.iframe || null, !s.o.modal ? null : s.d.overlay, s.d.container.css('position') === 'fixed' ? s.d.container : null], function (i, el) {
                if (el) {
                    var bch = 'document.body.clientHeight', bcw = 'document.body.clientWidth',
                        bsh = 'document.body.scrollHeight', bsl = 'document.body.scrollLeft',
                        bst = 'document.body.scrollTop', bsw = 'document.body.scrollWidth',
                        ch = 'document.documentElement.clientHeight', cw = 'document.documentElement.clientWidth',
                        sl = 'document.documentElement.scrollLeft', st = 'document.documentElement.scrollTop',
                        s = el[0].style;

                    s.position = 'absolute';
                    if (i < 2) {
                        s.removeExpression('height');
                        s.removeExpression('width');
                        s.setExpression('height','' + bsh + ' > ' + bch + ' ? ' + bsh + ' : ' + bch + ' + "px"');
                        s.setExpression('width','' + bsw + ' > ' + bcw + ' ? ' + bsw + ' : ' + bcw + ' + "px"');
                    }
                    else {
                        var te, le;
                        if (p && p.constructor === Array) {
                            var top = p[0]
                                ? typeof p[0] === 'number' ? p[0].toString() : p[0].replace(/px/, '')
                                : el.css('top').replace(/px/, '');
                            te = top.indexOf('%') === -1
                                ? top + ' + (t = ' + st + ' ? ' + st + ' : ' + bst + ') + "px"'
                                : parseInt(top.replace(/%/, '')) + ' * ((' + ch + ' || ' + bch + ') / 100) + (t = ' + st + ' ? ' + st + ' : ' + bst + ') + "px"';

                            if (p[1]) {
                                var left = typeof p[1] === 'number' ? p[1].toString() : p[1].replace(/px/, '');
                                le = left.indexOf('%') === -1
                                    ? left + ' + (t = ' + sl + ' ? ' + sl + ' : ' + bsl + ') + "px"'
                                    : parseInt(left.replace(/%/, '')) + ' * ((' + cw + ' || ' + bcw + ') / 100) + (t = ' + sl + ' ? ' + sl + ' : ' + bsl + ') + "px"';
                            }
                        }
                        else {
                            te = '(' + ch + ' || ' + bch + ') / 2 - (this.offsetHeight / 2) + (t = ' + st + ' ? ' + st + ' : ' + bst + ') + "px"';
                            le = '(' + cw + ' || ' + bcw + ') / 2 - (this.offsetWidth / 2) + (t = ' + sl + ' ? ' + sl + ' : ' + bsl + ') + "px"';
                        }
                        s.removeExpression('top');
                        s.removeExpression('left');
                        s.setExpression('top', te);
                        s.setExpression('left', le);
                    }
                }
            });
        },
        /*
         * Place focus on the first or last visible input
         */
        focus: function (pos) {
            var s = this, p = pos && $.inArray(pos, ['first', 'last']) !== -1 ? pos : 'first';

            // focus on dialog or the first visible/enabled input element
            var input = $(':input:enabled:visible:' + p, s.d.wrap);
            setTimeout(function () {
                input.length > 0 ? input.focus() : s.d.wrap.focus();
            }, 10);
        },
        getDimensions: function () {
            // fix a jQuery bug with determining the window height - use innerHeight if available
            var s = this,
                h = typeof window.innerHeight === 'undefined' ? wndw.height() : window.innerHeight;

            d = [doc.height(), doc.width()];
            w = [h, wndw.width()];
        },
        getVal: function (v, d) {
            return v ? (typeof v === 'number' ? v
                : v === 'auto' ? 0
                : v.indexOf('%') > 0 ? ((parseInt(v.replace(/%/, '')) / 100) * (d === 'h' ? w[0] : w[1]))
                : parseInt(v.replace(/px/, '')))
                : null;
        },
        /*
         * Update the container. Set new dimensions, if provided.
         * Focus, if enabled. Re-bind events.
         */
        update: function (height, width) {
            var s = this;

            // prevent update if dialog does not exist
            if (!s.d.data) {
                return false;
            }

            // reset orig values
            s.d.origHeight = s.getVal(height, 'h');
            s.d.origWidth = s.getVal(width, 'w');

            // hide data to prevent screen flicker
            s.d.data.hide();
            height && s.d.container.css('height', height);
            width && s.d.container.css('width', width);
            s.setContainerDimensions();
            s.d.data.show();
            s.o.focus && s.focus();

            // rebind events
            s.unbindEvents();
            s.bindEvents();
        },
        setContainerDimensions: function () {
            var s = this,
                badIE = browser.ie6 || browser.ie7;

            // get the dimensions for the container and data
            //var ch = s.d.origHeight ? s.d.origHeight : browser.opera ? s.d.container.height() : s.getVal(badIE ? s.d.container[0].currentStyle['height'] : s.d.container.css('height'), 'h'),
            var ch = '',
                //cw = s.d.origWidth ? s.d.origWidth : browser.opera ? s.d.container.width() : s.getVal(badIE ? s.d.container[0].currentStyle['width'] : s.d.container.css('width'), 'w'),
                cw = '',
                //dh = s.d.data.outerHeight(true) + s.d.title.outerHeight(true),
                dh = s.d.data.outerHeight(true) + s.d.container.height(),
                dw = s.d.data.outerWidth(true) + s.d.container.width();

            s.d.origHeight = s.d.origHeight || ch;
            s.d.origWidth = s.d.origWidth || cw;

            // mxoh = max option height, mxow = max option width
            var mxoh = s.o.maxHeight ? s.getVal(s.o.maxHeight, 'h') : null,
                mxow = s.o.maxWidth ? s.getVal(s.o.maxWidth, 'w') : null,
                mh = mxoh && mxoh < w[0] ? mxoh : w[0],
                mw = mxow && mxow < w[1] ? mxow : w[1];

            // moh = min option height
            var moh = s.o.minHeight ? s.getVal(s.o.minHeight, 'h') : 'auto';
            if (!ch) {
                if (!dh) {ch = moh;}
                else {
                    if (dh > mh) {ch = mh;}
                    else if (s.o.minHeight && moh !== 'auto' && dh < moh) {ch = moh;}
                    else {ch = dh;}
                }
            }
            else {
                ch = s.o.autoResize && ch > mh ? mh : ch < moh ? moh : ch;
            }

            // mow = min option width
            var mow = s.o.minWidth ? s.getVal(s.o.minWidth, 'w') : 'auto';
            if (!cw) {
                if (!dw) {cw = mow;}
                else {
                    if (dw > mw) {cw = mw;}
                    else if (s.o.minWidth && mow !== 'auto' && dw < mow) {cw = mow;}
                    else {cw = dw;}
                }
            }
            else {
                cw = s.o.autoResize && cw > mw ? mw : cw < mow ? mow : cw;
            }

            s.d.container.css({height: ch, width: cw});
            s.d.wrap.css({overflow: (dh > ch || dw > cw) ? 'auto' : 'visible'});
            s.o.autoPosition && s.setPosition();
        },
        setPosition: function () {
            var s = this, top, left,
                hc = (w[0]/2) - (s.d.container.outerHeight(true)/2),
                vc = (w[1]/2) - (s.d.container.outerWidth(true)/2),
                st = s.d.container.css('position') !== 'fixed' ? wndw.scrollTop() : 0;

            if (s.o.position && Object.prototype.toString.call(s.o.position) === '[object Array]') {
                top = parseFloat(st) + parseFloat(s.o.position[0] || hc);
                left = s.o.position[1] || vc;
            } else {
                top = st + hc;
                left = vc;
            }
            s.d.container.css({left: left, top: top});
        },
        watchTab: function (e) {
            var s = this;

            if ($(e.target).parents('.simplemodal-container').length > 0) {
                // save the list of inputs
                s.inputs = $(':input:enabled:visible:first, :input:enabled:visible:last', s.d.data[0]);

                // if it's the first or last tabbable element, refocus
                if ((!e.shiftKey && e.target === s.inputs[s.inputs.length -1]) ||
                    (e.shiftKey && e.target === s.inputs[0]) ||
                    s.inputs.length === 0) {
                    e.preventDefault();
                    var pos = e.shiftKey ? 'last' : 'first';
                    s.focus(pos);
                }
            }
            else {
                // might be necessary when custom onShow callback is used
                e.preventDefault();
                s.focus();
            }
        },
        /*
         * Open the modal dialog elements
         * - Note: If you use the onOpen callback, you must "show" the
         *         overlay and container elements manually
         *         (the iframe will be handled by SimpleModal)
         */
        open: function () {
            var s = this;
            // display the iframe
            s.d.iframe && s.d.iframe.show();

            if ($.isFunction(s.o.onOpen)) {
                // execute the onOpen callback
                s.o.onOpen.apply(s, [s.d]);
            }
            else {
                // display the remaining elements
                s.d.overlay.show();
                s.d.container.show();
                s.d.data.show();
            }

            s.o.focus && s.focus();

            // bind default events
            s.bindEvents();
        },
        /*
         * Close the modal dialog
         * - Note: If you use an onClose callback, you must remove the
         *         overlay, container and iframe elements manually
         *
         * @param {boolean} external Indicates whether the call to this
         *     function was internal or external. If it was external, the
         *     onClose callback will be ignored
         */
        close: function (doCallback) {
            doCallback = (typeof doCallback == "undefined") ? true : !!doCallback;
            var s = this;

            // prevent close when dialog does not exist
            if (!s.d.data) {
                return false;
            }

            // remove the default events
            s.unbindEvents();

            if ($.isFunction(s.o.onClose) && !s.occb && doCallback) {
                // set the onClose callback flag
                s.occb = true;

                // execute the onClose callback
                s.o.onClose.apply(s, [s.d]);
            }
            else {
                // if the data came from the DOM, put it back
                if (s.d.placeholder) {
                    var ph = $('#simplemodal-placeholder');
                    // save changes to the data?
                    if (s.o.persist) {
                        // insert the (possibly) modified data back into the DOM
                        ph.replaceWith(s.d.data.removeClass('simplemodal-data').css('display', s.display));
                    }
                    else {
                        // remove the current and insert the original,
                        // unmodified data back into the DOM
                        s.d.data.hide().remove();
                        ph.replaceWith(s.d.orig);
                    }
                }
                else {
                    // otherwise, remove it
                    s.d.data.hide().remove();
                }

                // remove the remaining elements
                s.d.container.hide().remove();
                s.d.overlay.hide();
                s.d.iframe && s.d.iframe.hide().remove();
                s.d.overlay.remove();

                // reset the dialog object
                s.d = {};
            }
        }
    };
}));
/**
 * Created by gti on 05.07.16.
 */
(function ($){


var methods = {
    palettes: {
        basic: [
            "#000000",
            "#7f7f7f",
            "#880015",
            "#ed1c24",
            "#ff7f27",
            "#fff200",
            "#22b14c",
            "#00a2e8",
            "#3f48cc",
            "#a349a4",
            "#ffffff",
            "#c3c3c3",
            "#b97a57",
            "#ffaec9",
            "#ffc90e",
            "#efe4b0",
            "#b5e61d",
            "#99d9ea",
            "#7092be",
            "#c8bfe7"
        ]
    },
    defaults: {
        palette: [],
        columns: 1,
        size: 20,
        value: '',
        change: function() {}
    },
    init: function (options) {
        var obj = $.extend({}, methods.defaults, options);

        if(typeof options.palette === "string" && methods.palettes[options.palette]) {
            obj.palette = methods.palettes[options.palette];
        }

        obj.element = this;

        var rows = Math.ceil(obj.palette.length / obj.columns);

        var $table = $('<table>').css({'border-collapse': 'collapse',
                                        'position': 'relative',
                                        'width': (+(obj.columns) * (+(obj.size) + 2)) + 'px',
                                        //'height': '100%',
                                        'margin': 0,
                                        'padding': 0,
                                        'border': 0,
                                        'outline': 0,
                                        'text-decoration': 'none',
                                        'font-size': '100%',
                                        'list-style': 'none'
                                    });

        for(var i=0; i<rows; i++) {
            var $tr = $('<tr>');
            for(var j=0; j<obj.columns; j++) {
                var $td = $('<td>', {class: 'palette-item'}).attr('data-color', obj.palette[i*obj.columns + j]).
                    css({width: obj.size, height: obj.size, 'background-color': obj.palette[i*obj.columns + j]});
                $tr.append($td);
            }
            $table.append($tr);
        }

        $table.on('click', 'td', function(){
            obj.value = $(this).data('color');
            obj.change.call(obj);
        });

        this.append($table).css({
            'position': 'relative',
            'line-height': 0,
            'border-width': 0,
            'display': 'inline-block'
        });

        this.data('palette', obj);
    }
};


$.fn.palette = function (options) {

    if(typeof options === "undefined" || typeof options === 'object') {

        return this.each(function(n){
            var selector = $(this);
            methods.init.call(selector, options, n);
            return selector;
        });

    } else if (typeof options === 'string') {

        var args = Array.prototype.slice.call(arguments, 1);

        if (methods[options] && typeof methods[options] == 'function') {

            if(args.length) {
                return this.each(function (n) {
                    var selector = $(this);
                    methods[options].call(selector, args);
                    return selector;
                });
            } else {
                var selector = $(this).eq(0);
                return methods[options].call(selector, args);
            }

        } else {
            return console.error('Method should be function');
        }
    } else {
        return console.error('Options should be object, string or undefined');
    }

};
})(jQuery);
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

if(typeof tzOffsetMoscow == "undefined") {
    tzOffsetMoscow = 10800;
}

if(typeof LANG_NAME == "undefined") {
    LANG_NAME = 'en';
}

if(typeof TEXT_TRANSLATOR_MODE == "undefined") {
//    TEXT_TRANSLATOR_MODE = 'ru';
}

if(typeof IGUANACHART_THEME == "undefined") {
    IGUANACHART_THEME = "White";
}

if(typeof MOBILE_BROWSER_DETECTED == "undefined") {
    MOBILE_BROWSER_DETECTED = false;
}

function formatDate(offset, time) {
    var date = new Date();
    var time = date.getTime();
    var changedDate = new Date(time + (+(offset) * 86400000/*24 * 60 * 60 * 1000*/));
    date.setTime(changedDate.getTime());
    return iChart.formatDateTime(date, "dd.MM.yyyy") + ((time)?' 23:59':'');
}

function getElementSize(element) {
    return {
        width: element.width === undefined 
            ? element.offsetWidth
            : element.width / window.devicePixelRatio,
        height: element.height === undefined
            ? element.offsetHeight
            : element.height / window.devicePixelRatio
    };
}

Date.parse = function(input) {

    if (!input)
    {
        return null;
    }

    if (input instanceof Date)
    {
        return input.getTime();
    }

    var matches = input.match(/^\s*([0-9]{4})-([0-9]{2})-([0-9]{2})[\s|T]{0,1}(?:\s*(\d\d{0,1}):?(\d\d{0,1})(?::?(\d\d{0,1}))?(?:\.([0-9]{0,3}))?)?\s*$/);

    if (matches)
    {
        var result = new Date(matches[1], matches[2] - 1, matches[3]);
        if (typeof matches[4] !== "undefined" && typeof matches[5] !== "undefined")
        {
            result.setHours(matches[4], matches[5], matches[6] || 0, matches[7] || 0);
        }
        return result.getTime();
    }

    var matches = input.match(new RegExp("^\\s*([0-9]{1,2})(?:\.|-|/|\\s)([0-9]{1,2})(?:\.|-|/|\\s)([0-9]{4})(?:\\s*([0-9]{1,2}):?([0-9]{1,2})(?::?([0-9]{1,2}))?)?\\s*$"));
    if (matches)
    {
        var result = new Date(matches[3], matches[2] - 1, matches[1]);
        if (typeof matches[4] !== "undefined" && typeof matches[5] !== "undefined")
        {
            result.setHours(matches[4], matches[5], matches[6] || 0);
        }
        return result.getTime();
    }

    return new Date(input).getTime();
}

if(typeof _t == "undefined") {

    /**
     *
     * @type {{}}
     */
    _.data = {};

    /**
     * Получить перевод по хэш ключу
     * @param hash srting  хэш перевода
     * @param str srting текст по умолчанию
     * @return srting
     */
    function _(hash, str) {

        if(typeof _.data !== "undefined") {

            if (!_.data[hash]) {

                if (!!i18n[hash]) {

                    _.data[hash] = i18n[hash];

                    return _.data[hash]
                }

            } else {

                return _.data[hash];
            }

            return str;
        }
    }

    /**
     * Вырезать из строки перевода нужную форму ед/мнж числа
     * @see \My_Translate::getPluralForm  /!\ изменяя этот метод меняйте php копию
     *
     * 1                   2,3,4               5,6...
     * Вася купил N булку||Вася купил N булки||Валя купил N булок
     *
     * В зависимости от $num будет выбрана необходимая форма. Также определение идет от выбранного языка, т.к. ед и мн числа разные
     *
     * @param text           Строка перевода вида "Вася купил %QTY% булку||Вася купил %QTY% булки||Валя купил %QTY% булок"
     * @param num            кол-во из фразы
     * @param langShortName  язык
     *
     * @return int  фраза в нужном мнж числе
     */
    function translateGetPluralForm (text, num, langShortName)
    {
        // сперва узнаем - целое ли?
        var isInt   = parseInt(num) == num;
        var form    = 2;

        // --- RU и UK - разбор русского и украинского языков, правила одинаковые ---
        if (langShortName == 'ru' || langShortName == 'uk') {

            // все дробные как форма 2.
            if (!isInt) {
                form = 2;
            } else {

                var endTwo = ("" + num + "").length > 1 ? ("" + num + "").substr(-2, 1) : false;
                if (endTwo == '1') {
                    form = 3;
                } else {
                    var end = ("" + num + "").substr(-1);

                    switch (end) {
                        case '1':
                            form = 1;
                            break;

                        case '2':     case '3':     case '4':
                        form = 2;
                        break;

                        default:
                        case '0':     case '5':     case '6':     case '7':     case '8':     case '9':
                        form = 3;
                        break;
                    }
                }
            }
        }

        // --- EN - разбор англ. языка ---
        else if (langShortName == 'en') {

            // все просто: > 1 - мнж, <= 1 - ед, видимо программисты придумывали язык
            if (num > 1) {
                form = 2;
            } else {
                form = 1;
            }
        }

        // --- Все остальные, пока аналог EN ---
        else {

            if (num > 1) {
                form = 2;
            } else {
                form = 1;
            }
        }

        var strings = text.split('||');

        if (typeof strings[form - 1] === 'undefined') {
            return strings[0];
        } else {
            return strings[form - 1];
        }
    }

    _t = function (id, txtOrig, variables)
    {
        var translate  = '';
        var itsOrig    = false;
        var pluralMode = (((typeof variables == 'object')) && (typeof variables.QTY !== 'undefined') && (txtOrig.indexOf("||") != -1));

        translate = _(id, txtOrig);

        if (typeof translate === 'undefined' || translate == txtOrig) {
            translate   = txtOrig;
            itsOrig = true;
        }

        if (pluralMode) {
            translate = translateGetPluralForm(translate, variables.QTY, itsOrig ? 'ru' : LANG_NAME);
        }

        if (typeof variables == 'object') {
            $.each(variables, function(index, value) {
                translate = translate.replace(new RegExp('%'+index+'%','g'), value);
            });
        }

        return ' '+translate+' ';
    }
}

if(typeof String.prototype.hashCode == "undefined") {
    String.prototype.hashCode = function () {
        var hash = 0, i, chr, len;
        if (this.length == 0) return hash;
        for (i = 0, len = this.length; i < len; i++) {
            chr = this.charCodeAt(i);
            hash = ((hash << 5) - hash) + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    };
}

if(typeof getTimeOffsetServer == "undefined") {
    /**
     * Получить разницу локального и серверного времени
     * @param serverOffset в секундах
     * @returns {number}  в милисекундах
     */
    getTimeOffsetServer = function (serverOffset) {
        serverOffset = serverOffset || 0;
        var d = new Date()
        var tzLocalOffset = d.getTimezoneOffset();
        return (serverOffset) + (tzLocalOffset * 60);
    }
}

function intervalNames(interval) {
    switch (interval) {
        case "S30":
            return _t('2072', "30 секундный");
        case "I1":
            return _t('2073', "минутный");
        case "I5":
            return _t('2074', "5 минутный");
        case "I15":
            return _t('2075', "15 минутный");
        case "H1":
            return _t('2076', "Часовик");
        case "D1":
            return _t('2077', "Дневной");
        case "D7":
            return _t('2078', 'Недельный');
        default:
            return "";
    }
}

function intervalShortNames(interval) {
    switch (interval) {
        case "S30":
            return _t('1176', "30c");
        case "I1":
            return _t('1370', "М");
        case "I5":
            return _t('3331', "5М");
        case "I15":
            return _t('3332', "15М");
        case "H1":
            return _t('3333', "Ч");
        case "D1":
            return _t('1368', "Д");
        case "D3":
            return _t('15824', "3Д");
        case "D7":
            return _t('1369', 'Н');
        case "M1":
            return _t('1370', 'М');
        case "M3":
            return _t('1371', '3М');
        default:
            return "";
    }
}

(function (w)
{
    "use strict";

    // IE8 (initial release) bugfix for '' becoming 'null'. See http://support.microsoft.com/kb/976662 for details.
    if (typeof JSON !== "undefined" && JSON.stringify(document.createElement("input").value) !== "")
    {
        (function ()
        {
            var _replacer = function (k, v) { return v === "" ? "" : v; };
            var _stringify = JSON.stringify;
            JSON.stringify = function (v, r, s)
            {
                return _stringify(v, _replacer, s);
            };
        })();
    }

    // Array indexOf shim for IE8.
    if (!Array.prototype.indexOf)
    {
        Array.prototype.indexOf = function (searchElement, fromIndex)
        {
            /// <summary>
            /// Returns the first index at which a given element can be found in the array, or -1 if it is not present.
            /// </summary>
            /// <returns type="Number" />

            if (typeof fromIndex === "undefined")
            {
                fromIndex = 0;
            }
            else
            {
                fromIndex = parseInt(fromIndex, 10);
            }

            if (fromIndex >= this.length)
            {
                return -1;
            }

            if (fromIndex < 0)
            {
                fromIndex = Math.max(0, this.length + fromIndex);
            }

            for (var i = fromIndex; i < this.length; ++i)
            {
                if (this[i] === searchElement)
                {
                    return i;
                }
            }

            return -1;
        };
    }

    //+ Jonas Raoni Soares Silva
    //@ http://jsfromhell.com/string/expand-exponential [rev. #1]
    String.prototype.expandExponential = function ()
    {
        /// <summary>
        /// Expands a number in the exponential form to the decimal form.
        /// </summary>
        /// <returns type="String" />

        return this.replace(/^([+-])?(\d+).?(\d*)[eE]([-+]?\d+)$/, function (x, s, n, f, c)
        {
            var l = +c < 0, i = n.length + +c, x = (l ? n : f).length,
            c = ((c = Math.abs(c)) >= x ? c - x + l : 0),
            z = (new Array(c + 1)).join("0"), r = n + f;
            return (s || "") + (l ? r = z + r : r += z).substr(0, i += l ? z.length : 0) + (i < r.length ? "." + r.substr(i) : "");
        });
    };

    w.inheritPrototype = function (subtype, supertype)
    {
        /// <summary>
        /// Inherits the specifed subtype from the specified supertype.
        /// </summary>
        /// <param name="subtype">Subtype that should inherit fields and methods from supertype.</param>
        /// <param name="supertype">Supertype that provides fields and methods to inherit.</param>

        var dummy = function () { };
        dummy.prototype = supertype.prototype;
        subtype.prototype = new dummy();
        subtype.prototype.constructor = subtype;
    };

    var padLeft = function (input)
    {
        return (input < 10 ? "0" + input : input);
    };

    if (typeof w.iChart === "undefined")
    {
        w.iChart = {};
    }

    w.iChart.dayShortNames = [_t('2129', 'Пн'), _t('2130', 'Вт'), _t('2131', 'Ср'), _t('2132', 'Чт'), _t('2133', 'Пт'), _t('2134', 'Сб'), _t('2135', 'Вс')];
    w.iChart.monthNames = [_t('3280', 'Январь'), _t('3281', 'Февраль'), _t('3282', 'Март'), _t('3283', 'Апрель'), _t('3284', 'Май'), _t('3285', 'Июнь'), _t('3286', 'Июль'), _t('3287', 'Август'), _t('3288', 'Сентябрь'), _t('3289', 'Октябрь'), _t('3290', 'Ноябрь'), _t('3291', 'Декабрь')];
    w.iChart.monthRNames = [_t('1889', "января"), _t('1890', "февраля"), _t('1891', "марта"), _t('1892', "апреля"), _t('1893', "мая"), _t('1894', "июня"), _t('1895', "июля"), _t('1896', "августа"), _t('1897', "сентября"), _t('1898', "октября"), _t('1899', "ноября"), _t('1900', "декабря")];
    w.iChart.monthShortNames = [_t('3502', 'янв'), _t('3503', 'фев'), _t('3504', 'мар'), _t('3505', 'апр'), _t('4939', "май"), _t('3507', 'июн'), _t('3508', 'июл'), _t('3509', 'авг'), _t('3510', 'сен'), _t('3511', 'окт'), _t('3512', 'ноя'), _t('3513', 'дек')];

    w.iChart.declineNoun = function (n, singular, dual, plural)
    {
        /// <summary>
        /// Declines the specified russian noun based on its singular, dual and plural forms.
        /// </summary>
        /// <returns type="String" />

        n = Math.abs(n);
        n %= 100;
        if (n >= 5 && n <= 20)
        {
            return plural;
        }

        n %= 10;
        if (n == 1)
        {
            return singular;
        }

        if (n >= 2 && n <= 4)
        {
            return dual;
        }

        return plural;
    };

    w.iChart.formatDateTime = function (input, format)
    {
        /// <summary>
        /// Provides some basic formatting capabilities for the date/time objects.
        /// </summary>
        /// <param name="input" type="Date">Date to format.</param>
        /// <param name="format" type="String">Format string (optional). Understands d, dd, M, MM, MMM, yy, yyyy, H, HH, m, mm, s, ss.</param>
        /// <returns type="String" />

        if (!input)
        {
            return "";
        }

        if (!format)
        {
            if (input.getHours() === 0 && input.getMinutes() === 0)
            {
                format = "dd.MM.yyyy";
            }
            else if (input.getSeconds() === 0)
            {
                format = "dd.MM.yyyy HH:mm";
            }
            else
            {
                format = "dd.MM.yyyy HH:mm:ss";
            }
        }

        var token = "";
        var tokens = [];
        for (var i = 0; i < format.length; ++i)
        {
            var c = format.charAt(i);
            if (token.length === 0)
            {
                token = c;
                continue;
            }

            var p = token.charAt(token.length - 1);
            if (c !== 'd' && c !== 'M' && c !== 'y' && c !== 'H' && c !== "m" && c !== "s")
            {
                if (p !== 'd' && p !== 'M' && p !== 'y' && p !== 'H' && p !== "m" && p !== "s")
                {
                    token += c;
                    continue;
                }
            }
            else if (c === p)
            {
                token += c;
                continue;
            }

            tokens.push(token);
            token = c;
        }

        if (token.length !== 0)
        {
            tokens.push(token);
        }

        var result = "";
        for (var i = 0; i < tokens.length; ++i)
        {
            var token = tokens[i];
            switch (token)
            {
                case "d":
                    result += input.getDate();
                    break;
                case "dd":
                    result += padLeft(input.getDate());
                    break;
                case "M":
                    result += input.getMonth() + 1;
                    break;
                case "MM":
                    result += padLeft(input.getMonth() + 1);
                    break;
                case "MMM":
                    result += w.iChart.monthShortNames[input.getMonth()];
                    break;
                case "MMMM":
                    result += w.iChart.monthRNames[input.getMonth()];
                    break;
                case "yy":
                    result += input.getFullYear().toString().substr(2, 2);
                    break;
                case "yyyy":
                    result += input.getFullYear();
                    break;
                case "H":
                    result += input.getHours();
                    break;
                case "HH":
                    result += padLeft(input.getHours());
                    break;
                case "m":
                    result += input.getMinutes();
                    break;
                case "mm":
                    result += padLeft(input.getMinutes());
                    break;
                case "s":
                    result += input.getSeconds();
                    break;
                case "ss":
                    result += padLeft(input.getSeconds());
                    break;
                default:
                    result += token;
                    break;
            }
        }

        return result;
    };

    w.iChart.formatNumber = function (number, formatProvider)
    {
        /// <summary>
        /// Converts the numeric value to its equivalent string representation using the specified format information.
        /// </summary>
        /// <returns type="String" />

        if (typeof number === "undefined" || number === null)
        {
            return "";
        }

        formatProvider = $.extend(
            {
                "decimalPlaces": null,
                "decimalPrecision": null,
                "decimalSeparator": ".",
                "scale": 0,
                "thousandsSeparator": " "
            },
            formatProvider);

        if (formatProvider.scale !== 0)
        {
            number = number / Math.pow(10, 3 * formatProvider.scale);
        }

        var fixedDecimalPlaces = formatProvider.decimalPlaces !== null;
        var roundedNumber;
        if (fixedDecimalPlaces)
        {
            roundedNumber = parseFloat(w.iChart.toFixed(number, formatProvider.decimalPlaces));
        }
        else if (formatProvider.decimalPrecision !== null)
        {
            roundedNumber = parseFloat(number.toPrecision(formatProvider.decimalPrecision));
        }
        else
        {
            roundedNumber = number;
        }

        var numberParts = roundedNumber.toString().expandExponential().split(".");
        if (numberParts[0].length > 3)
        {
            numberParts[0] = numberParts[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, formatProvider.thousandsSeparator);
        }

        if (fixedDecimalPlaces && (numberParts[1] || "").length < formatProvider.decimalPlaces)
        {
            numberParts[1] = numberParts[1] || "";
            numberParts[1] += new Array(formatProvider.decimalPlaces - numberParts[1].length + 1).join("0");
        }

        var result = numberParts.join(formatProvider.decimalSeparator).replace("-", "−");
        switch (formatProvider.scale)
        {
            case 0:
                break;
            case 1:
                result += _t('3496', "тыс.");
                break;
            case 2:
                result += _t('2137', "млн");
                break;
            case 3:
                result += _t('4708', "млрд");
                break;
            case 4:
                result += _t('2139', "трлн");
                break;
            default:
                throw new Error("Number scale '" + formatProvider.scale + "' is invalid.");
        }

        return result;
    };

    w.iChart.parseDateTime = function (input, format)
    {
        /// <summary>
        /// Tries to parse the specified string as a date/time in d.M.yyyy H:m:s format (hours/minutes/seconds are optional). Returns null if parsing fails.
        /// </summary>
        /// <param name="input" type="String">Input string.</param>
        /// <param name="format" type="String">Format string.</param>
        /// <returns type="Date" />

        if (!input)
        {
            return null;
        }

        if (input instanceof Date)
        {
            return input;
        }

        if (format === "yyyyMMddHHmm")
        {
            var matches = input.match(new RegExp("^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})$"));
            if (!matches)
            {
                return null;
            }

            var result = new Date(matches[1], matches[2] - 1, matches[3], matches[4], matches[5], 0, 0);
            return result;
        }

        if (format === "yyyy-MM-dd HH:mm:ss")
        {
            var matches = input.match(new RegExp("^([0-9]{4})-([0-9]{2})-([0-9]{2})\\s([0-9]{2}):([0-9]{2}):([0-9]{2})"));
            if (!matches)
            {
                return null;
            }

            var result = new Date(matches[1], matches[2] - 1, matches[3], matches[4], matches[5], matches[6], 0);
            return result;
        }

        var matches = input.match(new RegExp("^\\s*([0-9]{1,2})(?:\.|-|/|\\s)([0-9]{1,2})(?:\.|-|/|\\s)([0-9]{4})(?:\\s*([0-9]{1,2}):?([0-9]{1,2})(?::?([0-9]{1,2}))?)?\\s*$"));
        if (!matches)
        {
            return null;
        }

        var result = new Date(matches[3], matches[2] - 1, matches[1]);
        if (typeof matches[4] !== "undefined" && typeof matches[5] !== "undefined")
        {
            result.setHours(matches[4], matches[5], matches[6] || 0);
        }

        return result;
    };

    w.iChart.parseQueryString = function (queryString)
    {
        /// <summary>
        /// Parses a query string into an associative array.
        /// </summary>
        /// <returns type="String" />

        if(typeof queryString != "string") {
            return {};
        }
        var questionMarkIndex = queryString.indexOf("?");
        if (questionMarkIndex !== -1)
        {
            queryString = queryString.substr(questionMarkIndex + 1);
        }

        var chunks = queryString.split("&");
        var params = {};
        for (var i = 0; i < chunks.length; ++i)
        {
            var kvp = chunks[i].split("=");
            if (kvp.length !== 2)
            {
                continue;
            }

            var paramKey = decodeURIComponent(kvp[0]);
            var paramValue = decodeURIComponent(kvp[1]);
            switch (typeof params[paramKey])
            {
                case "object":
                    params[paramKey].push(paramValue);
                    break;
                case "string":
                    params[paramKey] = [params[paramKey], paramValue];
                    break;
                case "undefined":
                    params[paramKey] = paramValue;
                    break;
                default:
                    break;
            }
        }

        return params;
    };
/*
    w.iChart.setHashValue = function (key, value)
    {
        /// <summary>
        /// Sets value at the specified key in the location hash.
        /// </summary>
        /// <param name="key">A key at which the value should be stored.</param>
        /// <param name="value">A value to set.</param>

        if (userSettings.dataSettings.useHash == false) {
            var currentHash = userSettings.dataSettings.hash;
        } else {
            var currentHash = document.location.hash;
        }
        var values = w.iChart.parseQueryString(currentHash.substr(1));
        values[key] = value;
        var hash = "#" + w.iChart.toQueryString(values);
        if (hash !== currentHash)
        {
            if (userSettings.dataSettings.useHash == false) {
                userSettings.dataSettings.hash = hash;
            } else {
                document.location.hash = hash;
            }
        }
    };

    w.iChart.setHashValues = function (valuesNew)
    {
        /// <summary>
        /// Sets values at the specified keys in the location hash.
        /// </summary>
        /// <param name="valuesNew" type="Object">A dictionary of values to set.</param>

        if (userSettings.dataSettings.useHash == false) {
            var currentHash = userSettings.dataSettings.hash;
        } else {
            var currentHash = document.location.hash;
        }

        var values = w.iChart.parseQueryString(currentHash.substr(1));
        for (var key in valuesNew)
        {
            if (valuesNew.hasOwnProperty(key))
            {
                values[key] = valuesNew[key];
            }
        }
        var hash = "#" + w.iChart.toQueryString(values);
        if (hash !== currentHash && !$.isEmptyObject(values))
        {
            if (userSettings.dataSettings.useHash == false) {
                userSettings.dataSettings.hash = hash;
            } else {
                document.location.hash = hash;
            }
        }
    };
*/
    w.iChart.toFixed = function (number, decimalPlaces)
    {
        /// <remarks>
        /// IE6-8 bugfix: X.toFixed(0) wrongly rounds towards zero when |X| is in the range [0.50, 0.95).
        /// </remarks>
        /// <returns type="Number" />

        var scale = Math.pow(10, decimalPlaces);
        return Math.round(number * scale) / scale;
    };

    /**
     *
     * @param number
     * @param precision 0.01|0.5|0.025
     * @returns {float}
     */
    w.iChart.roundToPrecision = function (number, precision)
    {
        precision = parseFloat(precision)
        if (precision < 1) {
            var scale = parseFloat(precision).toString().length-2;
            return +((Math.round(number * (1/precision)) / (1/precision)).toFixed(scale));
        } else {
            return +((Math.round(number * (1/precision)) / (1/precision)).toFixed(0));
        }

    }

    w.iChart.toQueryString = function (params, questionMark)
    {
        /// <summary>
        /// Converts the specified associative array to HTTP query string (starting '?' is omitted by default).
        /// </summary>
        /// <returns type="String" />

        var paramStrings = [];
        for (var key in params)
        {
            if (!params.hasOwnProperty(key))
            {
                continue;
            }

            var value = params[key];
            if (typeof value === "undefined" || value === null || value === "")
            {
                continue;
            }

            if ($.isArray(value))
            {
                for (var i = 0; i < value.length; ++i)
                {
                    paramStrings.push(encodeURIComponent(key) + "=" + encodeURIComponent(value[i]));
                }
            }
            else
            {
                if (value instanceof Date)
                {
                    value = iChart.formatDateTime(value);
                }

                paramStrings.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
            }
        }

        var result = "";
        if (questionMark && paramStrings.length !== 0)
        {
            result += "?";
        }

        result += paramStrings.join("&");
        return result;
    };

    w.iChart.rgbToHex = function (rgb)
    {
        if(/^#[a-fA-F0-9]{3,6}$/.test(rgb)){
            if(rgb.length< 7){
                var A= rgb.split('');
                rgb= A[0]+A[1]+A[1]+A[2]+A[2]+A[3]+A[3];
            }
            return rgb;
        }

        rgb = [].slice.call(arguments).join(",").match(/\d+/g);
        var hex,l;l=( hex = ( (rgb[0] << 16 ) + ( rgb[1] << 8 ) + +rgb[2] ).toString(16) ).length;
        while( l++ < 6 )
            hex="0"+hex
        return '#' + hex;
    };

    w.iChart.rgbaGetAlfa = function (rgba)
    {
        var a = rgba.match(/\((.*),(.*),(.*),(.*)\)/);
        if(a && a[4]) {
            return +a[4];
        }
        return 1;
    };

    w.iChart.hexToRGB = function (hex, a)
    {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ?
            'rgba(' +
                parseInt(result[1], 16)+ ',' +
                parseInt(result[2], 16)+ ',' +
                parseInt(result[3], 16)+ ',' +
                a + ')'
            : null;
    };

    w.iChart.invertColor = function (rgb) {
        rgb = [].slice.call(arguments).join(",").replace(/rgb\(|\)|rgba\(|\)|\s/gi, '').split(',');
        for (var i = 0; i < rgb.length; i++) rgb[i] = (i === 3 ? 1 : 255) - rgb[i];
        return rgb.join(", ");
    };

    w.iChart.getIntersection = function (p1, p2, p3, p4)
    {
        if(((p1.y-p2.y)*(p4.x-p3.x)-(p3.y-p4.y)*(p2.x-p1.x)) != 0 && (p4.x-p3.x) != 0) {
            var x=-((p1.x*p2.y-p2.x*p1.y)*(p4.x-p3.x)-(p3.x*p4.y-p4.x*p3.y)*(p2.x-p1.x))/((p1.y-p2.y)*(p4.x-p3.x)-(p3.y-p4.y)*(p2.x-p1.x));
            var y=((p3.y-p4.y)*(-x)-(p3.x*p4.y-p4.x*p3.y))/(p4.x-p3.x);
            return {x: x, y: y};
        } else {
            return false;
        }
    }

    w.iChart.getThirdPoint = function (point1, point2, x)
    {
        var y = (((parseFloat(x)-parseFloat(point1.x))*(parseFloat(point2.y)-parseFloat(point1.y)))/(parseFloat(point2.x)-parseFloat(point1.x)))+parseFloat(point1.y);
        return {x: parseFloat(x), y: y};
    }

    w.iChart.getLineEquation = function (point1, point2, x)
    {
        var k = (+(point2.y) - +(point1.y)) / (+(point2.x) - +(point1.x)),
            b = +(point1.y) - k * (point1.x);
        var y = k * +(x) + b;
        return {x: +(x), y: y, k: k, b: b};
    }

    w.iChart.getChartTimeframe = function (timeframe) {
        switch (timeframe) {
            case "I1":
                return 1;
            case "I5":
                return 5;
            case "I15":
                return 15;
            case "H1":
                return 60;
            case "D1":
                return 1440;
            case "D7":
                return 10080;
            default:
                return 1440;
        }
    };
    /**
     *
     * @param canvas
     * @returns {CanvasRenderingContext2D | WebGLRenderingContext}
     */
    w.iChart.getContext = function (canvas) {
        var ctx = canvas.getContext('2d');
        if(!ctx.scaled) {
            var dpr = Math.max(window.devicePixelRatio || 1, 1);
            ctx.scale(dpr, dpr);
            ctx.scaled = 1;
        }
        return ctx;
    };

    w.iChart.animateId = null;
    w.iChart.animate = function (options) {

        var start = performance.now();

        w.iChart.animateId = requestAnimationFrame(function animate(time) {
            // timeFraction от 0 до 1
            var timeFraction = (time - start) / options.duration;
            if (timeFraction > 1) timeFraction = 1;

            // текущее состояние анимации
            var progress = options.timing(timeFraction);

            options.draw(progress);

            if (timeFraction < 1) {
                w.iChart.animateId = requestAnimationFrame(animate);
            } else {
                cancelAnimationFrame(w.iChart.animateId);
                if(typeof options.complete === 'function') {
                    options.complete();
                }
            }
        });
    }

})(window);

/**
 * Created by gti on 14.10.15.
 */

iChart.indicators = {
    "AD":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('428', 'AD (Распределение накопления)'),
        "value": "AD",
        "outputRegion": "self",
        "description": _t('4789', 'Формула распределения накопления использует отношение между объемом и ценами, чтобы оценить интенсивность изменения цен; если объем увеличивается, весьма вероятно, что цены поднимутся.'),
        "parameters":[]
    },
    "ADOSC":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('429', 'ADOSC (Осциллятор Чайкина)'),
        "value": "ADOSC",
        "outputRegion": "self",
        "description":_t('4790', 'Индикатор осциллятора Чайкина – это разница между трехдневным экспоненциальным скользящим средним и десятидневным экспоненциальным скользящим средним, примененная к распределению накопления.'),
        "parameters":[
            {"Code":"FastPeriod", "Name":_t('4791', 'Краткосрочный интервал'), "Value":3},
            {"Code":"SlowPeriod", "Name":_t('4792', 'Долгосрочный интервал'), "Value":10}
        ]
    },
    "ADX":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('430', 'ADX (Индекс направленного движения)'),
        "value": "ADX",
        "outputRegion": "self",
        "description":_t('4793', 'Индикатор среднего направленного движения служит для определения вероятного направления основного тренда.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('5421', 'Интервал'), "Value":14}
        ]
    },
    "ADXDI":{
        "type": 'TA_LIB',
        "output": 3,
        "outputNames": ['ADX','PLUS_DI','MINUS_DI'],
        "name": _t('431', 'ADXDI (Индекс направленного движения (с индикаторами направления))'),
        "value": "ADXDI",
        "outputRegion": "self",
        "description":_t('4793', 'Индикатор среднего направленного движения служит для определения вероятного направления основного тренда.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('5421', 'Интервал'), "Value":14}
        ]
    },
    "AROON":{
        "type": 'TA_LIB',
        "output": 2,
        "outputNames": ['AroonDown','AroonUp'],
        "name": _t('432', 'AROON (Арун)'),
        "value": "AROON",
        "outputRegion": "self",
        "description":_t('4797', 'Индикатор Арун применяется для изучения силы и направления трендов.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('5421', 'Интервал'), "Value":25}
        ]
    },
    "ATR":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('433', 'ATR (Средний истинный диапазон)'),
        "value": "ATR",
        "outputRegion": "self",
        "description":_t('4799', 'Индикатор среднего истинного диапазона измеряет фиксацию и сравнивает диапазоны между высокими и низкими ценами и ценами закрытия.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('5421', 'Интервал'), "Value":14}
        ]
    },
    "BBANDS":{
        "type": 'TA_LIB',
        "output": 3,
        "outputNames": ['UpperBand','MiddleBand','LowerBand'],
        "name": _t('434', 'BBANDS (Уровни Боллинджера)'),
        "value": "BBANDS",
        "outputRegion": "price",
        "description":_t('4801', 'Индикаторы с линиями Боллинджера наносятся на график как уровни стандартного отклонения выше и ниже скользящего среднего.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('5421', 'Интервал'), "Value":7},
            {"Code":"DeviationsUp", "Name":_t('4803', 'Верхнее число станд. отклонения'), "Value":2},
            {"Code":"DeviationsDown", "Name":_t('4804', 'Нижнее число станд. отклонения'), "Value":2}
        ]
    },
    "CCI":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('435', 'CCI (Индекс товарного канала)'),
        "value": "CCI",
        "outputRegion": "self",
        "description":_t('4805', 'Индикатор ценовых моментов сравнивает цены с их скользящими средними.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":10}
        ]
    },
    "CHV":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('436', 'CHV (Волатильность Чайкина)'),
        "value": "CHV",
        "outputRegion": "self",
        "description":_t('4807', 'Индикатор волатильности Чайкина показывает разницу между максимальными и минимальными ценами и используется для обозначения верхних и нижних частей рынка.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('4808', 'Период EMA'), "Value":10},
            {"Code":"PeriodROC", "Name":_t('4809', 'Период ROC'), "Value":10}
        ]
    },
    "DPO":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('437', 'DPO (Осциллятор цен с исключенным трендом)'),
        "value": "DPO",
        "outputRegion": "self",
        "description":_t('4810', 'Осциллятор цен с исключенным трендом пытается исключить из цен тренды.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":20}
        ]
    },
    "ELDR":{
        "type": 'TA_LIB',
        "output": 4,
        "outputNames": ['Bull','Bear','Rays'],
        "name": _t('17699', 'ELDR (Лучи Элдера)'),
        "value": "ELDR",
        "outputRegion": "self",
        "description":_t('17700', 'Индикатор Лучи Элдера поможет вам оценить, в какой момент времени «быки» и «медведи» становятся слабее или сильнее.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":13}
        ]
    },
    "EMA":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('438', 'EMA (Экспоненциальное скользящее среднее)'),
        "value": "EMA",
        "outputRegion": "price",
        "description":_t('4812', 'Экспоненциальное скользящее среднее – это среднее значение данных, рассчитанное за некий период времени, причем последние дни имеют в вычислении больший вес.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":12}
        ]
    },
    "ENV":{
        "type": 'TA_LIB',
        "output": 2,
        "outputNames": ['Upper','Lower'],
        "name": _t('439', 'ENV (Конверты)'),
        "value": "ENV",
        "outputRegion": "price",
        "description":_t('4815', 'Конверты наносятся над и под скользящим средним; смещение определяется указанным процентом.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":20},
            {"Code":"shift", "Name":_t('4817', 'Сдвиг, %'), "Value":1}
        ]
    },
    "MACD":{
        "type": 'TA_LIB',
        "output": 3,
        "outputNames": ['MACD','MACDSignal','MACDHist'],
        "name": _t('441', 'MACD (Конвергенция и дивергенция скользящих средних)'),
        "value": "MACD",
        "outputRegion": "self",
        "description":_t('4818', 'Индикатор конвергенции и дивергенции скользящих средних сравнивает два скользящих средних цен и используется вместе с девятидневным экспоненциальным скользящим средним в качестве сигнала для моментов покупки и продажи.'),
        "parameters":[
            {"Code":"FastPeriod", "Name":_t('4819', 'Краткосрочный период'), "Value":12},
            {"Code":"SlowPeriod", "Name":_t('4820', 'Долгосрочный период'), "Value":26},
            {"Code":"SignalPeriod", "Name":_t('4821', 'Период сигнальной линии'), "Value":9, "MinValue":2}
        ]
    },
    "MEDPRICE":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('443', 'MEDPRICE (Медианная цена)'),
        "value": "MEDPRICE",
        "outputRegion": "price",
        "description":_t('4822', 'Медианные цены – это средние значения цен за день, которые могут использоваться как фильтр для индикаторов трендов.'),
        "parameters":[]
    },
    "MFI":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('444', 'MFI (Денежный поток)'),
        "value": "MFI",
        "outputRegion": "self",
        "description":_t('4823', 'Индикатор денежных потоков сравнивает восходящие и нисходящие изменения типичных цен, приведенных к объему.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":14}
        ]
    },
    "OBV":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('445', 'OBV (Балансовый объём)'),
        "value": "OBV",
        "outputRegion": "self",
        "description":_t('4828', 'Индикатор балансового объема измеряет положительный и отрицательный поток объема.'),
        "parameters":[]
    },
    "PCH":{
        "type": 'TA_LIB',
        "output": 3,
        "name": _t('17701', 'PCH (Price chanel)'),
        "value": "PCH",
        "outputRegion": "price",
        "description":_t('17702', 'price channel это уровни потдержки и сопротивления, которые меняются вместе с ценой.'),
        "parameters":[
            {"Code":"TimePeriodLower", "Name":_t('17703', 'Период Lower'), "Value":20},
            {"Code":"TimePeriodUpper", "Name":_t('17704', 'Период Upper'), "Value":20}
        ]
    },
    "PSAR":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('447', 'PSAR (Параболик)'),
        "value": "PSAR",
        "outputRegion": "price",
        "description":_t('4833', 'Индикатор Параболик помогает определять точки разворота тренда.'),
        "parameters":[
            {"Code":"Acceleration", "Name":_t('860', 'Шаг'), "Value":0.02},
            {"Code":"Maximum", "Name":_t('4835', 'Максимальный шаг'), "Value":0.2}
        ]
    },
    "ROC":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('449', 'ROC (Темп изменения)'),
        "value": "ROC",
        "outputRegion": "self",
        "description":_t('4840', 'Индикатор темпов изменений сравнивает указанную цену закрытия с текущей ценой.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":10}
        ]
    },
    "RSI":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('450', 'RSI (Индекс относительной силы)'),
        "value": "RSI",
        "outputRegion": "self",
        "description":_t('4842', 'Индекс относительной силы – это осциллятор момента, сравнивающий восходящие изменения цены закрытия с нисходящими изменениями и выдающий значения в диапазоне от 0 до 100.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":10}
        ]
    },
    "SMA":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('451', 'SMA (Простое скользящее среднее)'),
        "value": "SMA",
        "outputRegion": "price",
        "description":_t('4844', 'Простое скользящее среднее – это среднее значение данных, рассчитанное за некий период времени. Скользящее среднее – самый распространенный индикатор цен в техническом анализе, который можно использовать с любой ценой, например высокой, низкой, ценами открытия и закрытия, а также применять к другим индикаторам.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":10}
        ]
    },
    "STDDEV":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('452', 'STDDEV (Стандартное отклонение)'),
        "value": "STDDEV",
        "outputRegion": "self",
        "description":_t('4846', 'Стандартное отклонение используется для обозначения волатильности и показывает, например, разницу между значениями цены закрытия и ее скользящего среднего.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":10}
        ]
    },
    "STOCH":{
        "type": 'TA_LIB',
        "output": 2,
        "name": _t('453', 'STOCH (Вероятностный индикатор)'),
        "value": "STOCH",
        "description":_t('4848', 'Вероятностный индикатор помогает находить изменения трендов, обнаруживая моменты, когда цены закрытия приближаются к низким ценам на рынке, имеющем восходящий тренд, и когда цены закрытия близки к высоким ценам на рынке, имеющем нисходящий тренд.'),
        "parameters":[
            {"Code":"PeriodFastK", "Name":_t('4849', 'Краткосрочный период %K'), "Value":5},
            {"Code":"PeriodSlowK", "Name":_t('4850', 'Долгосрочный период %K'), "Value":3},
            {"Code":"PeriodSlowD", "Name":_t('4851', 'Период %D'), "Value":3}
        ]
    },
    "TEMA":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('454', 'TEMA (Тройное экспоненциальное скользящее среднее)'),
        "value": "TEMA",
        "outputRegion": "price",
        "description":_t('4852', 'Тройное экспоненциальное скользящее среднее основано на тройном скользящем среднем цены закрытия. Его назначение – исключить короткие циклы. Этот индикатор сохраняет цену закрытия в трендах, которые короче указанного периода.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":12}
        ]
    },
    "TRIMA":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('455', 'TRIMA (Треугольное скользящее среднее)'),
        "value": "TRIMA",
        "outputRegion": "price",
        "description":_t('4854', 'Треугольное скользящее среднее – это среднее значение данных, рассчитанное за некий период времени, причем средняя часть данных имеет в вычислении больший вес.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":20}
        ]
    },
    "TYPPRICE":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('456', 'TYPPRICE (Типичная цена)'),
        "value": "TYPPRICE",
        "outputRegion": "price",
        "description":_t('4856', 'Типичная цена – это среднее значение цен за день, которое может использоваться как фильтр для индикаторов трендов.'),
        "parameters":[]
    },
    "VPT":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('457', 'VPT (Тренд объёма цен)'),
        "value": "VPT",
        "outputRegion": "self",
        "description":_t('4857', 'Тренд объема цен – это совокупное значение объема, рассчитываемое на основе относительных изменений цены закрытия; его следует использовать с другими индикаторами.'),
        "parameters":[]
    },
    "WCLPRICE":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('458', 'WCLPRICE (Взвешенная цена закрытия)'),
        "value": "WCLPRICE",
        "outputRegion": "price",
        "description":_t('4858', 'Формула взвешенной цены закрытия вычисляет среднее значение цен за день. Единственное отличие взвешенной цены закрытия и типичной цены в том, что у цены закрытия больший вес и она считается самой важной ценой.'),
        "parameters":[]
    },
    "WILLR":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('459', 'WILLR (Процентный диапазон Уильямса)'),
        "value": "WILLR",
        "outputRegion": "self",
        "description":_t('4859', 'Процентный диапазон Уильямса – это индикатор момента, который показывает уровни перекупленности и перепроданности.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":14}
        ]
    },
    "WMA":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('460', 'WMA (Взвешенное скользящее среднее)'),
        "value": "WMA",
        "outputRegion": "price",
        "description":_t('4861', 'Взвешенное скользящее среднее – это среднее значение данных, рассчитанное за некий период времени, причем последние данные имеют в вычислении больший вес.'),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":9}
        ]
    },
    "ZLEMA":{
        "type": 'TA_LIB',
        "output": 1,
        "name": _t('17705', 'ZLEMA (Zero-Lag Moving Average Indicator)'),
        "value": "ZLEMA",
        "outputRegion": "price",
        "description":_t('13667', ''),
        "parameters":[
            {"Code":"TimePeriod", "Name":_t('1296', 'Период'), "Value":12}
        ]
    },
    "TRPLN":{
        "type": 'TA_LIB',
        "output": 0,
        "name": _t('13838', 'TRPLN (Тенденциальная планиметрия)'),
        "value": "TRPLN",
        "outputRegion": "price",
        "description": _t('13843', 'Тенденциальная планиметрия'),
        "parameters":[]
    }
};

/**
* @company  Tradernet
* @package  iguanaChart
*/

(function ()
{
    "use strict";

    if (typeof iChart === "undefined")
    {
        iChart = {};
    }

    iChart.Charting = {};

    iChart.Charting.indexOfFirstElementGreaterThanOrEqualTo = function (arr, val)
    {
        /// <summary>
        /// Finds the index of the first element in the specified sorted array that is greater than or equal to the specified value.
        /// </summary>
        /// <param name="arr" type="Array">Sorted array to search.</param>
        /// <param name="val">Array element to compare against.</param>

        var low = 0;
        var high = arr.length - 1;
        var i;

        if (high === -1)
        {
            return -1;
        }

        if (arr[low] >= val)
        {
            return low;
        }

        if (arr[high] < val)
        {
            return -1;
        }

        while (low <= high)
        {
            if (low === high)
            {
                return low;
            }

            if (low === high - 1)
            {
                return arr[low] < val ? high : low;
            }

            i = Math.floor((low + high) / 2);

            if (arr[i] < val)
            {
                low = i + 1;
            }
            else
            {
                high = i;
            }
        }

        return i;
    };

    iChart.Charting.indexOfLastElementLessThanOrEqualTo = function (arr, val)
    {
        /// <summary>
        /// Finds the index of the last element in the specified sorted array that is less than or equal to the specified value.
        /// </summary>
        /// <param name="arr" type="Array">Sorted array to search.</param>
        /// <param name="val">Array element to compare against.</param>

        var low = 0;
        var high = arr.length - 1;
        var i;

        if (high === -1)
        {
            return -1;
        }

        if (arr[low] > val)
        {
            return -1;
        }

        if (arr[high] <= val)
        {
            return high;
        }

        while (low <= high)
        {
            if (low === high)
            {
                return low;
            }

            if (low === high - 1)
            {
                return arr[high] <= val ? high : low;
            }

            i = Math.floor((low + high) / 2);

            if (arr[i] > val)
            {
                high = i - 1;
            }
            else
            {
                low = i;
            }
        }

        return i;
    };

    iChart.Charting.getNearestNotNullIndex = function(arr, index)
    {
        var indexL, indexR;
        indexL = indexR = index;

        while(1) {
            if($.isArray(arr[indexL])) {
                if(arr[indexL][0] != null)
                    return indexL;
            } else {
                if(arr[indexL] != null)
                    return indexL;
            }
            if($.isArray(arr[indexR])) {
                if(arr[indexR][0] != null)
                    return indexR;
            } else {
                if(arr[indexR] != null)
                    return indexR;
            }
            indexL > 0 ? indexL-- : '';
            indexR < arr.length-1 ? indexR++ : '';

            if(indexL < 0 && indexR > arr.length-1) {
                return false;
            }
        }
    }

    iChart.Charting.initCanvas = function (container, oldCanvas, newWidth, newHeight)
    {
        /// <summary>
        /// Initializes a HTML5 canvas with the specified width and height.
        /// </summary>
        /// <param name="newWidth" type="Number">Canvas width in pixels.</param>
        /// <param name="newHeight" type="Number">Canvas height in pixels.</param>

        if (!container) {
            console.log('No chart container. Abort');
            return;
        }

        var dpr = Math.max(window.devicePixelRatio || 1, 1);
        newWidth = newWidth * dpr;
        newHeight =  newHeight * dpr;

        if (oldCanvas)
        {
            if (oldCanvas.width === newWidth && oldCanvas.height === newHeight)
            {
                return oldCanvas;
            }

            if (typeof FlashCanvas === "undefined")
            {
                oldCanvas.width = newWidth;
                oldCanvas.height = newHeight;
                var ctx = oldCanvas.getContext('2d');
                ctx.scaled = 0;

                return oldCanvas;
            }

            $(oldCanvas).remove();
        }

        var newCanvas = document.createElement("canvas");
        newCanvas.style.left = 0;
        newCanvas.style.position = "absolute";
        newCanvas.style.top = 0;
        $(newCanvas).unbind("selectstart");
        $(newCanvas).attr("unselectable", "on").css("user-select", "none").on("selectstart", false);

        container.appendChild(newCanvas);
        if (typeof newCanvas.getContext === "undefined")
        {
            if (typeof FlashCanvas === "undefined")
            {
                alert(_t("87550", "Ваш браузер не поддерживается."));
                return null;
            }

            FlashCanvas.initElement(newCanvas);
        }

        newCanvas.width = newWidth;
        newCanvas.height = newHeight;
        return newCanvas;
    };

    iChart.Charting.pointToPointDistanceSquared = function (a, b)
    {
        /// <summary>
        /// Gets the squared distance between the two specified points on a plane.
        /// </summary>
        /// <param name="a">Coordinates of the first point.</param>
        /// <param name="b">Coordinates of the second point.</param>
        /// <returns type="Number">Squared distance between the two points.</returns>

        var x = a.x - b.x;
        var y = a.y - b.y;
        return (x * x) + (y * y);
    };

    iChart.Charting.pointToSegmentDistanceSquared = function (segment, point, ignoreOutside)
    {
        /// <summary>
        /// Gets the squared distance between the specified segment and the specified point on a 2D plane.
        /// </summary>
        /// <param name="a">Coordinates of the first point.</param>
        /// <param name="b">Coordinates of the second point.</param>
        /// <param name="ignoreOutside">A value indicating whether the distance is calculated to the segment itself or the line on which it resides.</param>
        /// <returns type="Number">Squared distance between the segment and a point on a 2D plane.</returns>

        var a = ((point.x - segment[0].x) * (segment[1].x - segment[0].x)) + ((point.y - segment[0].y) * (segment[1].y - segment[0].y));
        if (a < 0)
        {
            return ignoreOutside ? Infinity : iChart.Charting.pointToPointDistanceSquared(point, segment[0]);
        }

        var b = iChart.Charting.pointToPointDistanceSquared(segment[1], segment[0]);
        var epsilon = 1e-5;
        if (a > b || b < epsilon)
        {
            return ignoreOutside ? Infinity : iChart.Charting.pointToPointDistanceSquared(point, segment[1]);
        }

        var c = a / b;
        var intersection = {
            "x": segment[0].x + (c * (segment[1].x - segment[0].x)),
            "y": segment[0].y + (c * (segment[1].y - segment[0].y))
        };

        return iChart.Charting.pointToPointDistanceSquared(point, intersection);
    };
})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartWidgetLayer = function (chart, settings)
    {

        this.canvas = null;
        this.chart = chart;
        this.widget = {
            widgetCurPrice: {
                enable: false,
                width: 200,
                height: 44,
                valign: 'top',
                halign: 'left',
                vspace: 0,
                hspace: 50
            }
        };
        this.prevX = null;
        this.prevY = null;
        this.prevValueX = null;
        this.prevValueY = null;
        this.xIndex = null;
        this.xPoint = null;
        this.yPoint = null;

        if(typeof settings != "undefined") {
            for (var widget in settings) {
                this.widget[widget] = $.extend(this.widget[widget], settings[widget]);
            }
        }

        $(chart.container).off('mousedown.WidgetLayer').off('mouseup.WidgetLayer').off('mousemove.WidgetLayer').off('mouseout.WidgetLayer');
        $(chart.container).on('mousedown.WidgetLayer', $.proxy(this.onMouseDown, this)).
        on('mouseup.WidgetLayer', $.proxy(this.onMouseUp, this)).
        on('mousemove.WidgetLayer', $.proxy(this.onMouseMove, this)).
        on('mouseout.WidgetLayer', $.proxy(this.onMmouseOut, this));

    };

    iChart.Charting.ChartWidgetLayer.prototype.clear = function ()
    {
        if(!this.context) {
            console.log("ERROR: No context for render");
            return 0;
        }

        var context = this.context;
        var canvasSize = getElementSize(context.canvas);
        this.context.clearRect(0, 0, canvasSize.width, canvasSize.height);
        this.drawWidgets(context);

    };

    iChart.Charting.ChartWidgetLayer.prototype.render = function (context)
    {
        /// <summary>
        /// Redraws the layer.
        /// </summary>

        if (!context)
        {
            if(!this.context) {
                console.log("ERROR: No context for render");
                return 0;
            }
            context = this.context;
            var canvasSize = getElementSize(context.canvas);
            context.clearRect(0, 0, canvasSize.width, canvasSize.height);
        }

        context.save();
        this.drawWidgets(context);
        this.drawCrosshair(context, {});
        context.restore();

        if (typeof FlashCanvas !== "undefined")
        {
            // Flush and execute commands.
            context.e();
        }
    };

    iChart.Charting.ChartWidgetLayer.prototype.update = function ()
    {
        /// <summary>
        /// Updates drawing layer.
        /// </summary>

        if (!this.chart.areas)
        {
            return;
        }

        this.area = this.chart.areas[0];
        var $container = $(this.chart.container);
        this._initCanvas($container.width(), $container.height());
        this.render();
    };

    iChart.Charting.ChartWidgetLayer.prototype._initCanvas = function (width, height)
    {
        /// <summary>
        /// Initializes the canvas.
        /// </summary>
        /// <param name="width" type="Number">Canvas width in pixels.</param>
        /// <param name="height" type="Number">Canvas height in pixels.</param>

        this.canvas = iChart.Charting.initCanvas(this.chart.container, this.canvas, width, height);
        if (this.canvas)
        {
            this.context = iChart.getContext(this.canvas);
            this.offset = this.chart._containerSize.offset;
        }
    };

    iChart.Charting.ChartWidgetLayer.prototype.drawWidgets = function (ctx)
    {
        //ctx.save();
        //ctx.strokeStyle="#FF0000";
        //var canvasSize = getElementSize(ctx.canvas);
        //ctx.strokeRect(0, 0, canvasSize.width-1, canvasSize.height-1);
        //ctx.restore();

        for (var widget in this.widget) {
            if(this.widget[widget].enable) {
                this[widget](ctx, this.widget[widget]);
            }
        }
    };

    iChart.Charting.ChartWidgetLayer.prototype.onMouseDown = function (e) {

    };
    iChart.Charting.ChartWidgetLayer.prototype.onMouseUp = function (e) {

    };
    iChart.Charting.ChartWidgetLayer.prototype.onMmouseOut = function (e) {
        this.clear();
    };
    iChart.Charting.ChartWidgetLayer.prototype.onMouseMove = function (e) {

        if (typeof this.offset === "undefined")
        {
            return;
        }

        var pageX = e.pageX;
        var pageY = e.pageY;

        if (pageX === this.pageX && pageY === this.pageY)
        {
            return;
        }

        this.pageX = pageX;
        this.pageY = pageY;


        var x = Math.round(e.pageX - this.offset.left - this.area.innerOffset.left);
        var y = Math.round(e.pageY - this.offset.top - this.area.innerOffset.top);

        if (x === this.prevX && y === this.prevY)
        {
            // Minor performance optimization: do not handle the same coordinates twice in a row.
            return;
        }

        this.prevX = x;
        this.prevY = y;

        var valueX = 1000 * this.area.getXValue(x);
        var valueY = this.area.getYValue(y);

        this.prevValueX = valueX;
        this.prevValueY = valueY;



        this.render();
    };


    iChart.Charting.ChartWidgetLayer.prototype.widgetCurPrice = function (ctx, options)
    {
        var width = options.width,
            height = options.height;


        if(options.valign == 'top') {
            var yT = this.area.innerOffset.top+options.vspace;
        } else {
            var yT = this.area.innerHeight+this.area.innerOffset.top-height-options.vspace;
        }

        if(options.halign == 'left') {
            var xT = this.area.innerOffset.left+options.hspace;
        } else {
            var xT = this.area.innerWidth+this.area.innerOffset.left-width-options.hspace;
        }

        ctx.save();
        ctx.translate(xT, yT);
        ctx.beginPath();
        ctx.moveTo(0, height);
        ctx.lineTo(width, height);
        ctx.lineTo(width, 0);
        ctx.lineTo(0, 0);
        ctx.closePath();
        ctx.clip();

        ctx.fillStyle = "rgba(214,218,225,0.75)";
        ctx.strokeStyle = "rgba(171,177,192,1)";
        ctx.fillRect(0,0,width,height);
        ctx.rect(0,0,width,height);
        ctx.stroke();


        var q = this.chart.env.userSettings.currentSecurity.q;
        ctx.fillStyle = '#20232a';
        ctx.font = 'normal 26px Arial,Helvetica,sans-serif';
        ctx.textBaseline = "middle";

        if(!this.chart.areas[0].ySeries[0]) { return;}
        var lastIndex = this.chart.areas[0].ySeries[0].points.length-this.chart.chartOptions.futureAmount-1;
        var pointX = this.chart.areas[0].xSeries[lastIndex];
        var pointY = this.chart.areas[0].ySeries[0].points[lastIndex];

        var price = pointY[3];
        var deg = (1/this.chart.env.userSettings.currentSecurity.min_step > 1) ? (Math.round(1/this.chart.env.userSettings.currentSecurity.min_step)).toString().length-1 : 0;
        price = price.toFormat(deg,'.',' ');
        ctx.fillText(price, 10, 30);

        ctx.textBaseline = "top";
        var dataLabel = iChart.formatDateTime(new Date(pointX * 1000), "dd MMMM HH:mm");

        ctx.font = 'normal 11px Arial,Helvetica,sans-serif';
        ctx.fillText(dataLabel, 10, 5);

        /*
        if(q.chg >= 0) {
            ctx.fillStyle = '#228B22';
        } else {
            ctx.fillStyle = '#b7333b';
        }
        var chg = parseFloat(q.chg);
        var sign = (chg > 0) ? "▲+":"▼";
        var diff = q.chg=='0'?'0.00': sign + chg.toFormat(Math.max(chg.getDegree(),2),'.',' ');
        ctx.fillText(diff, 140, 13);

        if(q.pcp) {
            if(q.pcp >= 0) {
                ctx.fillStyle = '#228B22';
            } else {
                ctx.fillStyle = '#b7333b';
            }
            var sign = (parseFloat(q.pcp) > 0) ? "▲+" : "▼";
            var diffpc = sign + q.pcp + '%';
            ctx.fillText(diffpc, 140, 28);
        }
        */

        ctx.restore();

    };

    iChart.Charting.ChartWidgetLayer.prototype.widgetCurPrice2 = function (ctx, options)
    {
        var width = options.width,
            height = options.height;

        if(typeof this.chart.env.userSettings.currentSecurity.q != "undefined") {

            if(options.valign == 'top') {
                var yT = this.area.innerOffset.top+options.vspace;
            } else {
                var yT = this.area.innerHeight+this.area.innerOffset.top-height-options.vspace;
            }

            if(options.halign == 'left') {
                var xT = this.area.innerOffset.left+options.hspace;
            } else {
                var xT = this.area.innerWidth+this.area.innerOffset.left-width-options.hspace;
            }

            ctx.save();
            ctx.translate(xT, yT);
            ctx.beginPath();
            ctx.moveTo(0, height);
            ctx.lineTo(width, height);
            ctx.lineTo(width, 0);
            ctx.lineTo(0, 0);
            ctx.closePath();
            ctx.clip();

            ctx.fillStyle = "rgba(214,218,225,0.75)";
            ctx.strokeStyle = "rgba(171,177,192,1)";
            ctx.fillRect(0,0,width,height);
            ctx.rect(0,0,width,height);
            ctx.stroke();


            var q = this.chart.env.userSettings.currentSecurity.q;
            ctx.fillStyle = '#20232a';
            ctx.font = 'normal 26px Arial,Helvetica,sans-serif';
            ctx.textBaseline = "middle";
            var price = parseFloat(q.ltp);
            var deg = (1/this.chart.env.userSettings.currentSecurity.min_step > 1) ? (Math.round(1/this.chart.env.userSettings.currentSecurity.min_step)).toString().length-1 : 0;
            price = price.toFormat(deg,'.',' ');
            ctx.fillText(price, 10, 30);

            ctx.textBaseline = "top";
            if(new Date(q.ltt).toString() != "Invalid Date") {
                var ltt = q.ltt;
                ltt = ltt.replace(/^[\d-]{10}T?/, '');
                var dataLabel = iChart.formatDateTime(new Date(q.ltt), "dd MMMM") + " " + ltt;

                ctx.font = 'normal 11px Arial,Helvetica,sans-serif';
                ctx.fillText(dataLabel, 10, 5);
            }

            if(q.chg >= 0) {
                ctx.fillStyle = '#228B22';
            } else {
                ctx.fillStyle = '#b7333b';
            }
            var chg = parseFloat(q.chg);
            var sign = (chg > 0) ? "▲+":"▼";
            var diff = q.chg=='0'?'0.00': sign + chg.toFormat(Math.max(chg.getDegree(),2),'.',' ');
            ctx.fillText(diff, 140, 13);

            if(q.pcp) {
                if(q.pcp >= 0) {
                    ctx.fillStyle = '#228B22';
                } else {
                    ctx.fillStyle = '#b7333b';
                }
                var sign = (parseFloat(q.pcp) > 0) ? "▲+" : "▼";
                var diffpc = sign + q.pcp + '%';
                ctx.fillText(diffpc, 140, 28);
            }

        }

        ctx.restore();

    };

    iChart.Charting.ChartWidgetLayer.prototype.drawCrosshair = function (ctx, options) {

        var offset = {};
        offset.left = Math.round(this.pageX - this.offset.left);
        offset.top = Math.round(this.pageY - this.offset.top);

        var inside = {};
        inside.x = false;
        inside.y = false;

        for (var i = 0; i < this.chart.areas.length; ++i)
        {
            var area = this.chart.areas[i];
            if (area.enabled === false || area.isLayer || area.isScroller)
            {
                continue;
            }

            if(area.chart.chartOptions.tooltipPosition == 'top') {
                var top = area.innerOffset.top - 20;
            } else if(area.chart.chartOptions.tooltipPosition == 'bottom') {
                var top = area.innerOffset.top - 38 + area.innerHeight;
            }

            inside[i] = {};
            inside.x = (inside[i].x = offset.left >= area.innerOffset.left && offset.left <= area.innerOffset.left + area.innerWidth) || inside.x;
            inside.y = (inside[i].y = offset.top >= area.innerOffset.top && offset.top <= area.innerOffset.top + area.innerHeight) || inside.y;
        }

        if (!inside.x || !inside.y)
        {
            return;
        }


        var area = this.chart.areas[0];
        if (area.xSeries.length === 0)
        {
            return;
        }

        var xIndex = area.getXIndex(offset.left - area.innerOffset.left);
        if (xIndex < area.viewport.x.bounded.min || xIndex > area.viewport.x.bounded.max)
        {
            return;
        }

        this.xIndex = Math.max(area.viewport.x.bounded.min, Math.min(area.viewport.x.bounded.max, Math.round(xIndex)));

        this.xPoint = Math.round(this.area.getXPositionByIndex(this.xIndex));
        this.yPoint = this.prevY;

        ctx.save();
        ctx.translate(0.5, 0.5);
        this.drawCrossLines(ctx);
        ctx.restore();

    };

    iChart.Charting.ChartWidgetLayer.prototype.drawCrossLines = function (ctx, xPoint, yPoint) {

        var areas = this.chart.areas;

        var legendXPos = this.chart.chartOptions.legendAlign;

        for (var area_i = 0; area_i < areas.length; ++area_i)
        {
            var area = areas[area_i];

            if (area.enabled === false || area.isScroller || area.name == "VolumeByPriceArea")
            {
                continue;
            }

            if(area.isLayer) {
                var parentArea = $.grep(areas, function (x) { return x.name === area.parentName })[0];
                area.textOffset = parentArea.textOffset;
                var areaOffsetTop = legendXPos === 'top' ? parentArea.offset.top + 2 : area.offset.top;
            } else {
                var areaOffsetTop = area.offset.top + (legendXPos === 'top' ? 2 : 0);
                area.textOffset = 0;
            };

            if(!area.isLayer) {
                ctx.save();

                if (ctx.setLineDash) {
                    ctx.setLineDash([4, 3]);
                }

                ctx.strokeStyle = "#999999";
                ctx.beginPath();
                ctx.moveTo(this.xPoint, area.offset.top);
                ctx.lineTo(this.xPoint, area.offset.top + area.innerHeight);

                if (this.yPoint >= area.innerOffset.top && this.yPoint <= area.innerOffset.top + area.innerHeight) {
                    if (ctx.setLineDash) {
                        ctx.setLineDash([4, 3]);
                    }

                    ctx.moveTo(area.offset.left, this.yPoint);
                    ctx.lineTo(area.offset.left + area.innerWidth, this.yPoint);
                }
                ctx.stroke();
                ctx.closePath();
                ctx.restore();


                if (this.yPoint >= area.innerOffset.top && this.yPoint <= area.innerOffset.top + area.innerHeight) {
                    var yValue = area.getYValue(this.yPoint - area.offset.top);

                    if(yValue < 100) {
                        yValue = iChart.formatNumber( yValue, { decimalPlaces: null, decimalPrecision: 6, "scale": 0 });
                    } else {
                        yValue = iChart.formatNumber( yValue, { decimalPlaces: 2, decimalPrecision: null, "scale": 0 });
                    }

                    var x = area.offset.left + area.innerWidth;
                    var y = this.yPoint;

                    ctx.fillStyle = this.chart.chartOptions.labelColor;
                    ctx.fillRect(x + 8, y - 8, ctx.measureText(yValue).width + 10, 15);
                    ctx.beginPath();
                    ctx.moveTo(x + 9, y - 9);
                    ctx.lineTo(x + 9, y + 8);
                    ctx.lineTo(x, y);
                    ctx.lineTo(x + 9, y - 9);
                    ctx.lineTo(x + 9, y + 8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.font = 'normal ' + 10 + 'px ' + 'Verdana,Tahoma,Geneva,Arial,Sans-serif';
                    ctx.textAlign = "left";
                    ctx.textBaseline = "top";
                    ctx.fillStyle = this.chart.chartOptions.labelFontColor;
                    ctx.fillText(yValue, x + 8, y - 6);
                }
            }

            ctx.save();

            var dateTime = new Date(1000 * area.xSeries[this.xIndex]);

            //label ось X
            if(area_i == 0 && !area.isLayer) {
                var dateLabel = iChart.formatDateTime(dateTime, this.chart.dateFormat);
                var dateLabelArr = dateLabel.split("\n");

                var width = ctx.measureText(dateLabelArr[0] + " " + dateLabelArr[1]).width;
                ctx.fillStyle = this.chart.chartOptions.labelColor;
                ctx.fillRect(this.xPoint - Math.round(width / 2) - 4, area.offset.top + area.innerHeight + 2, width + 4, 12);
                ctx.fillStyle = this.chart.chartOptions.labelFontColor;
                ctx.font = 'normal ' + 8 + 'px ' + 'Verdana,Tahoma,Geneva,Arial,Sans-serif';
                ctx.textAlign = "left";
                ctx.textBaseline = "top";
                ctx.fillText(dateLabelArr[0] + " " + dateLabelArr[1], this.xPoint - Math.round(width / 2), area.offset.top + area.innerHeight + 3);
            }

            if(!area.isLayer) {
                ctx.fillStyle = this.chart.chartOptions.backgroundColor;
                if (legendXPos === 'top') {
                    ctx.fillRect(area.offset.left, areaOffsetTop, 100, 15);
                } else {
                    ctx.fillRect(area.offset.left, areaOffsetTop + area.innerHeight - 15, 100, 15);
                }

                ctx.font = 'normal ' + 10 + 'px ' + 'Verdana,Tahoma,Geneva,Arial,Sans-serif';
                ctx.textAlign = "left";
                ctx.textBaseline = "top";

                var tooltips = iChart.formatDateTime(dateTime, "dd.MM.yyyy" + (this.chart.showTime() ? " HH:mm" : ""));
                area.textOffset += ctx.measureText(tooltips).width + 20;
                ctx.fillStyle = this.chart.chartOptions.labelColor;
                if (legendXPos === 'top') {
                    ctx.fillText(tooltips, area.offset.left, areaOffsetTop);
                } else {
                    ctx.fillText(tooltips, area.offset.left, areaOffsetTop + area.innerHeight - 12);
                }

            }

            for(var j = 0; j < area.ySeries.length; j++) {
                var ySeries = area.ySeries[j];

                if(!ySeries.points[this.xIndex] || ySeries.points[this.xIndex].length == 4 && ySeries.points[this.xIndex][0] == null) {
                    continue;
                }

                if(ySeries.valuesPerPoint > 1) {
                    var yValue = ySeries.points[this.xIndex] ? ySeries.points[this.xIndex][ySeries.dotIndex] : null;
                } else {
                    var yValue = ySeries.points[this.xIndex] ? ySeries.points[this.xIndex][0] : null;
                }

                if(yValue) {

                    ctx.beginPath();
                    ctx.fillStyle = ySeries.color;
                    ctx.arc(this.xPoint, area.offset.top + Math.round(area.getYPosition(yValue)), 4, 0, 2 * Math.PI, true);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.fillStyle = this.chart.chartOptions.backgroundColor;
                if (legendXPos === 'top') {
                    ctx.fillRect(area.offset.left + area.textOffset, areaOffsetTop, 15, 15);
                } else {
                    ctx.fillRect(area.offset.left + area.textOffset, areaOffsetTop + area.innerHeight - 15, 15, 15);
                }

                ctx.beginPath();
                ctx.fillStyle = ySeries.color;
                ctx.strokeStyle = ySeries.color;

                if (legendXPos === 'top') {
                    ctx.arc(area.offset.left + area.textOffset, areaOffsetTop + 5, 6, 0, 2 * Math.PI, true);
                } else {
                    ctx.arc(area.offset.left + area.textOffset, areaOffsetTop + area.innerHeight - 6, 6, 0, 2 * Math.PI, true);
                }

                ctx.closePath();
                ctx.stroke();
                ctx.fill();
                area.textOffset += 15;

                tooltips = (ySeries.labels[0] && ySeries.labels[0][2] ? ySeries.labels[0][2] : ySeries.name)  + " ";

                if(ySeries.points[this.xIndex]) {

                    if (ySeries.valuesPerPoint === 4) {
                        if (this.chart.isComparison) {
                            tooltips += ySeries.points[this.xIndex][3];
                        } else {
                            tooltips += " H: " + ySeries.points[this.xIndex][0]
                                + " L: " + ySeries.points[this.xIndex][1]
                                + " O: " + ySeries.points[this.xIndex][2]
                                + " C: " + ySeries.points[this.xIndex][3];
                        }
                    } else if (ySeries.valuesPerPoint == 2) {
                        tooltips += " " + _t('2589', "Мин:") + " " + ySeries.points[this.xIndex][0]
                                 + " " + _t('2590', "Макс:") + " " + ySeries.points[this.xIndex][0];
                    } else {
                        var pointYValue = ySeries.points[this.xIndex][0];
                        if(pointYValue < 100) {
                            pointYValue = iChart.formatNumber( pointYValue, { decimalPlaces: null, decimalPrecision: 6, "scale": 0 });
                        } else {
                            pointYValue = iChart.formatNumber( pointYValue, { decimalPlaces: 2, decimalPrecision: null, "scale": 0 });
                        }
                        tooltips += pointYValue;
                    }

                    ctx.fillStyle = this.chart.chartOptions.backgroundColor;
                    if (legendXPos === 'top') {
                        ctx.fillRect(area.offset.left + area.textOffset, areaOffsetTop, ctx.measureText(tooltips).width + 20, 15);
                    } else {
                        ctx.fillRect(area.offset.left + area.textOffset, areaOffsetTop + area.innerHeight - 15, ctx.measureText(tooltips).width + 20, 15);
                    }

                    ctx.fillStyle = this.chart.chartOptions.labelColor;
                    ctx.font = 'normal ' + 10 + 'px ' + 'Verdana,Tahoma,Geneva,Arial,Sans-serif';
                    ctx.textAlign = "left";
                    ctx.textBaseline = "top";
                    if (legendXPos === 'top') {
                        ctx.fillText(tooltips, area.offset.left + area.textOffset, areaOffsetTop);
                    } else {
                        ctx.fillText(tooltips, area.offset.left + area.textOffset, areaOffsetTop + area.innerHeight - 12);
                    }

                    area.textOffset += ctx.measureText(tooltips).width + 20;
                }

            }

            ctx.restore();

        }

        if(this.chart.chartOptions.floatingLegend) {
            this.drawTooltip(ctx);
        }
    };

    iChart.Charting.ChartWidgetLayer.prototype.drawPoints = function (ctx) {

    };

    iChart.Charting.ChartWidgetLayer.prototype.drawTooltip = function (ctx) {
        ctx.save();

        var areas = this.chart.areas;

        for (var area_i = 0; area_i < areas.length; ++area_i) {
            var area = areas[area_i];

            if (area.enabled === false || area.isScroller || area.name == "VolumeByPriceArea" || area.isLayer) {
                continue;
            }

            if (this.yPoint >= area.innerOffset.top && this.yPoint <= area.innerOffset.top + area.innerHeight) {

                var ySeries = area.ySeries[0];

                var hPositionRight = true;

                var floatingLegendFontSize = this.chart.chartOptions.floatingLegendFontSize;
                var floatingLegendPadding = floatingLegendFontSize / 2;

                ctx.font = 'normal ' + floatingLegendFontSize + 'px ' + 'Verdana,Tahoma,Geneva,Arial,Sans-serif';
                ctx.textAlign = "left";
                ctx.textBaseline = "top";

                var points = area.ySeries[0].points[this.xIndex];

                if( ySeries.kind == 'HLOC' ) {

                    var text1L = ctx.measureText(_t('21962', 'open:') + points[2]).width;
                    var text2L = ctx.measureText(_t('21963', 'close:') + points[3]).width;
                    var text3L = ctx.measureText(_t('21964', 'low:') + points[1]).width;
                    var text4L = ctx.measureText(_t('21965', 'high:') + points[0]).width;

                    var textWidth = Math.max(text1L,text2L,text3L,text4L) + 10;
                    var textHeight = (floatingLegendFontSize + 2) * 4 + floatingLegendPadding;
                } else {

                    var textWidth = ctx.measureText(ySeries.name + ': ' + iChart.formatNumber(points[ySeries.closeValueIndex], ySeries.formatProvider)).width + 10;
                    var textHeight = (floatingLegendFontSize + 2) + floatingLegendPadding;
                }

                var cursorY = area.getYPosition(points[ySeries.closeValueIndex]) + area.innerOffset.top;
                var yPointPosition = cursorY - 20;

                if(this.xPoint  > (area.offset.left + area.innerWidth) / 2) {
                    hPositionRight = false;
                }

                var cursorXDir = 9 * (hPositionRight ? 1: -1);

                if(hPositionRight) {
                    var xPointPosition = this.xPoint + cursorXDir;
                } else {
                    xPointPosition = this.xPoint - textWidth + cursorXDir;
                }

                var yOffset = 0;

                if(yPointPosition + textHeight > area.innerOffset.top + area.innerHeight) {
                    yOffset = (yPointPosition + textHeight) - (area.innerOffset.top + area.innerHeight);
                }

                ctx.fillStyle = this.chart.chartOptions.floatingLegendBorderColor;
                ctx.beginPath();
                ctx.moveTo(this.xPoint + cursorXDir, cursorY - 9);
                ctx.lineTo(this.xPoint + cursorXDir, cursorY + 8);
                ctx.lineTo(this.xPoint, cursorY);
                ctx.lineTo(this.xPoint + cursorXDir, cursorY - 9);
                ctx.lineTo(this.xPoint + cursorXDir, cursorY + 8);
                ctx.closePath();
                ctx.fill();

                ctx.lineWidth = 1;
                ctx.strokeStyle = this.chart.chartOptions.floatingLegendBorderColor;

                var radius = 5;
                ctx.beginPath();
                ctx.moveTo(xPointPosition + radius, yPointPosition - yOffset);
                ctx.lineTo(xPointPosition + textWidth - radius, yPointPosition - yOffset);
                ctx.quadraticCurveTo(xPointPosition + textWidth, yPointPosition - yOffset, xPointPosition + textWidth, yPointPosition - yOffset + radius);
                ctx.lineTo(xPointPosition + textWidth, yPointPosition - yOffset + textHeight - radius);
                ctx.quadraticCurveTo(xPointPosition + textWidth, yPointPosition - yOffset + textHeight, xPointPosition + textWidth - radius, yPointPosition - yOffset + textHeight);
                ctx.lineTo(xPointPosition + radius, yPointPosition - yOffset + textHeight);
                ctx.quadraticCurveTo(xPointPosition, yPointPosition - yOffset + textHeight, xPointPosition, yPointPosition - yOffset + textHeight - radius);
                ctx.lineTo(xPointPosition, yPointPosition - yOffset + radius);
                ctx.quadraticCurveTo(xPointPosition, yPointPosition - yOffset, xPointPosition + radius, yPointPosition - yOffset);
                ctx.closePath();
                ctx.stroke();
                ctx.fillStyle = this.chart.chartOptions.floatingLegendBackground;
                ctx.fill();

                ctx.fillStyle = this.chart.chartOptions.floatingLegendTextColor;
                if( ySeries.kind == 'HLOC' ) {
                    var yTextPosition = yPointPosition - yOffset + floatingLegendPadding;

                    ctx.fillText(_t('21962', 'open:') + points[2], xPointPosition, yTextPosition);
                    ctx.fillText(_t('21963', 'close:') + points[3], xPointPosition, yTextPosition + floatingLegendFontSize + 2);
                    ctx.fillText(_t('21964', 'low:') + points[1], xPointPosition, yTextPosition + floatingLegendFontSize*2 + 2);
                    ctx.fillText(_t('21965', 'high:') + points[0], xPointPosition, yTextPosition + floatingLegendFontSize*3 + 2);
                } else {
                    var yTextPosition = yPointPosition - yOffset + floatingLegendPadding;
                    ctx.fillText(ySeries.name + ': ' + iChart.formatNumber(points[ySeries.closeValueIndex], ySeries.formatProvider), xPointPosition, yTextPosition);

                }
            }
        }

        ctx.restore();

    }

})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartAreaLayer = function (chart)
    {
        this.$deleteButton = $("<span/>", { "class": "m-chart-instrument-delete", "text": "✕", "title": _t("87551", "Удалить инструмент") }).hide().appendTo(chart.container);
        this.$settingsButton = $("<span class ='m-chart-instrument-settings' href = '#' text = ''><span class='elementSettingsHolder' style='position: relative'></span></span>").hide();
        this.$settingsButton.attr('title', _t("87552", "Свойства"));
        this.$settingsButton.appendTo(chart.container);

        this.canvas = null;
        this.chart = chart;
        this.defaultCursor = "default";
        this.drag = null;
        this.history = [];
        this.hover = null;
        this.controlsHover = null;
        this.prevX = null;
        this.prevY = null;
        this.selected = null;
        this.unfinished = null;

        /*
        $(chart.container).off('mousedown.overlay').unbind('mouseup.overlay').unbind('mousemove.overlay');
        $(chart.container).on('mousedown.overlay', $.proxy(this.onMouseDown, this)).
            on('mouseup.overlay', $.proxy(this.onMouseUp, this)).
            on('mousemove.overlay', $.proxy(this.onMouseMove, this));
        */
    };

    iChart.Charting.ChartAreaLayer.prototype.clear = function (all)
    {
        /// <summary>
        /// Clears the canvas, leaving only the chart image.
        /// </summary>

        all = !!all;
        if (this.history.length)
        {
            if(all) {
                this.$deleteButton.hide().removeClass('on');
                this.$settingsButton.hide();
                this.history = [];
                this.render();
                this.syncHash();
            } else {
                var overlayHistory = this.history;
                for(var i=0; i < overlayHistory.length; i++) {
                    var element = overlayHistory[i];
                    if(element.drawType == "manually") {
                        overlayHistory.splice(i, 1);
                        i--;
                    }
                }
                this.render();
                this.syncHash();
            }
        }
    };

    iChart.Charting.ChartAreaLayer.prototype.createElement = function (elementType)
    {
        /// <summary>
        /// Initializes a new instance of the chart element with the specified type.
        /// </summary>
        /// <param name="elementType" type="String">Type of the chart element that should be initialized.</param>

        switch (elementType)
        {
            case "Channel":
                return new iChart.Charting.ChartChannel(this);
            case "Ellipse":
                return new iChart.Charting.ChartEllipse(this);
            case "FibonacciArc":
                return new iChart.Charting.ChartFibonacciArc(this);
            case "FibonacciCorrection":
                return new iChart.Charting.ChartFibonacciCorrection(this);
            case "FibonacciFan":
                return new iChart.Charting.ChartFibonacciFan(this);
            case "HorizontalLine":
                return new iChart.Charting.ChartHorizontalLine(this);
            case "Line":
                return new iChart.Charting.ChartLine(this);
            case "Rectangle":
                return new iChart.Charting.ChartRectangle(this);
            case "Trend":
                return new iChart.Charting.ChartTrend(this);
            case "Triangle":
                return new iChart.Charting.ChartTriangle(this);
            case "VerticalLine":
                return new iChart.Charting.ChartVerticalLine(this);
            case "Mark":
                return new iChart.Charting.ChartMark(this);
            case "Label":
                return new iChart.Charting.ChartLabel(this);
            case "Arrow":
                return new iChart.Charting.ChartArrow(this);
            case "Polygon":
                return new iChart.Charting.ChartPolygon(this);
            case "Trade":
                return new iChart.Charting.ChartTrade(this);
            case "Bubble":
                return new iChart.Charting.ChartBubble(this);
            case "Text":
                return new iChart.Charting.ChartText(this);
            case "Order":
                return new iChart.Charting.ChartOrder(this);
            case "Trendorder":
                return new iChart.Charting.ChartTrendorder(this);
            case "Position":
                return new iChart.Charting.ChartPosition(this);
            case "Visualtrade":
                return new iChart.Charting.ChartVisualtrade(this);
            case "TradePanel":
                return new iChart.Charting.ChartTradePanel(this);
            case "Button":
                return new iChart.Charting.ChartButton(this);
            case "Event":
                return new iChart.Charting.ChartEvent(this);
            case "Level":
                return new iChart.Charting.ChartLevel(this);
            case "Range":
                return new iChart.Charting.ChartRange(this);
            case "HorizontalRange":
                return new iChart.Charting.ChartHorizontalRange(this);
            default:
                return undefined;
        }
    };

    iChart.Charting.ChartAreaLayer.prototype.deserialize = function (valueProvider)
    {
        this.$deleteButton.unbind("mousedown").hide().removeClass('on');
        this.$settingsButton.unbind("mousedown").hide();

        this.history = [];

        var elementCount = parseInt(valueProvider["L"], 10);

        if (isNaN(elementCount))
        {
            return;
        }

        theloop:
        for (var i = 0; i < elementCount; ++i)
        {
            var elementType = valueProvider["L" + i + "_T"];
            var element = this.createElement(elementType);
            if (typeof element === "undefined")
            {
                continue;
            }

            element.points = [];
            for (var j = 0; j < element.maxPointCount; ++j)
            {
                var point = {
                    "x": parseFloat(valueProvider["L" + i + "_X" + j]),
                    "y": parseFloat(valueProvider["L" + i + "_Y" + j])
                };

                if (isNaN(point.x) || isNaN(point.y))
                {
                    continue theloop;
                }

                element.points.push(point);
            }

            if(valueProvider["L" + i + "_S"]) {
                //element.settings = encodeURIComponent(valueProvider["L" + i + "_S"]);
                //element.settings = decodeURIComponent(valueProvider["L" + i + "_S"])
                //var str = .replace(/=/, '@');
                element.settings = JSON.parse(decodeURIComponent(window.atob(valueProvider["L" + i + "_S"].replace(/@/g, '='))));
                //element.settings = valueProvider["L" + i + "_S"];
            }

            this.history.push(element);
        }
    };

    iChart.Charting.ChartAreaLayer.prototype.elementAt = function (x, y)
    {
        /// <summary>
        /// Returns chart element at the specified coordinates, or undefined if it is not present.
        /// </summary>
        /// <param name="x" type="Number">X pixel coordinate.</param>
        /// <param name="y" type="Number">Y pixel coordinate.</param>

        /*
        this.history.sort(function(a, b){
            if (a && a.selected) return -1;
            if (a && a.elementType == 'TradePanel') return -1;
            return 1;
        });

        for (var i = 0; i < this.history.length; ++i)
        {
            var element = this.history[i];
            var mode = element.isMouseOver.call(element, x, y);
            if (mode !== -1)
            {
                return { "mode": mode, "value": element };
            }
        }
        */

        return undefined;
    };

    iChart.Charting.ChartAreaLayer.prototype.finalizePoint = function (x, y)
    {
        /// <suummary>
        /// Adds the specified point to the figure that is being drawn at the moment and redraws the canvas.
        /// </summary>
        /// <param name="x" type="Number">X pixel coordinate.</param>
        /// <param name="y" type="Number">Y pixel coordinate.</param>
/*
        this.unfinished.points[this.unfinished.points.length - 1].x = x;
        this.unfinished.points[this.unfinished.points.length - 1].y = y;
        if (this.unfinished.isComplete())
        {
            this.chart.env.wrapper.trigger('iguanaChartEvents', ['drawComplete', this.unfinished]);
            this.unfinished = null;
            this.syncHash();
            this.chart.container.style.cursor = this.defaultCursor;
        }
        else
        {
            this.unfinished.points.push({});
            this.chart.container.style.cursor = "crosshair";
        }
*/
        this.render();
    };

    iChart.Charting.ChartAreaLayer.prototype.getMarkers = function (dx, dy)
    {
        /// <summary>
        /// Gets shifted marker points of the chart element that is being dragged.
        /// </summary>
        /// <param name="dx" type="Number">X coordinate shift in pixels</param>
        /// <param name="dy" type="Number">Y coordinate shift in pixels</param>

        var markers = [];
        var outside = false;
        for (var i = 0; i < this.drag.element.points.length; ++i)
        {
            var point = this.drag.element.points[i];
            var marker = {};
            if (this.drag.mode === 0 || this.drag.mode === i + 1)
            {
                marker = $.extend({}, point);
                marker.x = 1000 * this.area.getXValue(this.area.getXPositionByValue(point.x / 1000) + dx);
                marker.y = this.area.getYValue(this.area.getYPosition(point.y) + dy);
                if (isNaN(marker.x) || isNaN(marker.y))
                {
                    outside = true;
                    break;
                }
            }
            else
            {
                marker = $.extend({}, point);
            }

            markers.push(marker);
        }

        return {
            "markers": markers,
            "outside": outside
        };
    };

    iChart.Charting.ChartAreaLayer.prototype.getPixelPosition = function (axis, value)
    {
        /// <summary>
        /// Gets a pixel position that is equivalent to the specified value on the specified axis, or undefined if it is not present.
        /// </summary>
        /// <param name="axis" type="Object">Axis data.</param>
        /// <param name="value" type="Number">A value that should be searched on the axis.</param>

        var l = axis.length;
        if (l < 2 || axis[0][0] >= value)
        {
            return undefined;
        }

        for (var i = 1; i < l; ++i)
        {
            var pair = axis[i];
            if (pair[0] >= value)
            {
                return pair[1];
            }
        }

        return undefined;
    };

    iChart.Charting.ChartAreaLayer.prototype.onMouseDown = function (e)
    {
        /// <summary>
        /// Handler for the document mousedown jQuery event. Used for drawing, dragging and selecting chart elements.
        /// </summary>
/*
        if (typeof this.offset === "undefined")
        {
            return;
        }

        var x = Math.round(e.pageX - this.offset.left - this.area.innerOffset.left);
        var y = Math.round(e.pageY - this.offset.top - this.area.innerOffset.top);
        var valueX = 1000 * this.area.getXValue(x);
        var valueY = this.area.getYValue(y);

        $(window).data('mouseValueX', valueX);
        $(window).data('mouseValueY', valueY);

        if(this.chart.isComparison && !isNaN(valueY)) {
            var indexBase = iChart.Charting.getNearestNotNullIndex(this.chart.areas[0].ySeries[0].points, this.chart.areas[0].viewport.x.bounded.min);
            var base = this.chart.areas[0].ySeries[0].points[indexBase][3];
            valueY = base + base / 100 * valueY;
        }

        if (isNaN(valueX) || isNaN(valueY))
        {
            return;
        }

        if (this.unfinished !== null)
        {
            this.finalizePoint(valueX, valueY);
            this.selected.onInsert();
            return;
        }

        if (this.history.length === 0 || this.drag !== null)
        {
            return;
        }

        var element = this.elementAt(x, y);

        //Вызываем функцию
        if (element && element.value && typeof element.value.onMouseDown =='function' ) {
            element.value.onMouseDown(e, x, y);
        }


        if (typeof element === "undefined")
        {
            this.setSelected(null);
            return;
        } else if(!element.value.controlEnable) {
            return;
        } else if(element.mode.toString().match(new RegExp("^m_", "i"))) {
            var m = element.mode.toString().match(new RegExp(/^m_(\d)/i));
            element.value.maps[m[1]].click();
        } else if(element.mode.toString().match(new RegExp("^c_", "i"))) {
            //Перенес в onMouseUp
            var c = element.mode.toString().match(new RegExp(/^c_(\d)/i));
            element.value.controls[c[1]].click();
            return;
        } else if(element.mode.toString().match(new RegExp("^a_", "i"))) {
        }

        this.setSelected(element.value);
        if (element.hasSettings) {

        }

        this.drag = {};
        this.drag.element = this.selected;
        this.drag.mode = element.mode;
        this.drag.x = x;
        this.drag.y = y;

        // Disable selection so that it doesn't interfere with drag.
        if (this.chart.selection)
        {
            this.chart.selection.disable();
        }
        */
    };

    iChart.Charting.ChartAreaLayer.prototype.onMouseMove = function (e)
    {
        /*
        /// <summary>
        /// Handler for the document mousemove jQuery event. Used for dragging and selecting chart elements.
        /// </summary>

        if (typeof this.offset === "undefined")
        {
            return;
        }

        var x = Math.round(e.pageX - this.offset.left - this.area.innerOffset.left);
        var y = Math.round(e.pageY - this.offset.top - this.area.innerOffset.top);
        if (x === this.prevX && y === this.prevY)
        {
            // Minor performance optimization: do not handle the same coordinates twice in a row.
            return;
        }

        this.prevX = x;
        this.prevY = y;

        var valueX = 1000 * this.area.getXValue(x);
        var valueY = this.area.getYValue(y);

        this.prevValueX = valueX;
        this.prevValueY = valueY;

        if(this.chart.isComparison && !isNaN(valueY)) {
            var indexBase = iChart.Charting.getNearestNotNullIndex(this.chart.areas[0].ySeries[0].points, this.chart.areas[0].viewport.x.bounded.min);
            var base = this.chart.areas[0].ySeries[0].points[indexBase][3];
            valueY = base + base / 100 * valueY;
        }

        if (isNaN(valueX) || isNaN(valueY))
        {
            this.setHover(null);
            this.chart.container.style.cursor = this.defaultCursor;
            return;
        }

        if (this.unfinished !== null)
        {
            this.hover = null;
            this.unfinished.points[this.unfinished.points.length - 1].x = valueX;
            this.unfinished.points[this.unfinished.points.length - 1].y = valueY;
            this.render();
            this.chart.container.style.cursor = "crosshair";
            return;
        }

        if (this.drag !== null)
        {
            if(!isNaN(parseInt(this.drag.mode))) {
                if (typeof this.drag.element.moveCursor != "undefined") {
                    this.chart.container.style.cursor = this.drag.element.moveCursor;
                } else {
                    this.chart.container.style.cursor = "move";
                }
            }

            var dx = x - this.drag.x;
            var dy = y - this.drag.y;
            if (dx === 0 && dy === 0)
            {
                return;
            }

            var result = this.getMarkers(dx, dy);
            this.drag.element.onDrag(result.markers);

            if (result.outside)
            {
                if (typeof this.drag.element.markers !== "undefined")
                {
                    delete this.drag.element.markers;
                    this.render();
                }
            }
            else
            {
                this.drag.element.markers = result.markers;
                this.render();
            }

            return;
        }

        var element = this.elementAt(x, y);
        if (typeof element === "undefined")
        {
            this.setHover(null);
            this.setControlsHover(null);
            this.chart.container.style.cursor = this.defaultCursor;
        }
        else
        {
            if(element.mode.toString().match(new RegExp("^c_", "i"))) {
                this.chart.container.style.cursor = "pointer";
                this.setControlsHover(element);
            } else if (element.mode.toString().match(new RegExp("^a_", "i"))) {
                this.setHover(null);
                this.setControlsHover(element);
                this.chart.container.style.cursor = this.defaultCursor;
            } else if (element.mode.toString().match(new RegExp("^m_", "i"))) {
                var m = element.mode.toString().match(new RegExp(/^m_(\d)/i));
                //console.log(element.mode);
                this.setControlsHover(element);
                this.chart.container.style.cursor = "pointer";
            } else {
                this.setHover(element.value, x, y);
                this.setControlsHover(element);

                if(typeof element.value.hoverCursor != "undefined" || typeof element.value.hoverPointCursor != "undefined") {
                    if(element.mode > 0 && typeof element.value.hoverPointCursor != "undefined") {
                        this.chart.container.style.cursor = element.value.hoverPointCursor;
                    } else if(element.mode == 0 && typeof element.value.hoverCursor != "undefined") {
                        this.chart.container.style.cursor = element.value.hoverCursor;
                    } else {
                        this.chart.container.style.cursor = "pointer";
                    }
                } else {
                    this.chart.container.style.cursor = "pointer";
                }
            }
        }
        */
    };

    iChart.Charting.ChartAreaLayer.prototype.onMouseUp = function (e)
    {
        /// <summary>
        /// Handler for the document mouseup jQuery event. Used for dragging chart elements.
        /// </summary>

        /*
        var x = Math.round(e.pageX - this.offset.left - this.area.innerOffset.left);
        var y = Math.round(e.pageY - this.offset.top - this.area.innerOffset.top);

        var element = this.elementAt(x, y);
        if (typeof element === "undefined")
        {
        } else if(!element.value.controlEnable) {
            return;
        } else if(element.mode.toString().match(new RegExp("^c_", "i"))) {
            //var c = element.mode.toString().match(new RegExp(/^c_(\d)/i));
            //element.value.controls[c[1]].click();
            //return;
        } else if(element.mode.toString().match(new RegExp("^a_", "i"))) {
        }

        if (typeof this.offset === "undefined")
        {
            return;
        }

        if (this.drag === null)
        {
            return;
        }

        var x = Math.round(e.pageX - this.offset.left - this.area.innerOffset.left);
        var y = Math.round(e.pageY - this.offset.top - this.area.innerOffset.top);
        var valueX = 1000 * this.area.getXValue(x);
        var valueY = this.area.getYValue(y);
        if(this.chart.isComparison && !isNaN(valueY)) {
            var base = this.chart.areas[0].ySeries[0].points[this.chart.areas[0].viewport.x.bounded.min][3];
            valueY = base + base / 100 * valueY;
        }

        if (isNaN(valueX) || isNaN(valueY))
        {
            return;
        }

        var dx = x - this.drag.x;
        var dy = y - this.drag.y;
        if (dx !== 0 || dy !== 0)
        {
            var result = this.getMarkers(dx, dy);
            this.drag.element.onDrag(result.markers);

            if (!result.outside)
            {
                this.drag.element.points = result.markers;
                delete this.drag.element.testContext;
                this.syncHash();
                this.drag.element.onDrop(this.drag.mode);
            }
        }
        delete this.drag.element.markers;
        this.drag = null;
        this.render();
        if (this.chart.selection)
        {
            this.chart.selection.enable();
        }
        */
    };

    iChart.Charting.ChartAreaLayer.prototype.remove = function (element)
    {
        /// <summary>
        /// Removes the specified chart element from the canvas.
        /// </summary>

        var i = this.history.indexOf(element);
        if (i === -1)
        {
            return;
        }

        this.$deleteButton.unbind("mousedown").hide().removeClass('on');
        this.$settingsButton.unbind("mousedown").hide();

        this.history.splice(i, 1);
        this.render();
        this.syncHash();
    };

    iChart.Charting.ChartAreaLayer.prototype.removeSelected = function (element)
    {
        /// <summary>
        /// Removes the currently selected chart element from the canvas.
        /// </summary>

        if (this.selected !== null && !element)
        {
            this.remove(this.selected);
        } else {
            this.remove(element);
        }
    };

    iChart.Charting.ChartAreaLayer.prototype.render = function (context)
    {
        /// <summary>
        /// Redraws the layer.
        /// </summary>

        if (!context)
        {
            if(!this.context) {
                console.log("ERROR: No context for render");
                return 0;
            }
            context = this.context;
            var canvasSize = getElementSize(context.canvas);
            context.clearRect(0, 0, canvasSize.width, canvasSize.height);
        }

        context.save();
        context.translate(this.area.innerOffset.left + 0.5, this.area.innerOffset.top + 0.5);
        //context.translate(this.area.innerOffset.left, this.area.innerOffset.top);

        context.beginPath();
        context.moveTo(0, this.area.innerHeight);
        context.lineTo(this.area.innerWidth, this.area.innerHeight);
        context.lineTo(this.area.innerWidth, 0);
        context.lineTo(0, 0);
        context.closePath();
        context.clip();
        if(typeof context.busyPoints != "undefined") {
            context.busyPoints = {};
        }

        this.history.sort(function(a,b){
            if (a.selected) return 1;
            if (a.inHover && b.selected) return -1;
            if (a.inHover && (!b.inHover && !b.selected)) return 1;
        });

        for (var i = 0; i < this.history.length; ++i)
        {
            this.history[i].draw(context, -1);
        }
        context.restore();

        context.save();
        context.translate(this.area.innerOffset.left, this.area.innerOffset.top);

        context.beginPath();
        context.moveTo(0, this.area.innerHeight);
        context.lineTo(this.area.outerWidth, this.area.innerHeight);
        context.lineTo(this.area.outerWidth, 0);
        context.lineTo(0, 0);
        context.closePath();
        context.clip();

        for (var i = 0; i < this.history.length; ++i)
        {
            this.history[i].drawExtended(context, -1);
        }
        context.restore();

        if (typeof FlashCanvas !== "undefined")
        {
            // Flush and execute commands.
            context.e();
        }
    };

    iChart.Charting.ChartAreaLayer.prototype.serialize = function ()
    {
        /// <summary>
        /// Serializes current chart canvas parameters to an associative array.
        /// </summary>

        var parameters = {};

        var ir = 0;

        parameters["L"] = 0;

        for (var i = 0; i < this.history.length; ++i)
        {
            var element = this.history[i];

            if (element.isComplete() && element.controlEnable && element.storageEnable)
            {
                parameters["L" + ir + "_T"] = element.elementType;
                for (var j = 0; j < element.points.length; ++j)
                {
                    parameters["L" + ir + "_X" + j] = element.points[j].x;
                    parameters["L" + ir + "_Y" + j] = element.points[j].y;
                }
                if(element.hasSettings) {
                    //parameters["L" + i + "_S"] = element.settings;
                    //parameters["L" + i + "_S"] = encodeURIComponent(element.settings);
                    parameters["L" + ir + "_S"] = window.btoa(encodeURIComponent(JSON.stringify(element.settings))).replace(/=/g, '@');
                }
                ir++;
                parameters["L"] = parameters["L"] + 1;
            }
        }
        return parameters;
    };

    /**
     * Отслеживание смены переходов областей
     * @param element
     */
    iChart.Charting.ChartAreaLayer.prototype.setControlsHover = function (element) {
        if(this.controlsHover) {
            if(element) {
                if (this.controlsHover.value.id != element.value.id || this.controlsHover.mode != element.mode) {
                    if (this.controlsHover.toString().match(new RegExp("^c_", "i"))) {
                        //var c = this.controlsHover.mode.toString().match(new RegExp(/^c_(\d)/i));
                    } else if (this.controlsHover.mode.toString().match(new RegExp("^a_", "i"))) {
                        //var a = this.controlsHover.mode.toString().match(new RegExp(/^a_(\d)/i));
                    } else if (this.controlsHover.mode.toString().match(new RegExp("^m_", "i"))) {
                        var m = this.controlsHover.mode.toString().match(new RegExp(/^m_(\d)/i));
                        if(typeof this.controlsHover.value.maps != 'undefined' && typeof this.controlsHover.value.maps[m[1]].hoverOut == 'function') {
                            this.controlsHover.value.maps[m[1]].hoverOut();
                            this.controlsHover = null;
                        }
                    }

                    if (element.mode.toString().match(new RegExp("^c_", "i"))) {
                        //var c = element.mode.toString().match(new RegExp(/^c_(\d)/i));
                    } else if (element.mode.toString().match(new RegExp("^a_", "i"))) {
                        //var a = element.mode.toString().match(new RegExp(/^a_(\d)/i));
                    } else if (element.mode.toString().match(new RegExp("^m_", "i"))) {
                        var m = element.mode.toString().match(new RegExp(/^m_(\d)/i));
                        if(typeof element.value.maps != 'undefined' && typeof element.value.maps[m[1]].hoverIn == 'function') {
                            this.controlsHover = element;
                            element.value.maps[m[1]].hoverIn();
                        }
                    }

                }
            } else {
                if (this.controlsHover.toString().match(new RegExp("^c_", "i"))) {
                    //var c = this.controlsHover.mode.toString().match(new RegExp(/^c_(\d)/i));
                } else if (this.controlsHover.mode.toString().match(new RegExp("^a_", "i"))) {
                    //var a = this.controlsHover.mode.toString().match(new RegExp(/^a_(\d)/i));
                } else if (this.controlsHover.mode.toString().match(new RegExp("^m_", "i"))) {
                    var m = this.controlsHover.mode.toString().match(new RegExp(/^m_(\d)/i));
                    if(typeof this.controlsHover.value.maps != 'undefined' && typeof this.controlsHover.value.maps[m[1]].hoverOut == 'function') {
                        this.controlsHover.value.maps[m[1]].hoverOut();
                        this.controlsHover = null;
                    }
                }
            }
        } else {
            if(element) {
                if (element.mode.toString().match(new RegExp("^c_", "i"))) {
                    //var c = element.mode.toString().match(new RegExp(/^c_(\d)/i));
                } else if (element.mode.toString().match(new RegExp("^a_", "i"))) {
                    //var a = element.mode.toString().match(new RegExp(/^a_(\d)/i));
                } else if (element.mode.toString().match(new RegExp("^m_", "i"))) {
                    var m = element.mode.toString().match(new RegExp(/^m_(\d)/i));
                    if(typeof element.value.maps != 'undefined' && typeof element.value.maps[m[1]].hoverIn == 'function') {
                        this.controlsHover = element;
                        element.value.maps[m[1]].hoverIn();
                    }
                }
            }
        }
    };

    iChart.Charting.ChartAreaLayer.prototype.setHover = function (element, x, y)
    {
        /// <summary>
        /// Sets hover to the specified chart element and redraws the canvas to highlight it.
        /// </summary>
        /// <param name="element">Chart element the mouse is over at the moment.</param>

        if(this.hover !== null && (element == null || this.hover !== element)) {


            this.hover.inHover = false;

            this.hover.onOut();
        }

        if (element !== null)
        {
            element.inHover = true;
        }

        if (this.hover !== element)
        {
            this.hover = element;

            if(element !== null && typeof element.onHover === 'function') {
                element.onHover(x, y);
            }

            this.render();
        }
    };

    iChart.Charting.ChartAreaLayer.prototype.setSelected = function (element)
    {
        /// <summary>
        /// Sets selection to the specified chart element and redraws the canvas to change selection.
        /// </summary>
        /// <param name="element">Chart element that is being selected, or a null to deselect the element that was selected before.</param>

        $('#elementSettings').remove();
        if (this.selected !== element)
        {
            if(this.selected != null) {
                this.selected.onOut();
                this.selected.selected = false;
                this.selected.onBlur(this.context);
            }

            this.selected = element;

            if (element === null)
            {
                this.$deleteButton.hide().removeClass('on');
                this.$settingsButton.hide();
            } else {
                this.$deleteButton.removeClass('on');
                this.selected.selected = true;
                this.selected.onSelect.call(this.selected, this.context);
            }
            this.render();
        }
    };

    iChart.Charting.ChartAreaLayer.prototype.start = function (elementType)
    {
        /// <summary>
        /// Finishes the drawing of the previous chart element, adds it to history, and starts a new one with the specified type.
        /// </summary>
        /// <param name="elementType">Type of the chart element that should be started.</param>

        this.unfinished = this.createElement(elementType);
        this.selected = this.unfinished;

        if (typeof this.unfinished !== "undefined")
        {
            this.history.push(this.unfinished);
        }

        return this.unfinished;
    };

    iChart.Charting.ChartAreaLayer.prototype.syncHash = function ()
    {
        /// <summary>
        /// Synchronizes the document location hash with the current chart canvas parameters.
        /// </summary>
        //this.chart.env.setHashValues(this.serialize());
    };

    iChart.Charting.ChartAreaLayer.prototype.update = function (area)
    {
        /// <summary>
        /// Updates drawing layer.
        /// </summary>

        if (!area)
        {
            return;
        }

        this.area = area;

        for (var i = 0; i < this.history.length; ++i)
        {
            delete this.history[i].testContext;
        }
        var $canvas = $('canvas#' + area.name);
        if($canvas.length) {
            this.canvas = $canvas.get(0);
            this.context = iChart.getContext(this.canvas);
            this.offset = this.chart._containerSize.offset;
        } else {
            var $container = $(this.chart.container);
            this._initCanvas($container.width(), $container.height());
            if (this.canvas) {
                $(this.canvas).attr('id', this.area.name)
            }
        }

        this.render();
    };

    iChart.Charting.ChartAreaLayer.prototype._initCanvas = function (width, height)
    {
        /// <summary>
        /// Initializes the canvas.
        /// </summary>
        /// <param name="width" type="Number">Canvas width in pixels.</param>
        /// <param name="height" type="Number">Canvas height in pixels.</param>

        this.canvas = iChart.Charting.initCanvas(this.chart.container, this.canvas, width, height);
        if (this.canvas)
        {
            this.context = iChart.getContext(this.canvas);
            this.offset = this.chart._containerSize.offset;
        }
    };
})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartDrawingLayer = function (chart)
    {
        /// <summary>
        /// Initializes a new instance of the iChart.Charting.ChartDrawingLayer class that provides methods for drawing some common figures on market data charts.
        /// </summary>
        /// <param name="chart" type="iChart.Charting.Chart">Chart this layer belongs to.</param>
        /// <field name="canvas" type="HTMLCanvasElement">Canvas used for drawing elements of this layer.</field>
        /// <field name="chart" type="iChart.Charting.Chart">Chart this layer belongs to.</field>
        this.$deleteButton = $("<span/>", { "class": "m-chart-instrument-delete", "text": "✕", "title": _t("87551", "Удалить инструмент") }).hide().appendTo(chart.container);
        this.$settingsButton = $("<span class ='m-chart-instrument-settings' href = '#' text = ''><span class='elementSettingsHolder' style='position: relative'></span></span>").hide();
        this.$settingsButton.attr('title', _t("87552", "Свойства"));
        this.$settingsButton.appendTo(chart.container);

        this.canvas = null;
        this.chart = chart;
        this.defaultCursor = "default";
        this.drag = null;
        this.history = [];
        this.hover = null;
        this.controlsHover = null;
        this.prevX = null;
        this.prevY = null;
        this.selected = null;
        this.unfinished = null;

        $(chart.container).off('mousedown.overlay').unbind('mouseup.overlay').unbind('mousemove.overlay');
        $(chart.container).on('mousedown.overlay', $.proxy(this.onMouseDown, this)).
            on('mouseup.overlay', $.proxy(this.onMouseUp, this)).
            on('mousemove.overlay', $.proxy(this.onMouseMove, this));

        if (this.chart.env.dataSource.dataSettings.useHash == false) {
            var hash = this.chart.env.dataSource.dataSettings.hash;
        } else {
            var hash = document.location.hash;
        }
        this.deserialize(iChart.parseQueryString((hash || "#").substr(1)));
    };

    iChart.Charting.ChartDrawingLayer.prototype.clear = function (all)
    {
        /// <summary>
        /// Clears the canvas, leaving only the chart image.
        /// </summary>

        all = !!all;
        if (this.history.length)
        {
            if(all) {
                this.$deleteButton.hide().removeClass('on');
                this.$settingsButton.hide();
                this.history = [];
                this.render();
                this.syncHash();
            } else {
                var overlayHistory = this.history;
                for(var i=0; i < overlayHistory.length; i++) {
                    var element = overlayHistory[i];
                    if(element.drawType == "manually") {
                        overlayHistory.splice(i, 1);
                        i--;
                    }
                }
                this.render();
                this.syncHash();
            }
        }
    };

    iChart.Charting.ChartDrawingLayer.prototype.createElement = function (elementType)
    {
        /// <summary>
        /// Initializes a new instance of the chart element with the specified type.
        /// </summary>
        /// <param name="elementType" type="String">Type of the chart element that should be initialized.</param>

        switch (elementType)
        {
            case "Channel":
                return new iChart.Charting.ChartChannel(this);
            case "Ellipse":
                return new iChart.Charting.ChartEllipse(this);
            case "FibonacciArc":
                return new iChart.Charting.ChartFibonacciArc(this);
            case "FibonacciCorrection":
                return new iChart.Charting.ChartFibonacciCorrection(this);
            case "FibonacciFan":
                return new iChart.Charting.ChartFibonacciFan(this);
            case "HorizontalLine":
                return new iChart.Charting.ChartHorizontalLine(this);
            case "Line":
                return new iChart.Charting.ChartLine(this);
            case "Rectangle":
                return new iChart.Charting.ChartRectangle(this);
            case "Trend":
                return new iChart.Charting.ChartTrend(this);
            case "Triangle":
                return new iChart.Charting.ChartTriangle(this);
            case "VerticalLine":
                return new iChart.Charting.ChartVerticalLine(this);
            case "Mark":
                return new iChart.Charting.ChartMark(this);
            case "Label":
                return new iChart.Charting.ChartLabel(this);
            case "Arrow":
                return new iChart.Charting.ChartArrow(this);
            case "Polygon":
                return new iChart.Charting.ChartPolygon(this);
            case "Trade":
                return new iChart.Charting.ChartTrade(this);
            case "Bubble":
                return new iChart.Charting.ChartBubble(this);
            case "Text":
                return new iChart.Charting.ChartText(this);
            case "Order":
                return new iChart.Charting.ChartOrder(this);
            case "Trendorder":
                return new iChart.Charting.ChartTrendorder(this);
            case "Position":
                return new iChart.Charting.ChartPosition(this);
            case "Visualtrade":
                return new iChart.Charting.ChartVisualtrade(this);
            case "TradePanel":
                return new iChart.Charting.ChartTradePanel(this);
            case "Button":
                return new iChart.Charting.ChartButton(this);
            case "Event":
                return new iChart.Charting.ChartEvent(this);
            case "Level":
                return new iChart.Charting.ChartLevel(this);
            case "Range":
                return new iChart.Charting.ChartRange(this);
            case "HorizontalRange":
                return new iChart.Charting.ChartHorizontalRange(this);
            default:
                return undefined;
        }
    };

    iChart.Charting.ChartDrawingLayer.prototype.deserialize = function (valueProvider)
    {
        /// <summary>
        /// Deserializes canvas content from the specified associative array.
        /// </summary>
        /// <param name="valueProvider" type="Object">A dictionary containing values.</param>
        this.$deleteButton.unbind("mousedown").hide().removeClass('on');
        this.$settingsButton.unbind("mousedown").hide();

        this.history = [];

        var elementCount = parseInt(valueProvider["L"], 10);

        if (isNaN(elementCount))
        {
            return;
        }

        theloop:
        for (var i = 0; i < elementCount; ++i)
        {
            var elementType = valueProvider["L" + i + "_T"];
            var element = this.createElement(elementType);
            if (typeof element === "undefined")
            {
                continue;
            }

            element.points = [];
            for (var j = 0; j < element.maxPointCount; ++j)
            {
                var point = {
                    "x": parseFloat(valueProvider["L" + i + "_X" + j]),
                    "y": parseFloat(valueProvider["L" + i + "_Y" + j])
                };

                if (isNaN(point.x) || isNaN(point.y))
                {
                    continue theloop;
                }

                element.points.push(point);
            }

            if(valueProvider["L" + i + "_S"]) {
                //element.settings = encodeURIComponent(valueProvider["L" + i + "_S"]);
                //element.settings = decodeURIComponent(valueProvider["L" + i + "_S"])
                //var str = .replace(/=/, '@');
                element.settings = JSON.parse(decodeURIComponent(window.atob(valueProvider["L" + i + "_S"].replace(/@/g, '='))));
                //element.settings = valueProvider["L" + i + "_S"];
            }

            this.history.push(element);
        }
    };

    iChart.Charting.ChartDrawingLayer.prototype.elementAt = function (x, y)
    {
        /// <summary>
        /// Returns chart element at the specified coordinates, or undefined if it is not present.
        /// </summary>
        /// <param name="x" type="Number">X pixel coordinate.</param>
        /// <param name="y" type="Number">Y pixel coordinate.</param>

        this.history.sort(function(a, b){
            if (a && a.selected) return -1;
            if (a && a.elementType == 'TradePanel') return -1;
            return 1;
        });

        for (var i = 0; i < this.history.length; ++i)
        {
            var element = this.history[i];
            var mode = element.isMouseOver.call(element, x, y);
            if (mode !== -1)
            {
                return { "mode": mode, "value": element };
            }
        }

        return undefined;
    };

    iChart.Charting.ChartDrawingLayer.prototype.finalizePoint = function (x, y)
    {
        /// <suummary>
        /// Adds the specified point to the figure that is being drawn at the moment and redraws the canvas.
        /// </summary>
        /// <param name="x" type="Number">X pixel coordinate.</param>
        /// <param name="y" type="Number">Y pixel coordinate.</param>

        this.unfinished.points[this.unfinished.points.length - 1].x = x;
        this.unfinished.points[this.unfinished.points.length - 1].y = y;
        if (this.unfinished.isComplete())
        {
            this.chart.env.wrapper.trigger('iguanaChartEvents', ['drawComplete', this.unfinished]);
            this.unfinished = null;
            this.syncHash();
            this.chart.container.style.cursor = this.defaultCursor;
        }
        else
        {
            this.unfinished.points.push({});
            this.chart.container.style.cursor = "crosshair";
        }

        this.render();
    };

    iChart.Charting.ChartDrawingLayer.prototype.getMarkers = function (dx, dy)
    {
        /// <summary>
        /// Gets shifted marker points of the chart element that is being dragged.
        /// </summary>
        /// <param name="dx" type="Number">X coordinate shift in pixels</param>
        /// <param name="dy" type="Number">Y coordinate shift in pixels</param>

        var markers = [];
        var outside = false;
        for (var i = 0; i < this.drag.element.points.length; ++i)
        {
            var point = this.drag.element.points[i];
            var marker = {};
            if (this.drag.mode === 0 || this.drag.mode === i + 1)
            {
                marker = $.extend({}, point);
                marker.x = 1000 * this.area.getXValue(this.area.getXPositionByValue(point.x / 1000) + dx);
                marker.y = this.area.getYValue(this.area.getYPosition(point.y) + dy);
                if (isNaN(marker.x) || isNaN(marker.y))
                {
                    outside = true;
                    break;
                }
            }
            else
            {
                marker = $.extend({}, point);
            }

            markers.push(marker);
        }

        return {
            "markers": markers,
            "outside": outside
        };
    };

    iChart.Charting.ChartDrawingLayer.prototype.getPixelPosition = function (axis, value)
    {
        /// <summary>
        /// Gets a pixel position that is equivalent to the specified value on the specified axis, or undefined if it is not present.
        /// </summary>
        /// <param name="axis" type="Object">Axis data.</param>
        /// <param name="value" type="Number">A value that should be searched on the axis.</param>

        var l = axis.length;
        if (l < 2 || axis[0][0] >= value)
        {
            return undefined;
        }

        for (var i = 1; i < l; ++i)
        {
            var pair = axis[i];
            if (pair[0] >= value)
            {
                return pair[1];
            }
        }

        return undefined;
    };

    iChart.Charting.ChartDrawingLayer.prototype.onMouseDown = function (e)
    {
        /// <summary>
        /// Handler for the document mousedown jQuery event. Used for drawing, dragging and selecting chart elements.
        /// </summary>

        if (typeof this.offset === "undefined")
        {
            return;
        }

        var x = Math.round(e.pageX - this.offset.left - this.area.innerOffset.left);
        var y = Math.round(e.pageY - this.offset.top - this.area.innerOffset.top);
        var valueX = 1000 * this.area.getXValue(x);
        var valueY = this.area.getYValue(y);

        $(window).data('mouseValueX', valueX);
        $(window).data('mouseValueY', valueY);

        if(this.chart.isComparison && !isNaN(valueY)) {
            var indexBase = iChart.Charting.getNearestNotNullIndex(this.chart.areas[0].ySeries[0].points, this.chart.areas[0].viewport.x.bounded.min);
            var base = this.chart.areas[0].ySeries[0].points[indexBase][3];
            valueY = base + base / 100 * valueY;
        }

        if (isNaN(valueX) || isNaN(valueY))
        {
            return;
        }

        if (this.unfinished !== null)
        {
            this.finalizePoint(valueX, valueY);
            this.selected.onInsert();
            return;
        }

        if (this.history.length === 0 || this.drag !== null)
        {
            return;
        }

        var element = this.elementAt(x, y);

        //Вызываем функцию
        if (element && element.value && typeof element.value.onMouseDown =='function' ) {
            element.value.onMouseDown(e, x, y);
        }


        if (typeof element === "undefined")
        {
            this.setSelected(null);
            return;
        } else if(!element.value.controlEnable) {
            return;
        } else if(element.mode.toString().match(new RegExp("^m_", "i"))) {
            var m = element.mode.toString().match(new RegExp(/^m_(\d)/i));
            element.value.maps[m[1]].click();
        } else if(element.mode.toString().match(new RegExp("^c_", "i"))) {
            //Перенес в onMouseUp
            var c = element.mode.toString().match(new RegExp(/^c_(\d)/i));
            element.value.controls[c[1]].click();
            return;
        } else if(element.mode.toString().match(new RegExp("^a_", "i"))) {
        }

        this.setSelected(element.value);
        if (element.hasSettings) {

        }

        this.drag = {};
        this.drag.element = this.selected;
        this.drag.mode = element.mode;
        this.drag.x = x;
        this.drag.y = y;

        // Disable selection so that it doesn't interfere with drag.
        if (this.chart.selection)
        {
            this.chart.selection.disable();
        }
    };

    iChart.Charting.ChartDrawingLayer.prototype.onMouseMove = function (e)
    {
        /// <summary>
        /// Handler for the document mousemove jQuery event. Used for dragging and selecting chart elements.
        /// </summary>

        if (typeof this.offset === "undefined")
        {
            return;
        }

        var x = Math.round(e.pageX - this.offset.left - this.area.innerOffset.left);
        var y = Math.round(e.pageY - this.offset.top - this.area.innerOffset.top);
        if (x === this.prevX && y === this.prevY)
        {
            // Minor performance optimization: do not handle the same coordinates twice in a row.
            return;
        }

        this.prevX = x;
        this.prevY = y;

        var valueX = 1000 * this.area.getXValue(x);
        var valueY = this.area.getYValue(y);

        this.prevValueX = valueX;
        this.prevValueY = valueY;

        if(this.chart.isComparison && !isNaN(valueY)) {
            var indexBase = iChart.Charting.getNearestNotNullIndex(this.chart.areas[0].ySeries[0].points, this.chart.areas[0].viewport.x.bounded.min);
            var base = this.chart.areas[0].ySeries[0].points[indexBase][3];
            valueY = base + base / 100 * valueY;
        }

        if (isNaN(valueX) || isNaN(valueY))
        {
            this.setHover(null);
            this.chart.container.style.cursor = this.defaultCursor;
            return;
        }

        if (this.unfinished !== null)
        {
            this.hover = null;
            this.unfinished.points[this.unfinished.points.length - 1].x = valueX;
            this.unfinished.points[this.unfinished.points.length - 1].y = valueY;
            this.render();
            this.chart.container.style.cursor = "crosshair";
            return;
        }

        if (this.drag !== null)
        {
            if(!isNaN(parseInt(this.drag.mode))) {
                if (typeof this.drag.element.moveCursor != "undefined") {
                    this.chart.container.style.cursor = this.drag.element.moveCursor;
                } else {
                    this.chart.container.style.cursor = "move";
                }
            }

            var dx = x - this.drag.x;
            var dy = y - this.drag.y;
            if (dx === 0 && dy === 0)
            {
                return;
            }

            var result = this.getMarkers(dx, dy);
            this.drag.element.onDrag(result.markers);

            if (result.outside)
            {
                if (typeof this.drag.element.markers !== "undefined")
                {
                    delete this.drag.element.markers;
                    this.render();
                }
            }
            else
            {
                this.drag.element.markers = result.markers;
                this.render();
            }

            return;
        }

        var element = this.elementAt(x, y);
        if (typeof element === "undefined")
        {
            this.setHover(null);
            this.setControlsHover(null);
            this.chart.container.style.cursor = this.defaultCursor;
        }
        else
        {
            if(element.mode.toString().match(new RegExp("^c_", "i"))) {
                this.chart.container.style.cursor = "pointer";
                this.setControlsHover(element);
            } else if (element.mode.toString().match(new RegExp("^a_", "i"))) {
                this.setHover(null);
                this.setControlsHover(element);
                this.chart.container.style.cursor = this.defaultCursor;
            } else if (element.mode.toString().match(new RegExp("^m_", "i"))) {
                var m = element.mode.toString().match(new RegExp(/^m_(\d)/i));
                //console.log(element.mode);
                this.setControlsHover(element);
                this.chart.container.style.cursor = "pointer";
            } else {
                this.setHover(element.value, x, y);
                this.setControlsHover(element);

                if(typeof element.value.hoverCursor != "undefined" || typeof element.value.hoverPointCursor != "undefined") {
                    if(element.mode > 0 && typeof element.value.hoverPointCursor != "undefined") {
                        this.chart.container.style.cursor = element.value.hoverPointCursor;
                    } else if(element.mode == 0 && typeof element.value.hoverCursor != "undefined") {
                        this.chart.container.style.cursor = element.value.hoverCursor;
                    } else {
                        this.chart.container.style.cursor = "pointer";
                    }
                } else {
                    this.chart.container.style.cursor = "pointer";
                }
            }
        }
    };

    iChart.Charting.ChartDrawingLayer.prototype.onMouseUp = function (e)
    {
        /// <summary>
        /// Handler for the document mouseup jQuery event. Used for dragging chart elements.
        /// </summary>

        var x = Math.round(e.pageX - this.offset.left - this.area.innerOffset.left);
        var y = Math.round(e.pageY - this.offset.top - this.area.innerOffset.top);

        var element = this.elementAt(x, y);
        if (typeof element === "undefined")
        {
        } else if(!element.value.controlEnable) {
            return;
        } else if(element.mode.toString().match(new RegExp("^c_", "i"))) {
            //var c = element.mode.toString().match(new RegExp(/^c_(\d)/i));
            //element.value.controls[c[1]].click();
            //return;
        } else if(element.mode.toString().match(new RegExp("^a_", "i"))) {
        }

        if (typeof this.offset === "undefined")
        {
            return;
        }

        if (this.drag === null)
        {
            return;
        }

        var x = Math.round(e.pageX - this.offset.left - this.area.innerOffset.left);
        var y = Math.round(e.pageY - this.offset.top - this.area.innerOffset.top);
        var valueX = 1000 * this.area.getXValue(x);
        var valueY = this.area.getYValue(y);
        if(this.chart.isComparison && !isNaN(valueY)) {
            var base = this.chart.areas[0].ySeries[0].points[this.chart.areas[0].viewport.x.bounded.min][3];
            valueY = base + base / 100 * valueY;
        }

        if (isNaN(valueX) || isNaN(valueY))
        {
            return;
        }

        var dx = x - this.drag.x;
        var dy = y - this.drag.y;
        if (dx !== 0 || dy !== 0)
        {
            var result = this.getMarkers(dx, dy);
            this.drag.element.onDrag(result.markers);

            if (!result.outside)
            {
                this.drag.element.points = result.markers;
                delete this.drag.element.testContext;
                this.syncHash();
                this.drag.element.onDrop(this.drag.mode);
            }
        }
        delete this.drag.element.markers;
        this.drag = null;
        this.render();
        if (this.chart.selection)
        {
            this.chart.selection.enable();
        }
    };

    iChart.Charting.ChartDrawingLayer.prototype.remove = function (element)
    {
        /// <summary>
        /// Removes the specified chart element from the canvas.
        /// </summary>

        var i = this.history.indexOf(element);
        if (i === -1)
        {
            return;
        }

        this.$deleteButton.unbind("mousedown").hide().removeClass('on');
        this.$settingsButton.unbind("mousedown").hide();

        this.history.splice(i, 1);
        this.render();
        this.syncHash();
    };

    iChart.Charting.ChartDrawingLayer.prototype.removeSelected = function (element)
    {
        /// <summary>
        /// Removes the currently selected chart element from the canvas.
        /// </summary>

        if (this.selected !== null && !element)
        {
            this.remove(this.selected);
        } else {
            this.remove(element);
        }
    };

    iChart.Charting.ChartDrawingLayer.prototype.render = function (context)
    {
        /// <summary>
        /// Redraws the layer.
        /// </summary>

        if (!context)
        {
            if(!this.context) {
                console.log("ERROR: No context for render");
                return 0;
            }
            context = this.context;
            var canvasSize = getElementSize(context.canvas);
            context.clearRect(0, 0, canvasSize.width, canvasSize.height);
        }

        context.save();
        context.translate(this.area.innerOffset.left, this.area.innerOffset.top);

        context.beginPath();
        context.moveTo(0, this.area.innerHeight);
        context.lineTo(this.area.outerWidth, this.area.innerHeight);
        context.lineTo(this.area.outerWidth, 0);
        context.lineTo(0, 0);
        context.closePath();
        context.clip();

        for (var i = 0; i < this.history.length; ++i)
        {
            this.history[i].drawExtended(context, -1);
        }
        context.restore();

        context.save();
        context.translate(this.area.innerOffset.left + 0.5, this.area.innerOffset.top + 0.5);
        //context.translate(this.area.innerOffset.left, this.area.innerOffset.top);

        context.beginPath();
        context.moveTo(0, this.area.innerHeight);
        context.lineTo(this.area.innerWidth, this.area.innerHeight);
        context.lineTo(this.area.innerWidth, 0);
        context.lineTo(0, 0);
        context.closePath();
        context.clip();
        if(typeof context.busyPoints != "undefined") {
            context.busyPoints = {};
        }

        this.history.sort(function(a,b){
            if (a.selected) return 1;
            if (a.inHover && b.selected) return -1;
            if (a.inHover && (!b.inHover && !b.selected)) return 1;
        });

        for (var i = 0; i < this.history.length; ++i)
        {
            this.history[i].draw(context, -1);
        }
        context.restore();


        if (typeof FlashCanvas !== "undefined")
        {
            // Flush and execute commands.
            context.e();
        }
    };

    iChart.Charting.ChartDrawingLayer.prototype.serialize = function ()
    {
        /// <summary>
        /// Serializes current chart canvas parameters to an associative array.
        /// </summary>

        var parameters = {};

        var ir = 0;

        parameters["L"] = 0;

        for (var i = 0; i < this.history.length; ++i)
        {
            var element = this.history[i];

            if (element.isComplete() && element.controlEnable && element.storageEnable)
            {
                parameters["L" + ir + "_T"] = element.elementType;
                for (var j = 0; j < element.points.length; ++j)
                {
                    parameters["L" + ir + "_X" + j] = element.points[j].x;
                    parameters["L" + ir + "_Y" + j] = element.points[j].y;
                }
                if(element.hasSettings) {
                    //parameters["L" + i + "_S"] = element.settings;
                    //parameters["L" + i + "_S"] = encodeURIComponent(element.settings);
                    parameters["L" + ir + "_S"] = window.btoa(encodeURIComponent(JSON.stringify(element.settings))).replace(/=/g, '@');
                }
                ir++;
                parameters["L"] = parameters["L"] + 1;
            }
        }
        return parameters;
    };

    /**
     * Отслеживание смены переходов областей
     * @param element
     */
    iChart.Charting.ChartDrawingLayer.prototype.setControlsHover = function (element) {
        if(this.controlsHover) {
            if(element) {
                if (this.controlsHover.value.id != element.value.id || this.controlsHover.mode != element.mode) {
                    if (this.controlsHover.toString().match(new RegExp("^c_", "i"))) {
                        //var c = this.controlsHover.mode.toString().match(new RegExp(/^c_(\d)/i));
                    } else if (this.controlsHover.mode.toString().match(new RegExp("^a_", "i"))) {
                        //var a = this.controlsHover.mode.toString().match(new RegExp(/^a_(\d)/i));
                    } else if (this.controlsHover.mode.toString().match(new RegExp("^m_", "i"))) {
                        var m = this.controlsHover.mode.toString().match(new RegExp(/^m_(\d)/i));
                        if(typeof this.controlsHover.value.maps != 'undefined' && typeof this.controlsHover.value.maps[m[1]].hoverOut == 'function') {
                            this.controlsHover.value.maps[m[1]].hoverOut();
                            this.controlsHover = null;
                        }
                    }

                    if (element.mode.toString().match(new RegExp("^c_", "i"))) {
                        //var c = element.mode.toString().match(new RegExp(/^c_(\d)/i));
                    } else if (element.mode.toString().match(new RegExp("^a_", "i"))) {
                        //var a = element.mode.toString().match(new RegExp(/^a_(\d)/i));
                    } else if (element.mode.toString().match(new RegExp("^m_", "i"))) {
                        var m = element.mode.toString().match(new RegExp(/^m_(\d)/i));
                        if(typeof element.value.maps != 'undefined' && typeof element.value.maps[m[1]].hoverIn == 'function') {
                            this.controlsHover = element;
                            element.value.maps[m[1]].hoverIn();
                        }
                    }

                }
            } else {
                if (this.controlsHover.toString().match(new RegExp("^c_", "i"))) {
                    //var c = this.controlsHover.mode.toString().match(new RegExp(/^c_(\d)/i));
                } else if (this.controlsHover.mode.toString().match(new RegExp("^a_", "i"))) {
                    //var a = this.controlsHover.mode.toString().match(new RegExp(/^a_(\d)/i));
                } else if (this.controlsHover.mode.toString().match(new RegExp("^m_", "i"))) {
                    var m = this.controlsHover.mode.toString().match(new RegExp(/^m_(\d)/i));
                    if(typeof this.controlsHover.value.maps != 'undefined' && typeof this.controlsHover.value.maps[m[1]].hoverOut == 'function') {
                        this.controlsHover.value.maps[m[1]].hoverOut();
                        this.controlsHover = null;
                    }
                }
            }
        } else {
            if(element) {
                if (element.mode.toString().match(new RegExp("^c_", "i"))) {
                    //var c = element.mode.toString().match(new RegExp(/^c_(\d)/i));
                } else if (element.mode.toString().match(new RegExp("^a_", "i"))) {
                    //var a = element.mode.toString().match(new RegExp(/^a_(\d)/i));
                } else if (element.mode.toString().match(new RegExp("^m_", "i"))) {
                    var m = element.mode.toString().match(new RegExp(/^m_(\d)/i));
                    if(typeof element.value.maps != 'undefined' && typeof element.value.maps[m[1]].hoverIn == 'function') {
                        this.controlsHover = element;
                        element.value.maps[m[1]].hoverIn();
                    }
                }
            }
        }
    };

    iChart.Charting.ChartDrawingLayer.prototype.setHover = function (element, x, y)
    {
        /// <summary>
        /// Sets hover to the specified chart element and redraws the canvas to highlight it.
        /// </summary>
        /// <param name="element">Chart element the mouse is over at the moment.</param>

        if(this.hover !== null && (element == null || this.hover !== element)) {


            this.hover.inHover = false;

            this.hover.onOut();
        }

        if (element !== null)
        {
            element.inHover = true;
        }

        if (this.hover !== element)
        {
            this.hover = element;

            if(element !== null && typeof element.onHover === 'function') {
                element.onHover(x, y);
            }

            this.render();
        }
    };

    iChart.Charting.ChartDrawingLayer.prototype.setSelected = function (element)
    {
        /// <summary>
        /// Sets selection to the specified chart element and redraws the canvas to change selection.
        /// </summary>
        /// <param name="element">Chart element that is being selected, or a null to deselect the element that was selected before.</param>

        $('#elementSettings').remove();
        if (this.selected !== element)
        {
            if(this.selected != null) {
                this.selected.onOut();
                this.selected.selected = false;
                this.selected.onBlur(this.context);
            }

            this.selected = element;

            if (element === null)
            {
                this.$deleteButton.hide().removeClass('on');
                this.$settingsButton.hide();
            } else {
                this.$deleteButton.removeClass('on');
                this.selected.selected = true;
                this.selected.onSelect.call(this.selected, this.context);
            }
            this.render();
        }
    };

    iChart.Charting.ChartDrawingLayer.prototype.start = function (elementType)
    {
        /// <summary>
        /// Finishes the drawing of the previous chart element, adds it to history, and starts a new one with the specified type.
        /// </summary>
        /// <param name="elementType">Type of the chart element that should be started.</param>

        this.unfinished = this.createElement(elementType);
        this.selected = this.unfinished;

        if (typeof this.unfinished !== "undefined")
        {
            this.history.push(this.unfinished);
        }

        return this.unfinished;
    };

    iChart.Charting.ChartDrawingLayer.prototype.syncHash = function ()
    {
        /// <summary>
        /// Synchronizes the document location hash with the current chart canvas parameters.
        /// </summary>
        this.chart.env.setHashValues(this.serialize());
    };

    iChart.Charting.ChartDrawingLayer.prototype.update = function ()
    {
        /// <summary>
        /// Updates drawing layer.
        /// </summary>

        if (!this.chart.areas)
        {
            return;
        }

        this.area = this.chart.areas[0];

        for (var i = 0; i < this.history.length; ++i)
        {
            delete this.history[i].testContext;
        }
        var $container = $(this.chart.container);
        this._initCanvas($container.width(), $container.height());
        this.render();
    };

    iChart.Charting.ChartDrawingLayer.prototype._initCanvas = function (width, height)
    {
        /// <summary>
        /// Initializes the canvas.
        /// </summary>
        /// <param name="width" type="Number">Canvas width in pixels.</param>
        /// <param name="height" type="Number">Canvas height in pixels.</param>

        this.canvas = iChart.Charting.initCanvas(this.chart.container, this.canvas, width, height);
        if (this.canvas)
        {
            this.context = iChart.getContext(this.canvas);
            this.offset = this.chart._containerSize.offset;
        }
    };
})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartElement = function (layer)
    {
        /// <summary>
        /// Initializes a new instance of the iChart.Charting.ChartElement class representing a chart element on the specified chart canvas.
        /// </summary>
        /// <param name="layer" type="iChart.Charting.ChartDrawingLayer">A chart drawing layer to which this element is rendered.</param>
        /// <field name="layer" type="iChart.Charting.ChartDrawingLayer">A chart drawing layer to which this element is rendered.</field>
        /// <field name="maxPointCount" type="Number">A maximum number of points the element can contain.</field>
        /// <field name="points" type="Array" elementType="Object">A list of points belonging to this element.</field>
        /// <field name="testContext" type="Object">Internal representation of the element used to detect mouse over.</field>

        this.layer = layer;
        this.selected = false;
        this.maxPointCount = 2;
        this.points = [{}];
        this.testContext = undefined;
        this.id = layer.history.length + '_' + new Date().getTime();
        this.controlEnable = true;
        this.storageEnable = true;
        this.hasSettings = false;
        this.settings = {};
        this.hasPopupSettings = false;
        this.drawSingle = false;//Рисовать без копии фигуры при перетаскивании
        this.positionAbsolute = false;
        this.inHover = false;

        layer.setSelected(null)
    };

    iChart.Charting.ChartElement.prototype.draw = function (ctx)
    {
        /// <summary>
        /// Draws this chart element using the specified 2D canvas context.
        /// </summary>
        /// <param name="ctx" type="CanvasRenderingContext2D">A 2D canvas context to use when drawing the chart element.</param>

        if (this === this.layer.hover)
        {
            ctx.fillStyle = "rgba(255,255,153,.2)";
            ctx.strokeStyle = "#52afc9";
            ctx.inHover = true;
        }
        else
        {
            ctx.inHover = false;
            if (ctx.hasSettings) {
                    var settings = ctx.settings;
                    ctx.fillStyle   = settings.fillStyle;
                    ctx.strokeStyle = settings.strokeStyle;
                    ctx.lineWidth = settings.lineWidth;
            } else {
                ctx.fillStyle = "rgba(0,0,0,.0)";
                ctx.strokeStyle = "#000";
            }

        }

        //Рисовать без копии фигуры при перетаскивании
        if(this.drawSingle) {
            if (typeof this.markers !== "undefined")
            {
                // Draws the copy of the element if it is being dragged.
                ctx.fillStyle = "rgba(82,175,201,.2)";
                ctx.strokeStyle = "#52afc9";

                pointCoords = this.getCoordinates(ctx, this.markers);
                this.drawInternal(ctx, pointCoords);
                this.drawPoints(ctx, pointCoords);
            } else {
                var pointCoords = this.getCoordinates(ctx, this.points);
                this.drawInternal(ctx, pointCoords);
                this.drawPoints(ctx, pointCoords);
            }
        } else {
            var pointCoords = this.getCoordinates(ctx, this.points);
            this.drawInternal(ctx, pointCoords);
            this.drawPoints(ctx, pointCoords);

            if (typeof this.markers !== "undefined")
            {
                // Draws the copy of the element if it is being dragged.
                ctx.fillStyle = "rgba(82,175,201,.2)";
                ctx.strokeStyle = "#52afc9";

                pointCoords = this.getCoordinates(ctx, this.markers);
                this.drawInternal(ctx, pointCoords);
                this.drawPoints(ctx, pointCoords);
            }
        }
    };

    iChart.Charting.ChartElement.prototype.drawInternal = function (ctx, coords)
    {
        /// <summary>
        /// Draws the element at the specified pixel coordinates using the specified 2D canvas context.
        /// </summary>
        /// <param name="ctx" type="CanvasRenderingContext2D">A 2D canvas context to use when drawing the chart element.</param>
        /// <param name="coords">Chart element marker points converted to actual pixel coordinates.</param>
    };

    iChart.Charting.ChartElement.prototype.drawExtended = function (ctx) {};

    iChart.Charting.ChartElement.prototype.onHover = function (ctx) {};

    iChart.Charting.ChartElement.prototype.onOut = function (ctx) {};

    iChart.Charting.ChartElement.prototype.onSelect = function (ctx) {
        this.layer.chart.env.wrapper.trigger('iguanaChartEvents', ['selectInstrument', this]);
    };

    iChart.Charting.ChartElement.prototype.onBlur = function (ctx) {};

    iChart.Charting.ChartElement.prototype.onRemove = function () {};

    iChart.Charting.ChartElement.prototype.onDrop = function () {};

    iChart.Charting.ChartElement.prototype.onDrag  = function (points) {};

    iChart.Charting.ChartElement.prototype.drawPopupSettings = function (ctx, coords) {};

    iChart.Charting.ChartElement.prototype.setSettings = function (settings) {
        this.settings = $.extend(this.settings, settings);
        if(typeof this.layer != "undefined" && this.layer.context) {
            this.layer.render();
            this.layer.syncHash();
        }
    };

    /**
     *
     * @param ctx
     * @param settings
     */
    iChart.Charting.ChartElement.prototype.initDrawSettings = function (ctx, settings) {
        if(settings != undefined) {
            var settings = settings;

            if(typeof settings.lineDash != "undefined") {
                if (typeof ctx.setLineDash !== "undefined") ctx.setLineDash(settings.lineDash);
                if ( ctx.mozDash !== undefined )       ctx.mozDash = settings.lineDash;
            }

            if (ctx.inHover) {
                //console.log(settings);
                ctx.fillStyle = iChart.invertColor(settings.fillStyle);
                ctx.strokeStyle = iChart.invertColor(settings.strokeStyle);
                ctx.lineWidth = settings.lineWidth;
            } else {
                ctx.fillStyle   = settings.fillStyle;
                ctx.strokeStyle = settings.strokeStyle;
                ctx.lineWidth = settings.lineWidth;
            }
        }
    };

    iChart.Charting.ChartElement.prototype.onInsert = function () {
        this.selected = true;
    };

    iChart.Charting.ChartElement.prototype.getCoordinates = function (ctx, points)
    {
        /// <summary>
        /// Converts the specified element points to actual pixel coordinates using the specified 2D canvas context.
        /// </summary>
        /// <param name="ctx" type="CanvasRenderingContext2D">A 2D canvas context to use when drawing the points.</param>
        /// <param name="points">Points to draw.</param>

        var coords = [];
        for (var i = 0; i < points.length; ++i)
        {
            var coord = {};
            coord.x = Math.round(this.layer.area.getXPositionByValue(points[i].x / 1000));
            if (isNaN(coord.x))
            {
                break;
            }

            if(this.layer.chart.isComparison) {
                var y = ((points[i].y  /  this.layer.area.ySeries[0].points[this.layer.area.viewport.x.bounded.min][3]) - 1) * 100;
                coord.y = Math.round(this.layer.area.getYPosition(y));

            } else {
                coord.y = Math.round(this.layer.area.getYPosition(points[i].y));
            }

            if (isNaN(coord.y))
            {
                break;
            }

            if (this === this.layer.selected && this.controlEnable && this.storageEnable)
            {
                // Place the delete button at the first marker point.
                if (i === 0)
                {
                    var self = this;
                    var deleteButton_onClick = function ()
                    {
//                        if (confirm("Удалить инструмент?"))
//                        {
                            //
//                        }

                        if($(this).hasClass('on')) {
                            self.remove();
                        } else {
                            $(this).addClass('on');
                        }
                        return false;
                    };

                    this.layer.$deleteButton.unbind("mousedown").mousedown(deleteButton_onClick).show().css({ "left": this.layer.area.innerOffset.left + coord.x + 2, "top": this.layer.area.innerOffset.top + coord.y + 2 });
                    if(this.hasSettings && this.hasPopupSettings) {
                        var settingsButton_onClick = function ()
                        {
                            self.drawPopupSettings(ctx, coord);
                            return false;
                        };
                        this.layer.$settingsButton.unbind("mousedown").mousedown(settingsButton_onClick).show().css({ "left": this.layer.area.innerOffset.left + coord.x - 10 , "top": this.layer.area.innerOffset.top + coord.y + 2 });
                    }

                }
            }

            coords.push(coord);
        }
        return coords;
    };

    iChart.Charting.ChartElement.prototype.drawPoints = function (ctx, pointCoords)
    {
        if (this === this.layer.selected && this.controlEnable)
        {
            for (var i = 0; i < pointCoords.length; ++i) {
                var point = pointCoords[i];
                ctx.save();
                ctx.beginPath();
                ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI, true);
                ctx.fillStyle = '#fff';
                ctx.globalAlpha = 1;
                ctx.lineWidth = 2;
                ctx.stokeStyle = '#eee';
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }
        }
    }

    iChart.Charting.ChartElement.prototype.getTestContext = function (force)
    {
        /// <summary>
        /// Gets context used for detecting cursor position relative to the element.
        /// </summary>

        force = !!force;

        if (typeof this.testContext === "undefined" || force)
        {
            this.testContext = {};

            var self = this;
            this.testContext.points = $.map(this.points, function (value, index)
            {
                return {
                    "x": Math.round(self.layer.area.getXPositionByValue(value.x / 1000)),
                    "y": Math.round(self.layer.area.getYPosition(value.y))
                };
            });

            this.setTestSegments();
        }

        return this.testContext;
    };

    iChart.Charting.ChartElement.prototype.isComplete = function ()
    {
        /// <summary>
        /// Gets a value indicating whether this chart element is complete.
        /// </summary>
        /// <returns type="Boolean" />

        return this.points.length === this.maxPointCount;
    };

    iChart.Charting.ChartElement.prototype.isMouseOver = function (x, y)
    {
        /// <summary>
        /// Gets a value indicating whether the mouse cursor at the specified coordinates is over this chart element.
        /// Returns the index of the marker point plus 1 if the cursor is close to a marker point.
        /// Returns a zero if the cursor is close to one of the element lines but not to a marker.
        /// Returns a -1 if the cursor is not close to any of the marker points/lines of the element.
        /// </summary>
        /// <param name="x" type="Number">X coordinate of the mouse.</param>
        /// <param name="y" type="Number">Y coordinate of the mouse.</param>
        /// <returns type="Boolean" />

        if (!this.isComplete())
        {
            return -1;
        }

        var testContext = this.getTestContext();

        if(typeof testContext.maps != 'undefined') {
            for (var i in testContext.maps)
            {
                var c = testContext.maps[i];
                if(x >= c[0].x && x <= c[1].x && y >= c[0].y && y <= c[1].y) {
                    return 'm_' + i;
                }
            }
        }

        // Check whether the coordinates are close to any of the marker points.
        for (var i = 0; i < testContext.points.length; ++i)
        {
            var p = testContext.points[i];
            var d = iChart.Charting.pointToPointDistanceSquared(p, { "x": x, "y": y });
            if (d <= 64)
            {
                return i + 1;
            }
        }

        // Check whether the coordinates are close to any of the lines constituting the element.
        for (var i = 0; i < testContext.segments.length; ++i)
        {
            var s = testContext.segments[i];
            var d = iChart.Charting.pointToSegmentDistanceSquared(s, { "x": x, "y": y }, true);
            if (d <= 64)
            {
                return 0;
            }
        }

        if(this.selected) {
            if(typeof testContext.controls != 'undefined') {
                for (var i in testContext.controls)
                {
                    var c = testContext.controls[i];
                    if(x >= c[0].x && x <= c[1].x && y >= c[0].y && y <= c[1].y) {
                        return 'c_' + i;
                    }
                }
            }
        }

        if(typeof testContext.elementArea != 'undefined') {
            var a = testContext.elementArea;
            if(x >= a[0].x && x <= a[1].x && y >= a[0].y && y <= a[1].y) {
                return 'a_' + 0;
            }
        }

        return -1;
    };

    iChart.Charting.ChartElement.prototype.remove = function ()
    {
        /// <summary>
        /// Removes this chart element from the canvas, effectively destroying it for good.
        /// </summary>

        this.onRemove();
        this.layer.remove(this);
        delete this.layer;
        delete this.testContext;
    };

    iChart.Charting.ChartElement.prototype.setTestSegments = function ()
    {
        /// <summary>
        /// Sets test segments based on the element marker points.
        /// </summary>

        this.testContext.segments = [
            this.testContext.points
        ];

        this.testContext.controls = [];
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartChannel = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Channel";
        this.drawType = 'manually';
        this.maxPointCount = 3;
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartChannel, iChart.Charting.ChartElement);

    iChart.Charting.ChartChannel.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        this.initDrawSettings(ctx, this.settings);

        ctx.beginPath();
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.stroke();

        if (coords.length < 3)
        {
            return;
        }

        ctx.beginPath();
        ctx.moveTo(coords[2].x, coords[2].y);
        ctx.lineTo(coords[1].x + (coords[2].x - coords[0].x), coords[1].y + (coords[2].y - coords[0].y));
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.lineTo(coords[1].x + (coords[2].x - coords[0].x), coords[1].y + (coords[2].y - coords[0].y) );
        ctx.lineTo(coords[2].x, coords[2].y );
        ctx.fill();
    };

    iChart.Charting.ChartChannel.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            this.testContext.points,
            [this.testContext.points[2], { "x": this.testContext.points[1].x + (this.testContext.points[2].x - this.testContext.points[0].x), "y": this.testContext.points[1].y + (this.testContext.points[2].y - this.testContext.points[0].y)}]
        ];
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartEllipse = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Ellipse";
        this.drawType = 'manually';
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartEllipse, iChart.Charting.ChartElement);

    iChart.Charting.ChartEllipse.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        var height = Math.abs(coords[1].y - coords[0].y);
        var width = Math.abs(coords[1].x - coords[0].x);
        if (height <= 4 || width <= 4)
        {
            return;
        }

        var centerX = (coords[0].x + coords[1].x) / 2;
        var centerY = (coords[0].y + coords[1].y) / 2;

        var controlRectHalfWidth = width * 2 / 3;

        this.initDrawSettings(ctx, this.settings);
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - height / 2);
        ctx.bezierCurveTo(centerX - controlRectHalfWidth, centerY - (height / 2), centerX - controlRectHalfWidth, centerY + (height / 2), centerX, centerY + (height / 2));
        ctx.bezierCurveTo(centerX + controlRectHalfWidth, centerY + (height / 2), centerX + controlRectHalfWidth, centerY - (height / 2), centerX, centerY - (height / 2));
        ctx.fill();
        ctx.stroke();
    };

    iChart.Charting.ChartEllipse.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            [this.testContext.points[0], { "x": this.testContext.points[0].x, "y": this.testContext.points[1].y}],
            [{ "x": this.testContext.points[0].x, "y": this.testContext.points[1].y }, this.testContext.points[1]],
            [this.testContext.points[1], { "x": this.testContext.points[1].x, "y": this.testContext.points[0].y}],
            [{ "x": this.testContext.points[1].x, "y": this.testContext.points[0].y }, this.testContext.points[0]]
        ];
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartFibonacciArc = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "FibonacciArc";
        this.drawType = 'manually';
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartFibonacciArc, iChart.Charting.ChartElement);

    iChart.Charting.ChartFibonacciArc.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        ctx.beginPath();
        this.initDrawSettings(ctx, this.settings);
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.stroke();

        var d = Math.sqrt(iChart.Charting.pointToPointDistanceSquared(coords[0], coords[1]));
        if (d <= 4)
        {
            return;
        }

        var percentages = [0.382, 0.5, 0.618];
        for (var i = 0; i < percentages.length; ++i)
        {
            ctx.beginPath();
            ctx.arc(coords[0].x, coords[0].y, d * percentages[i], 0, Math.PI, coords[0].y > coords[1].y);
            ctx.stroke();
        }
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartFibonacciCorrection = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "FibonacciCorrection";
        this.drawType = 'manually';
        //this.percentages = [0, 0.382, 0.5, 0.618, 1, 1.618, 2.618, 4.236];
        this.percentages = [0, 0.382, 0.5, 0.618, 0.786, 1, 1.272, 1.618];
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartFibonacciCorrection, iChart.Charting.ChartElement);

    iChart.Charting.ChartFibonacciCorrection.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        ctx.save();
        ctx.beginPath();
        this.initDrawSettings(ctx, this.settings);
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.stroke();

        var h = coords[1].y - coords[0].y;
        if (Math.abs(h) <= 4)
        {
            ctx.restore();
            return;
        }

        for (var i = 0; i < this.percentages.length; ++i)
        {
            var y = Math.round(coords[0].y + (h * this.percentages[i]));

            ctx.beginPath();
            ctx.moveTo(coords[0].x, y);
            var canvasSize = getElementSize(ctx.canvas);
            ctx.lineTo(canvasSize.width, y);
            ctx.stroke();

            if (this.percentages[i] != 0) {
                //Напишем значение
                ctx.font="12px Arial";
                var offset = ctx.measureText(this.percentages[i]);
                ctx.fillText(this.percentages[i],coords[0].x-offset.width-5,y+5);
            }
        }
        ctx.restore();
    };
})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartFibonacciFan = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "FibonacciFan";
        this.drawType = 'manually';
        this.percentages = [0.382, 0.5, 0.618];
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartFibonacciFan, iChart.Charting.ChartElement);

    iChart.Charting.ChartFibonacciFan.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        ctx.beginPath();
        this.initDrawSettings(ctx, this.settings);
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.stroke();

        var h = coords[1].y - coords[0].y;
        if (Math.abs(h) <= 4)
        {
            return;
        }

        h /= coords[1].x - coords[0].x;
        for (var i = 0; i < this.percentages.length; ++i)
        {
            ctx.beginPath();
            ctx.moveTo(coords[0].x, coords[0].y);
            var canvasSize = getElementSize(ctx.canvas);
            ctx.lineTo(canvasSize.width, coords[0].y + (this.percentages[i] * h * (canvasSize.width - coords[0].x)));
            ctx.stroke();
        }
    };
})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartHorizontalLine = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "HorizontalLine";
        this.drawType = 'manually';
        this.maxPointCount = 1;
        this.hasSettings = true;
        this.settings = $.extend({drawLabel: true}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartHorizontalLine, iChart.Charting.ChartElement);

    iChart.Charting.ChartHorizontalLine.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 1)
        {
            return;
        }

        var canvasWidth = getElementSize(ctx.canvas).width;
        var point = this.layer.area.getXValue(canvasWidth - 200);
        this.points[0].x = point * 1000;
        coords[0].x = canvasWidth - 200;

        ctx.save();
        ctx.beginPath();
        this.initDrawSettings(ctx, this.settings);
        ctx.moveTo(0, coords[0].y);
        ctx.lineTo(canvasWidth, coords[0].y);
        ctx.stroke();
        ctx.restore();

    };

    iChart.Charting.ChartHorizontalLine.prototype.drawExtended = function (ctx)
    {
        if(this.settings.drawLabel) {
            var pointCoords = this.getCoordinates(ctx, this.points);

            if (pointCoords.length < 1) {
                return;
            }
            var settings = this.settings;
            var label = this.layer.chart.renderer.formatNumber(this.layer.area.getYValue(pointCoords[0].y), {
                "decimalPrecision": this.layer.chart.labelPrecision,
                "scale": 0
            });
            this.layer.chart.renderer.drawLable(ctx, settings.strokeStyle, 0, this.layer.area.innerWidth, pointCoords[0].y, label);
        }
    };

    iChart.Charting.ChartHorizontalLine.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            [
                { "x": this.layer.area.innerOffset.left, "y": this.testContext.points[0].y },
                { "x": this.layer.area.innerOffset.left + this.layer.area.innerWidth, "y": this.testContext.points[0].y }
            ]
        ];
    };
})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartLine = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Line";
        this.drawType = 'manually';
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartLine, iChart.Charting.ChartElement);

    iChart.Charting.ChartLine.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        ctx.save();
        ctx.beginPath();

        this.initDrawSettings(ctx, this.settings);

        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.stroke();
        ctx.restore();
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartRectangle = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Rectangle";
        this.drawType = 'manually';
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartRectangle, iChart.Charting.ChartElement);

    iChart.Charting.ChartRectangle.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        ctx.save();
        ctx.beginPath();

        this.initDrawSettings(ctx, this.settings);


        var width = coords[1].x - coords[0].x;
        var height = coords[1].y - coords[0].y;


        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[0].x, coords[1].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.lineTo(coords[1].x, coords[0].y);
        ctx.lineTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[0].x, coords[1].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.stroke();
        ctx.fillRect(coords[0].x, coords[0].y, width, height);

        ctx.restore();

    };

    iChart.Charting.ChartRectangle.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            [this.testContext.points[0], { "x": this.testContext.points[0].x, "y": this.testContext.points[1].y}],
            [{ "x": this.testContext.points[0].x, "y": this.testContext.points[1].y }, this.testContext.points[1]],
            [this.testContext.points[1], { "x": this.testContext.points[1].x, "y": this.testContext.points[0].y}],
            [{ "x": this.testContext.points[1].x, "y": this.testContext.points[0].y }, this.testContext.points[0]]
        ];
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartTrend = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Trend";
        this.drawType = 'manually';
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartTrend, iChart.Charting.ChartElement);

    iChart.Charting.ChartTrend.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        ctx.beginPath();
        this.initDrawSettings(ctx, this.settings);
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.stroke();

        var d = Math.sqrt(iChart.Charting.pointToPointDistanceSquared(coords[0], coords[1]));
        if (d <= 4)
        {
            return;
        }

        ctx.beginPath();
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[0].x + d, coords[0].y);
        ctx.stroke();

        var angle = Math.acos((coords[1].x - coords[0].x) / d);
        var counterclockwise = coords[0].y >= coords[1].y;
        if (this === this.layer.selected)
        {
            ctx.beginPath();
            ctx.arc(coords[0].x, coords[0].y, d / 4, 0, counterclockwise ? 2 * Math.PI - angle : angle, counterclockwise);
            ctx.stroke();
        }

        if (typeof ctx.strokeText === "function")
        {
            ctx.font = "normal 15px Tahoma";
            ctx.fillStyle   = ctx.strokeStyle;

            ctx.translate(-0.5, -0.5);
            if (counterclockwise)
            {
                ctx.textBaseline = "top";
                ctx.fillText(Math.round(180 * angle / Math.PI) + "°", coords[0].x + 18, coords[0].y + 3);
            }
            else
            {
                ctx.textBaseline = "bottom";
                ctx.fillText("-" + Math.round(180 * angle / Math.PI) + "°", coords[0].x + 18, coords[0].y - 3);
            }

            ctx.translate(0.5, 0.5);
        }
    };

    iChart.Charting.ChartTrend.prototype.setTestSegments = function ()
    {
        var d = Math.sqrt(iChart.Charting.pointToPointDistanceSquared(this.testContext.points[0], this.testContext.points[1]));
        this.testContext.segments = [
            this.testContext.points,
            [this.testContext.points[0], { "x": this.testContext.points[0].x + d, "y": this.testContext.points[0].y}]
        ];
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartTriangle = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Triangle";
        this.drawType = 'manually';
        this.maxPointCount = 3;
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartTriangle, iChart.Charting.ChartElement);

    iChart.Charting.ChartTriangle.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        ctx.beginPath();
        this.initDrawSettings(ctx, this.settings);
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.stroke();

        if (coords.length < 3)
        {
            return;
        }

        ctx.beginPath();
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.lineTo(coords[2].x, coords[2].y);
        ctx.lineTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.fill();
        ctx.stroke();
    };

    iChart.Charting.ChartTriangle.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            [this.testContext.points[0], this.testContext.points[1]],
            [this.testContext.points[1], this.testContext.points[2]],
            [this.testContext.points[2], this.testContext.points[0]]
        ];
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartVerticalLine = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "VerticalLine";
        this.drawType = 'manually';
        this.maxPointCount = 1;
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartVerticalLine, iChart.Charting.ChartElement);

    iChart.Charting.ChartVerticalLine.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 1)
        {
            return;
        }

        ctx.save();
        ctx.beginPath();
        this.initDrawSettings(ctx, this.settings);
        ctx.moveTo(coords[0].x, 0);
        ctx.lineTo(coords[0].x, getElementSize(ctx.canvas).height);
        ctx.stroke();
        ctx.restore();
    };

    iChart.Charting.ChartVerticalLine.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            [
                { "x": this.testContext.points[0].x, "y": this.layer.area.innerOffset.top },
                { "x": this.testContext.points[0].x, "y": this.layer.area.innerOffset.top + this.layer.area.innerHeight }
            ]
        ];
    };
})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartMark = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Mark";
        this.drawType = 'manually';
        this.maxPointCount = 1;
        this.hasSettings = true;
        this.hasPopupSettings = true;
        this.settings = {mark: 'smileUp'};

        this.img = {};

        this.img["up"] = new Image();
        this.img["up"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'up' + ".png";
        this.img["left"] = new Image();
        this.img["left"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'left' + ".png";
        this.img["leftUp"] = new Image();
        this.img["leftUp"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'leftUp' + ".png";
        this.img["rightUp"] = new Image();
        this.img["rightUp"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'rightUp' + ".png";
        this.img["smileUp"] = new Image();
        this.img["smileUp"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'smileUp' + ".png";
        this.img["exclamation"] = new Image();
        this.img["exclamation"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'exclamation' + ".png";
        this.img["buy"] = new Image();
        this.img["buy"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'buy' + ".png";
        this.img["down"] = new Image();
        this.img["down"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'down' + ".png";
        this.img["right"] = new Image();
        this.img["right"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'right' + ".png";
        this.img["leftDown"] = new Image();
        this.img["leftDown"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'leftDown' + ".png";
        this.img["rightDown"] = new Image();
        this.img["rightDown"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'rightDown' + ".png";
        this.img["smileDown"] = new Image();
        this.img["smileDown"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'smileDown' + ".png";
        this.img["question"] = new Image();
        this.img["question"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'question' + ".png";
        this.img["sell"] = new Image();
        this.img["sell"].src = this.layer.chart.env.lib_path + "/images/" + 'icon-' + 'sell' + ".png";



        $('#elementSettings').remove();

    };

    inheritPrototype(iChart.Charting.ChartMark, iChart.Charting.ChartElement);

    iChart.Charting.ChartMark.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 1)
        {
            return;
        }

        if(this.settings != undefined) {
            var settings = this.settings;

            var img = this.img[settings.mark];
                ctx.save();
            ctx.translate(- 0.5, - 0.5);
            ctx.drawImage(img,coords[0].x-img.width/2, coords[0].y- img.height/2, img.width, img.height);
            ctx.restore();
            $('.Mark-select').hide();
        }
    };

    iChart.Charting.ChartMark.prototype.drawPopupSettings = function (ctx, coord)
    {
        $('#elementSettings').remove();

        $('<div id="elementSettings" class="mark chartInstrument">' +
            '<div class="uk-flex uk-flex-left">' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"up"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-up"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"left"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-left"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"leftUp"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-upLeft"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"rightUp"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-upRight"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"smileUp"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-smileUp"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"exclamation"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-exclamation"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"buy"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-buy"></i></div></div>' +
            '<div class="uk-flex uk-flex-left">' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"down"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-down"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"right"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-right"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"leftDown"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-downLeft"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"rightDown"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-downRight"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"smileDown"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-smileDown"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"question"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-question"></i></div>' +
            '<div class="chartTool uk-flex uk-flex-center uk-flex-middle" data-settings=\'{"mark":"sell"}\' name="SelectInstrument" data-instrument="Mark"><i class="sprite sprite-icon-sell"></i></div>' +
            '</div>' +
            '</div>').appendTo($(this.layer.chart.container));
        var x = coord.x - $('#elementSettings.mark').width()+8;
        $('#elementSettings').css({ "left": this.layer.area.innerOffset.left+x, "top": this.layer.area.innerOffset.top+coord.y + 15 });

        var self = this;
        var setSettings_onClick = function (settings)
        {
            self.setSettings(settings);
            self.layer.render();
        };

        $('#elementSettings .chartTool').off("mousedown").on('mousedown', function(event){
            event.stopPropagation();
            setSettings_onClick($(this).data('settings'));
            $('#elementSettings').remove();
        });

        return false;
    };

    iChart.Charting.ChartMark.prototype.drawPoints = function (ctx, pointCoords) {};

    iChart.Charting.ChartMark.prototype.setTestSegments = function ()
    {

        this.testContext.segments = [
            [this.testContext.points[0], { "x": this.testContext.points[0].x, "y": this.testContext.points[0].y}]
        ];
    };

})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartLabel = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Label";
        this.drawType = 'manually';
        this.maxPointCount = 1;

        this.hasSettings = true;
        this.hasPopupSettings = true;
        this.settings = 0;

        this.settings = {text: '', size: 12};
        this.sizes = [12,15,19];

        $('#elementSettings').remove();

    };

    inheritPrototype(iChart.Charting.ChartLabel, iChart.Charting.ChartElement);

    iChart.Charting.ChartLabel.prototype.drawString = function (ctx, text, posX, posY, fontSize, textColor, rotation, font)
    {
        var lines = text.split("\n");
        if (!rotation) rotation = 0;
        if (!font) font = 'Arial,Helvetica,sans-serif';
        if (!fontSize) fontSize = this.sizes[0];
        if (!textColor) textColor = '#000000';
        ctx.save();
        ctx.font = fontSize + "px " + font;
        ctx.fillStyle = textColor;
        ctx.translate(posX, posY);
        ctx.rotate(rotation * Math.PI / 180);
        for (var i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i],0, i*fontSize);
        }
        ctx.restore();
    }

    iChart.Charting.ChartLabel.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 1)
        {
            return;
        }
        var data = this.settings;
        this.drawString(ctx, data.text, coords[0].x, coords[0].y, data.size);
    };

    iChart.Charting.ChartLabel.prototype.setSettings = function (i) {
        this.settings = i;

        if(this.layer.context) {
            this.layer.render();
            this.layer.syncHash();
        }
    };


    iChart.Charting.ChartLabel.prototype.drawPopupSettings = function (ctx, coord)
    {
        var data = this.settings;

        var sltd0 = (data.size == this.sizes[0])? 'selected':'';
        var sltd1 = (data.size == this.sizes[1])? 'selected':'';
        var sltd2 = (data.size == this.sizes[2])? 'selected':'';

        $('#elementSettings').remove();
        /*        $('<div id="elementSettings" class="label">'+
         '<textarea rows="3" style="width: 99%;">' + data.text + '</textarea><br/>' +
         'Размер шрифта:<br/>' +
         '<select id="elementSize"><option '+sltd0+' value="'+this.sizes[0]+'">Маленький</option><option '+sltd1+' value="'+this.sizes[1]+'">Средний</option><option '+sltd2+' value="'+this.sizes[2]+'">Большой</option></select>' +
         '<img class="save" style="margin-left: 15px; margin-top: 3px;" src="/i/admin/btn/save.gif"/>' +
         '<div class="close">[X]</div>' +
         '</div>').prependTo('#chartContainerWrapper');
         $('#elementSettings.label').css({ "margin-left": coord.x + 2, "margin-top": coord.y + 2 });
         */

        $('<div id="elementSettings" class="label">'+
            '<textarea rows="3" style="width: 99%;">' + data.text + '</textarea><br/>' +
            'Размер шрифта:<br/>' +
            '<select id="elementSize"><option '+sltd0+' value="'+this.sizes[0]+'">Маленький</option><option '+sltd1+' value="'+this.sizes[1]+'">Средний</option><option '+sltd2+' value="'+this.sizes[2]+'">Большой</option></select>' +
            '<img class="save" style="margin-left: 15px; margin-top: 3px;" src="/i/admin/btn/save.gif"/>' +
            '<div class="close">[X]</div>' +
            '</div>').prependTo($(this.layer.chart.container).parent());
        $('#elementSettings.label').css({ "margin-left": coord.x + 2, "margin-top": coord.y + 2 });

        var self = this;
        var setSettings_onClick = function (i) { self.setSettings(i); }
        var remove_Element = function () { self.remove(); }
        var get_Text = function () { var data = self.settings; return data.text; }

        $('#elementSettings .save').unbind("mousedown").mousedown(function(event){
            event.stopPropagation();

            var params = {text: $('#elementSettings.label textarea').val(), size: $('#elementSettings.label #elementSize').val()};

            if(!$('#elementSettings.label textarea').val().length) {
                remove_Element();
                $('#elementSettings.label').remove();
            } else {
                setSettings_onClick(params);
                $('#elementSettings.label').remove();
            }
        });

        $('#elementSettings.label .close').unbind("mousedown").mousedown(function(event){
            event.stopPropagation();

            if(!get_Text().length) {
                remove_Element();
            }
            $('#elementSettings.label').remove();
        });

        return false;

    };

    iChart.Charting.ChartLabel.prototype.setTestSegments = function ()
    {
        var ctx = this.layer.context;
        var data = this.settings;

        var font= 'Arial,Helvetica,sans-serif';
        var fontSize = data.size;
        var textColor = '#000000';

        ctx.font = fontSize + "px " + font;
        ctx.fillStyle = textColor;

        var width = 0;
        var height = 0;

        var lines = data.text.split("\n");

        for (var i = 0; i < lines.length; i++) {

            if(ctx.measureText(lines[i]).width > width) {
                width = ctx.measureText(lines[i]).width;
                height += fontSize;
            }
        }

        this.testContext.segments = [
            [this.testContext.points[0], { "x": this.testContext.points[0].x+width, "y": this.testContext.points[0].y}],
            [{ "x": this.testContext.points[0].x+width, "y": this.testContext.points[0].y}, { "x": this.testContext.points[0].x+width, "y": this.testContext.points[0].y+height}],
            [{ "x": this.testContext.points[0].x+width, "y": this.testContext.points[0].y+height}, { "x": this.testContext.points[0].x, "y": this.testContext.points[0].y+height}],
            [{ "x": this.testContext.points[0].x, "y": this.testContext.points[0].y+height}, this.testContext.points[0]]
        ];
    };

})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartArrow = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Arrow";
        this.drawType = 'manually';
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartArrow, iChart.Charting.ChartElement);

    iChart.Charting.ChartArrow.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        ctx.save();

        this.initDrawSettings(ctx, this.settings);

        var fromx =  coords[0].x;
        var fromy =  coords[0].y;
        var toy =  coords[1].y;
        var tox =  coords[1].x;

        var headlen = (5+ctx.lineWidth)*2;
        var width = ctx.lineWidth;
        //Угол наклона стрелки
        var angle = Math.atan2(toy-fromy,tox-fromx);

        //Нарисуем конец стрелки
        ctx.beginPath();
        ctx.moveTo(tox, toy);
        ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/6),toy-headlen*Math.sin(angle-Math.PI/6));
        ctx.lineTo(tox-headlen*Math.cos(angle+Math.PI/6),toy-headlen*Math.sin(angle+Math.PI/6));
        ctx.lineTo(tox, toy);
        ctx.lineTo(tox-headlen*Math.cos(angle-Math.PI/6),toy-headlen*Math.sin(angle-Math.PI/6));
        ctx.fillStyle = ctx.strokeStyle;
        ctx.fill();
        ctx.stroke();
        //Нарисуем тело стрелки
        ctx.beginPath();
        ctx.moveTo(fromx, fromy);
        ctx.lineTo((tox-headlen*Math.cos(angle-Math.PI/6) + tox-headlen*Math.cos(angle+Math.PI/6)) / 2,
                   (toy-headlen*Math.sin(angle-Math.PI/6) + toy-headlen*Math.sin(angle+Math.PI/6)) / 2);

        ctx.stroke();

        ctx.restore();
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartPolygon = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Polygon";
        this.drawType = 'manually';
        this.maxPointCount = 4;
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartPolygon, iChart.Charting.ChartElement);

    iChart.Charting.ChartPolygon.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        ctx.beginPath();
        this.initDrawSettings(ctx, this.settings);
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.stroke();

        if (coords.length < 3)
        {
            return;
        }

        ctx.beginPath();
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.lineTo(coords[2].x, coords[2].y);

        if (coords.length < 4)
        {
            ctx.fill();
            return;
        }

        var settings = this.settings;

        ctx.beginPath();
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.stroke();

        ctx.beginPath();
        ctx.strokeStyle = settings.strokeStyle2;
        ctx.lineTo(coords[2].x, coords[2].y);
        ctx.lineTo(coords[3].x, coords[3].y);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(coords[0].x, coords[0].y);
        ctx.lineTo(coords[1].x, coords[1].y);
        ctx.lineTo(coords[2].x, coords[2].y);
        ctx.lineTo(coords[3].x, coords[3].y);
        ctx.fill();
    };

    iChart.Charting.ChartPolygon.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            [this.testContext.points[0], this.testContext.points[1]],
            [this.testContext.points[2], this.testContext.points[3]]
        ];
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

function getTradeLabelText(trade, price) {
    var postfix = parseInt(trade.volume) + '@' + price;

    if(trade.type_id === 1) return 'B' + ': ' + postfix;

    if(trade.type_id === 2) return 'S' + ': ' + postfix;

    if(trade.type_id === 3) return 'TP' + ': ' + postfix;

    if(trade.type_id === 4) return 'SL' + ': ' + postfix;
}

(function ()
{
    "use strict";

    iChart.Charting.ChartTrade = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Trade";
        this.drawType = 'manually';
        this.maxPointCount = 1;
        this.hasSettings = true;
        this.controlEnable = false;
        this.id = 0;
    };

    inheritPrototype(iChart.Charting.ChartTrade, iChart.Charting.ChartElement);

    iChart.Charting.ChartTrade.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 1)
        {
            return;
        }

        ctx.save();
        ctx.beginPath();

        ctx.arc(coords[0].x, coords[0].y, 5, 0, 2 * Math.PI, true);
        if(this.settings.type_id == 1 || this.settings.type_id == 3) {
            ctx.fillStyle = '#00ff00';
        } else {
            ctx.fillStyle = '#ff0000';
        }
        if(ctx.inHover) {
            ctx.fillStyle = '#0000ff';
            ctx.stokeStyle = '#000';
        }
        ctx.fill();
        ctx.closePath();

        if(this.settings.qb !== '') {
            ctx.beginPath();
            ctx.strokeStyle = ctx.fillStyle;
            ctx.moveTo(coords[0].x+5, coords[0].y);
            ctx.lineTo(getElementSize(ctx.canvas).width, coords[0].y);
            ctx.closePath();
            ctx.stroke();
        }

        if(this.settings.mode == 2) {
            this.drawTradeLable(ctx, coords[0].x, coords[0].y, this.settings);
        }

        ctx.globalAlpha = 0.3;
        ctx.lineWidth = 1;
        ctx.stokeStyle = '#eee';
        ctx.restore();

    };

    iChart.Charting.ChartTrade.prototype.drawTradeLable = function (context, x, y, trade)
    {
        var price = parseFloat(trade.price);
        if(price < 100) {
            price = iChart.formatNumber( price, { decimalPlaces: null, decimalPrecision: 6, "scale": 0 });
        } else {
            price = iChart.formatNumber( price, { decimalPlaces: 2, decimalPrecision: null, "scale": 0 });
        }

        var text = getTradeLabelText(trade, price);
        context.save();

        context.font = 'normal 11px Arial,Helvetica,sans-serif';
        context.textAlign = "left";
        context.textBaseline = "middle";

        context.busyPoints = (!context.busyPoints)?{}:context.busyPoints;

        //context.fillStyle = (trade.type_id==1)?'rgba(5, 255, 55, 0.7)':'rgba(255, 5, 5, 0.7)';
        /*context.fillRect(x+64, 10, context.measureText(text).width+10, 15);*/

        if (context.setLineDash) {
            context.setLineDash([5])
        }

        var newX =x+20,
            newY = 70,
            newWidth = context.measureText(text).width+10,
            newX2 = newX + newWidth,
            freeSpace = 0;

        for(newY = 70; newY <= this.layer.area.innerHeight; newY+=30) {
            freeSpace = 1;
            var checkArr = $.map(context.busyPoints, function(v,i){return (v.y == newY ? v : null)});
            for(var i = 0; i<checkArr.length && freeSpace; i++) {
                if ((x <= checkArr[i].maxX && x >= checkArr[i].minX) || (newX2 <= checkArr[i].maxX && newX2 >= checkArr[i].minX) || (x <= checkArr[i].minX && newX2 >= checkArr[i].maxX)) {
                    freeSpace = 0;
                }
            }
            if(freeSpace) {
                break;
            }
        }

        context.beginPath();
        context.strokeStyle = '#C5C5C5';
        context.fillStyle = 'rgba(238,238,238,0.5)';
        context.rect(newX, newY-10, newWidth, 20);
        context.fill();

        context.moveTo(x, y+(newY>y ? 5 : -5 ));
        context.lineTo(x, newY);
        context.lineTo(newX, newY);
        context.moveTo(x, y+(newY>y ? 5 : -5 ));
        context.stroke();

        context.fillStyle = '#000';
        context.fillText(text, x+24, newY);

        context.busyPoints[trade.id] = {minX:x, maxX:newX + newWidth, y: newY};
        context.restore();

    }


    iChart.Charting.ChartTrade.prototype.onHover = function (ctx) {
        var coords = this.getCoordinates(ctx, this.points);
        var top = coords[0].y;
        var left = coords[0].x;

        this.drawTooltip(this.settings, top, left);
    }

   /* iChart.Charting.ChartTrade.prototype.drawExtended = function (ctx)
    {
        var pointCoords = this.getCoordinates(ctx, this.points);

        if (pointCoords.length < 1)
        {
            return;
        }
        var settings = this.settings;
        var label = this.layer.chart.renderer.formatNumber(this.layer.area.getYValue(pointCoords[0].y), { "decimalPrecision": this.layer.chart.labelPrecision, "scale": 0 });

        if(this.settings.type_id == 1) {
            var color = "rgba(5, 255, 55, 0.3)"
        } else {
            color = "rgba(255, 5, 5, 0.3)"
        }

        var maxIndex = this.layer.area.viewport.x.max,
            minIndex = this.layer.area.viewport.x.min,
            xIndex = this.layer.area.getXIndex(pointCoords[0].x);

        if (xIndex <= maxIndex && xIndex > minIndex ) {

            this.layer.chart.renderer.drawLable(ctx, color, "#000", getElementSize(ctx.canvas).width, pointCoords[0].y, label);
        }

    }*/

    iChart.Charting.ChartTrade.prototype.onOut = function (ctx) {
        $('[chart-element-tooltip]').hide();
    }

    iChart.Charting.ChartTrade.prototype.drawTooltip = function (data, top, left) {

        if(this.layer.chart.env.wrapper.find('[chart-element-tooltip]').length == 0) {
            $(this.layer.chart.container).append('' +
            '<div chart-element-tooltip class="qtip qtip-default qtip-tipsy qtip-pos-rc" tracking="false" role="alert" aria-live="polite" aria-atomic="false" style="z-index: 15002;">' +
                '<div class="qtip-tip" style="background-color: transparent ! important; border: 0px none ! important; height: 6px; width: 6px; line-height: 6px; top: 50%; margin-top: -3px; right: -6px;"><canvas style="background-color: transparent ! important; border: 0px none ! important;" height="6" width="6"></canvas></div>' +
                '<div class="qtip-content" id="qtip-34-content" aria-atomic="true">' +
                '</div>' +
                '</div>' +
            '</div>');
        }

        var dataView = $('' +
            '<div>'
            + (
                data.type_id === 1
                    ? _t('4916', 'Покупка')
                    : _t('4917', 'Продажа')
            )
            + '<br/>'
            + _t('1510','Дата') + ': '
            + (
                this.layer.chart._dataSettings.timeframe >= 1440
                    ? data.date_time.substr(0, 10)
                    : data.date_time
            )
            + '<br/>'
            + _t('3728','Сделок') + ': '
            + data.count
            + '<br/>'
            + _t('1444','Количество') + ': '
            + iChart.formatNumber(
                    parseFloat(data.volume),
                    {
                        decimalPlaces: 0,
                        decimalPrecision: null,
                        'scale': 0
                    }
                )
            + '<br/>'
            + _t('1446','Сумма') + ': '
            + (
                data.summ < 100
                    ? iChart.formatNumber(
                            parseFloat(data.summ),
                            {
                                decimalPlaces: null,
                                decimalPrecision: 6,
                                'scale': 0
                            }
                        )
                    : iChart.formatNumber(
                            parseFloat(data.summ),
                            {
                                decimalPlaces: 2,
                                decimalPrecision: null,
                                'scale': 0
                            }
                        )
            )
            + '<br/>'
            + _t('1445','Цена') + ': '
            + (
                data.price < 100
                    ? iChart.formatNumber(
                        parseFloat(data.price),
                        {
                            decimalPlaces: null,
                            decimalPrecision: 6,
                            'scale': 0
                        }
                    )
                    : iChart.formatNumber(
                        parseFloat(data.price),
                        {
                            decimalPlaces: 2,
                            decimalPrecision: null,
                            'scale': 0
                        }
                    )
            )
            + '<br/>'
            + (
                parseFloat(data.profit) === 0
                    ? ''
                    : (
                        parseFloat(data.profit) > 0
                            ? _t('1448','Прибыль') + ': '
                            : _t('67057','Убыток') + ': '
                    )
            )
            + (
                parseFloat(data.profit) !== 0
                    ? (
                        iChart.formatNumber(
                            parseFloat(data.profit),
                            {
                                decimalPlaces: 2,
                                decimalPrecision: 2,
                                'scale': 0
                            }
                        )
                        + '<br/>'
                    )
                    : ''
            )
            + '</div>'
        );

        $('[chart-element-tooltip] .qtip-content').html(dataView);
        $('[chart-element-tooltip]').css({top: Math.max(top - $('[chart-element-tooltip]').height() - 12 , 0) +'px', left: left + 12 + 'px'}).show();

    }


    iChart.Charting.ChartTrade.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            [this.testContext.points[0], { "x": this.testContext.points[0].x, "y": this.testContext.points[0].y}]
        ];
    };

})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartBubble = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Bubble";
        this.drawType = 'manually';
        this.maxPointCount = 3;
        this.hasSettings = true;
        this.hasPopupSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings, {text: ''});
    };

    inheritPrototype(iChart.Charting.ChartBubble, iChart.Charting.ChartElement);

    iChart.Charting.ChartBubble.prototype.onInsert = function () {
        this.selected = true;

        var coords = this.getCoordinates(null, this.points);

        if (coords.length < 2)
        {
            return;
        }

        this.settings.width = coords[1].x - coords[0].x;
        this.settings.height = coords[1].y - coords[0].y;
    };

    iChart.Charting.ChartBubble.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        if(typeof this.markers != "undefined") {
            var size = {
                width: coords[1].x - coords[0].x,
                height: coords[1].y - coords[0].y
            };

            this.settings.width = coords[1].x - coords[0].x;
            this.settings.height = coords[1].y - coords[0].y;
        } else if(this.settings.width && this.settings.height) {
                this.points[1].x = this.layer.area.getXValue(coords[0].x + this.settings.width) * 1000;
                this.points[1].y = this.layer.area.getYValue(coords[0].y + this.settings.height);
                coords[1].x = this.layer.area.getXPositionByValue(this.points[1].x / 1000);
                coords[1].y = this.layer.area.getYPosition(this.points[1].y);
        }

        this.initDrawSettings(ctx, this.settings);

        this.drawBubble(ctx, coords);

    };

    iChart.Charting.ChartBubble.prototype.drawBubble = function (ctx, coords)
    {

        var radius = 30,
            radiusMax = 25,
            width = Math.abs(coords[0].x - coords[1].x),
            heigh = Math.abs(coords[0].y - coords[1].y),
            xD = coords[0].x < coords[1].x ? true : false,
            yD = coords[0].y < coords[1].y ? true : false,
            handle = [{},{},{}],
            handleBase,
            handleBaseMax = 80,
            xSide = false,
            ySide = false;

        radius = Math.min(parseInt(width/3),parseInt(heigh/3), radiusMax);

        ctx.save();
        ctx.lineJoin='miter';
        ctx.beginPath();
//        ctx.strokeStyle="black";
//        ctx.lineWidth="1";

        //Есть точка указателя и пространство на боковой стороне с учетом вычета на повороты
        if(typeof coords[2] != 'undefined' && Math.abs(coords[0].x - coords[1].x) > 2*radius && Math.abs(coords[0].y - coords[1].y) > 2*radius) {
            //указатель находится не внутри бабла
            if(!(coords[2].x < Math.max(coords[0].x, coords[1].x) && coords[2].x > Math.min(coords[0].x, coords[1].x)
                && coords[2].y < Math.max(coords[0].y, coords[1].y) && coords[2].y > Math.min(coords[0].y, coords[1].y)))
            {
                //ближняя сторона по x
                if(Math.abs(coords[0].x - coords[2].x) < Math.abs(coords[1].x - coords[2].x)) {
                    handle[0].x = coords[0].x;
                } else {
                    handle[0].x = coords[1].x;
                }
                //ближняя сторона по y
                if(Math.abs(coords[0].y - coords[2].y) < Math.abs(coords[1].y - coords[2].y)) {
                    handle[0].y = coords[0].y;
                } else {
                    handle[0].y = coords[1].y;
                }
                //отределение стороны примыкания указателя
                if(coords[2].x > Math.min(coords[0].x, coords[1].x) && coords[2].x < Math.max(coords[0].x, coords[1].x)) {
                    xSide = true;
                } else if(coords[2].y > Math.min(coords[0].y, coords[1].y) && coords[2].y < Math.max(coords[0].y, coords[1].y)) {
                    ySide = true;
                } else {
                    if(Math.abs((handle[0].x - coords[2].x) * (xD? 1:-1)) >  Math.abs((handle[0].y - coords[2].y) * (yD? 1:-1))) {
                        ySide = true;
                    } else {
                        xSide = true;
                    }
                }

                if(xSide) {
                    //определение площабки косания указателя и бабла
                    var angelBase = Math.abs(handle[0].y - coords[2].y) * Math.sin(Math.PI/12);
                    handleBaseMax = parseInt(width / 6);
                    var enableBase = parseInt(width - 2*radius);
                    if(angelBase < handleBaseMax && angelBase < enableBase) {
                        handleBase = angelBase;
                    } else {
                        handleBase = Math.min(handleBaseMax, enableBase);
                    }

                    //определение координат точек касания
                    var x = (xD? Math.min(coords[1].x-radius, Math.max(coords[0].x+radius, coords[2].x)):Math.min(coords[0].x-radius, Math.max(coords[1].x+radius, coords[2].x)));
                    handle[1].x = x - handleBase/2;
                    handle[2].x = x + handleBase/2;
                    handle[1].y = handle[2].y = handle[0].y;

                    if(xD && (Math.min(handle[1].x, handle[2].x) < coords[0].x+radius) || !xD && (Math.min(handle[1].x, handle[2].x) < coords[1].x+radius )) {
                        handle[1].x = handle[0].x + (xD? radius:radius);
                        handle[2].x = handle[1].x + (xD? handleBase:handleBase);
                    } else if(xD && (Math.max(handle[1].x, handle[2].x) > coords[1].x-radius) || !xD && (Math.max(handle[1].x, handle[2].x) > coords[0].x-radius)) {
                        handle[1].x = handle[0].x - (xD? radius:radius);
                        handle[2].x = handle[1].x - (xD? handleBase:handleBase);
                    }
                } else if(ySide) {
                    var angelBase = Math.abs(handle[0].x - coords[2].x) * Math.sin(Math.PI/12);
                    handleBaseMax = parseInt(heigh / 6);
                    var enableBase = parseInt(heigh - 2*radius);
                    if(angelBase < handleBaseMax && angelBase < enableBase) {
                        handleBase = angelBase;
                    } else {
                        handleBase = Math.min(handleBaseMax, enableBase);
                    }

                    var y = (yD? Math.min(coords[1].y-radius, Math.max(coords[0].y+radius, coords[2].y)):Math.min(coords[0].y-radius, Math.max(coords[1].y+radius, coords[2].y)));
                    handle[1].y = y - handleBase/2;
                    handle[2].y = y + handleBase/2;
                    handle[1].x = handle[2].x = handle[0].x;

                    if(yD && (Math.min(handle[1].y, handle[2].y) < coords[0].y+radius) || !yD && (Math.min(handle[1].y, handle[2].y) < coords[1].y+radius )) {
                        handle[1].y = handle[0].y + (yD? radius:radius);
                        handle[2].y = handle[1].y + (yD? handleBase:handleBase);
                    } else if(yD && (Math.max(handle[1].y, handle[2].y) > coords[1].y-radius) || !yD && (Math.max(handle[1].y, handle[2].y) > coords[0].y-radius)) {
                        handle[1].y = handle[0].y - (yD? radius:radius);
                        handle[2].y = handle[1].y - (yD? handleBase:handleBase);
                    }
                }
            }
        }

        ctx.moveTo(coords[0].x + (xD ? radius:-radius), coords[0].y);
        if(xSide && handle[0].y == coords[0].y) {
            ctx.lineTo((xD ? Math.min(handle[1].x, handle[2].x):Math.max(handle[1].x, handle[2].x)), handle[1].y);
            ctx.lineTo(coords[2].x, coords[2].y);
            ctx.lineTo((xD ? Math.max(handle[1].x, handle[2].x):Math.min(handle[1].x, handle[2].x)), handle[2].y);
            ctx.lineTo(coords[1].x - (xD ? radius:-radius), coords[0].y);
        } else {
            ctx.lineTo(coords[1].x - (xD ? radius:-radius), coords[0].y);
        }
        ctx.quadraticCurveTo(coords[1].x, coords[0].y, coords[1].x, coords[0].y + (yD ? radius:-radius));
        if(ySide && handle[0].x == coords[1].x) {
            ctx.lineTo(handle[1].x, (yD ? Math.min(handle[1].y, handle[2].y):Math.max(handle[1].y, handle[2].y)));
            ctx.lineTo(coords[2].x, coords[2].y);
            ctx.lineTo(handle[1].x, (yD ? Math.max(handle[1].y, handle[2].y):Math.min(handle[1].y, handle[2].y)));
            ctx.lineTo(coords[1].x, coords[1].y - (yD ? radius:-radius));
        } else {
            ctx.lineTo(coords[1].x, coords[1].y - (yD ? radius:-radius));
        }
        ctx.quadraticCurveTo(coords[1].x, coords[1].y, coords[1].x - (xD ? radius:-radius), coords[1].y);
        if(xSide && handle[0].y == coords[1].y) {
            ctx.lineTo((xD ? Math.max(handle[1].x, handle[2].x):Math.min(handle[1].x, handle[2].x)), handle[2].y);
            ctx.lineTo(coords[2].x, coords[2].y);
            ctx.lineTo((xD ? Math.min(handle[1].x, handle[2].x):Math.max(handle[1].x, handle[2].x)), handle[1].y);
            ctx.lineTo(coords[0].x + (xD ? radius:-radius), coords[1].y);
        } else {
            ctx.lineTo(coords[0].x + (xD ? radius:-radius), coords[1].y);
        }
        ctx.quadraticCurveTo(coords[0].x, coords[1].y, coords[0].x, coords[1].y - (yD ? radius:-radius));
        if(ySide && handle[0].x == coords[0].x) {
            ctx.lineTo(handle[1].x, (yD ? Math.max(handle[1].y, handle[2].y):Math.min(handle[1].y, handle[2].y)));
            ctx.lineTo(coords[2].x, coords[2].y);
            ctx.lineTo(handle[1].x, (yD ? Math.min(handle[1].y, handle[2].y):Math.max(handle[1].y, handle[2].y)));
            ctx.lineTo(coords[0].x, coords[0].y + (yD ? radius:-radius));
        } else {
            ctx.lineTo(coords[0].x, coords[0].y + (yD ? radius:-radius));
        }
        ctx.quadraticCurveTo(coords[0].x, coords[0].y, coords[0].x + (xD ? radius:-radius), coords[0].y);


//ctx.fillStyle="rgba(255,0,0,.4)";

        ctx.closePath();
        ctx.fill();
        ctx.stroke();


//        this.drawCheckPoint(ctx, coords[0].x + (xD ? radius:-radius), coords[0].y, '1');
//        this.drawCheckPoint(ctx, coords[0].x, coords[1].y - (yD ? radius:-radius), '2');
//        this.drawCheckPoint(ctx, coords[0].x, coords[0].y + (yD ? radius:-radius), '3');
//        this.drawCheckPoint(ctx, coords[0].x + (xD ? radius:-radius), coords[1].y, '4');
//        this.drawCheckPoint(ctx, coords[1].x - (xD ? radius:-radius), coords[1].y, '5');
//        this.drawCheckPoint(ctx, coords[1].x, coords[1].y - (yD ? radius:-radius), '6');
//        this.drawCheckPoint(ctx, coords[1].x - (xD ? radius:-radius), coords[0].y, '7');
//        this.drawCheckPoint(ctx, coords[1].x, coords[0].y + (yD ? radius:-radius), '8');

        this.drawText(ctx, coords, radius, '');

        ctx.restore();


    }

    iChart.Charting.ChartBubble.prototype.drawText = function (ctx, coords, radius, text) {

        var
            padding = 5,
            width = Math.abs(coords[0].x - coords[1].x) - parseInt(radius*2/3) - padding*2,
            height = Math.abs(coords[0].y - coords[1].y) - parseInt(radius*2/3) - padding*2,
            x = Math.min(coords[0].x, coords[1].x) + parseInt(radius/3) + padding,
            y = Math.min(coords[0].y, coords[1].y) + parseInt(radius/3) + padding;

        var settings = this.settings;

//console.log(this);

        if(!this.selected) {

            text = settings.text;

            ctx.save();

            ctx.beginPath();

            ctx.fillStyle = this.settings.fontColor;
            ctx.font = 'normal ' + this.settings.fontSize + 'px ' + this.settings.fontFamaly;
            ctx.textAlign = "left";
            ctx.textBaseline="top";

//console.log(x, y, width, height);
            ctx.rect(x, y, width, height);
            //ctx.stroke();
            ctx.clip();
            ctx.translate(x, y);

            //ctx.fillText(text, 0, 0);
//console.log(text);
            text = text.replace(/\n/g, ' [%br%] ');
//console.log(text);
            var words = text.split(/\s/);
            var countWords = words.length;
//console.log(words);

            var line = '';
            var textHeight = 0+Math.round(parseInt(this.settings.fontSize)/10);
            var lineHeight = parseInt(this.settings.fontSize) + Math.round(parseInt(this.settings.fontSize)/5);
            //var lineHeight = 16;

            for (var n = 0; n < countWords; n++) {
                var testLine = line + words[n] + " ";
                var testWidth = ctx.measureText(testLine).width;
                if (words[n] == "[%br%]") {
                    ctx.fillText(line, 0, textHeight);
                    line = '';
                    textHeight += lineHeight;
                } else if (testWidth > width) {
                    ctx.fillText(line, 0, textHeight);
                    line = words[n] + " ";
                    textHeight += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 0, textHeight);
            ctx.closePath();
            ctx.restore();

        } else {
            var top = y;
            var left = x + this.layer.area.innerOffset.left;

            if($('#chart-bubble-text').is(':visible')) {
                this.settings.text = $('#chart-bubble-text').val();
            } else {
                if($('#chart-element-bubble').length == 0) {
                    $(this.layer.chart.container).append('' +
                        '<div id="chart-element-bubble" style="z-index: 15002; position: absolute; ">' +
                        '<textarea id="chart-bubble-text"></textarea>' +
                        '</div>');
                }
                $('#chart-bubble-text').val('').focus().val(this.settings.text);
            }
            $('#chart-bubble-text').css({
                font: 'normal '+this.settings.fontSize+'px/'+ (parseInt(this.settings.fontSize) + Math.round(parseInt(this.settings.fontSize)/5)) +'px ' + this.settings.fontFamaly,
                background: "rgba(230,230,230,.0)",
                color: this.settings.fontColor,
                overflow: "hidden",
                border: "0px solid red",
                width: width +'px',
                height: height + 'px'
            });

            $('#chart-element-bubble').css({top: top +'px', left: left -2 + 'px'}).show();
            $('#chart-bubble-text').width(width-2).height(height-2);

            $('#chart-element-bubble').off('click mousedown drag dragstart').on('click mousedown drag dragstart', function(e) {
                e.stopPropagation();
            });
        }
    };

    iChart.Charting.ChartBubble.prototype.drawPopupSettings = function (ctx, coord) {

        var data = {
            options: {
                sizes: [
                    {name: 8, value: 8},
                    {name: 9, value: 9},
                    {name: 10, value: 10},
                    {name: 11, value: 11},
                    {name: 12, value: 12},
                    {name: 14, value: 14},
                    {name: 16, value: 16},
                    {name: 20, value: 20},
                    {name: 24, value: 24},
                    {name: 28, value: 28},
                    {name: 32, value: 32},
                    {name: 40, value: 40}
                ],
                fonts: [
                    {name: 'Verdana', value: 'Verdana,Tahoma,Geneva,Arial,Sans-serif'},
                    {name: 'Courier New', value: 'Courier New,Monospace'},
                    {name: 'Times New Roman', value: 'TimesNewRoman,Times,Baskerville,Georgia,serif'},
                    {name: 'Arial', value: 'Arial,Helvetica,sans-serif'}
                ]
            },
            values: {
                fontSize: this.settings.fontSize,
                fontColor: this.settings.fontColor,
                fontFamaly: this.settings.fontFamaly,
                text: this.settings.text
            }
        };

        var $textPopupSettingsHtml = $($.render.iChart_textPopupSettingsTmpl(data));

        var _this = this;

        var onMinicolorsChange = function(value, opacity){
            var color = $(this).val(),
                colorRGBA = color,
                option = $(this).attr('data-option');

            if(!color.match(/^rgb.*/)) {
                colorRGBA = iChart.hexToRGB(color, opacity)
            }

            $textPopupSettingsHtml.find('.js-colorSelector[data-option="' + option + '"]').css('background-color', colorRGBA);
            $textPopupSettingsHtml.find('input[data-option="' + option + '"]').val(colorRGBA);

            $(this).minicolors('value', colorRGBA);
        };

        var onPaletteChange = function(){
            var color = this.value;
            var option = this.element.attr('data-option');
            var colorRGBA = color;

            if(!color.match(/^rgb.*/)) {
                colorRGBA = iChart.hexToRGB(color, 1);
            }

            $textPopupSettingsHtml.find('.js-colorSelector[data-option="' + option + '"]').css('background-color', colorRGBA);
            $textPopupSettingsHtml.find('input[data-option="' + option + '"]').val(colorRGBA);
            this.element.parent().find('.js-colorPicker').minicolors('value', colorRGBA);
        };

        $textPopupSettingsHtml.find('.js-colorSelector').each(function(){

            var $this = $(this),
                menu = $this.find('.menuHolder').html();

            $this.qtip({
                style: {
                    classes: 'qtip-light'
                },
                position: {
                    at: 'center right',
                    my: 'left center',
                    effect: false,
                    viewport: $('html'),
                    adjust: {
                        method: 'shift none'
                    }
                },
                content: {
                    text: menu
                },
                hide: {
                    fixed: true,
                    delay: 300
                },
                show: {
                    solo: true
                },
                events: {
                    show: function(event, api) {
                        $(event.currentTarget).find('.js-colorPicker').each(function(){
                            _this.layer.chart.env.ui.addMinicolors(this, event.currentTarget, onMinicolorsChange, onPaletteChange);
                        });
                    }
                }
            });
        });

        $textPopupSettingsHtml.on('click', '.js-textPopupSettings', {popupWindow:$textPopupSettingsHtml, element: _this}, function(e){
            if($(this).data('value') == "ok") {
                e.data.element.settings.fontSize = e.data.popupWindow.find("[name='fontSize']").val();
                e.data.element.settings.fontFamaly = e.data.popupWindow.find("[name='fontFamaly']").val();
                e.data.element.settings.text = e.data.popupWindow.find("[name='text']").val();
                $('#chart-bubble-text').val(e.data.element.settings.text);
                e.data.element.settings.fontColor = e.data.popupWindow.find("input[data-option='fontColor']").val();
                e.data.element.layer.render();
            }

            if($.modal.impl.d.data) {
                $.modal.impl.close();
            }
        });

        this.layer.chart.env.wrapper.append($textPopupSettingsHtml);
        $textPopupSettingsHtml.modal(
            {modal: false, minWidth: 500, zIndex: 1500, position: [coord.y + 'px', coord.x + 'px'], title: _t('17599', 'Настройки текста')})
        ;
    };

    iChart.Charting.ChartBubble.prototype.onSelect = function (ctx) {
        iChart.Charting.ChartElement.prototype.onSelect.call(this, ctx);
        if($('#chart-element-bubble').length == 0) {
            $(this.layer.chart.container).append('' +
                '<div id="chart-element-bubble" style="z-index: 15002; position: absolute; ">' +
                '<textarea id="chart-bubble-text"></textarea>' +
                '</div>');
            $('#chart-bubble-text').css({
                font: 'normal '+this.settings.fontSize+'px/'+ (parseInt(this.settings.fontSize) + Math.round(parseInt(this.settings.fontSize)/5)) +'px ' + this.settings.fontFamaly,
                background: "rgba(230,230,230,.0)",
                color: this.settings.fontColor,
                overflow: "hidden",
                border: "0px solid red"
            });
        }
        $('#chart-bubble-text').val('').focus().val(this.settings.text);
    }

    iChart.Charting.ChartBubble.prototype.onBlur = function (ctx) {
        var settings = this.settings;
        settings.text = $('#chart-bubble-text').val();
        this.setSettings(settings);
        $('#chart-element-bubble').css({top: '-12000px', left: '-12000px'}).remove();
    }

    iChart.Charting.ChartBubble.prototype.onHover = function (ctx) {
        if(this.selected) {
            this.settings.text = $('#chart-bubble-text').val();
        }
    }

    iChart.Charting.ChartBubble.prototype.onOut = function (ctx) {
        if(this.selected) {
            this.settings.text = $('#chart-bubble-text').val();
        }
    }

    iChart.Charting.ChartBubble.prototype.onRemove = function () {
        $('#chart-element-bubble').css({top: '-12000px', left: '-12000px'}).hide();
    }

    iChart.Charting.ChartBubble.prototype.drawCheckPoint = function (ctx, x, y, text) {
        ctx.strokeText(text,x,y);
        ctx.beginPath();
        ctx.save();
        ctx.strokeStyle="rgba(50,50,50,.4)";
        ctx.arc(x, y, 40, 0, 2 * Math.PI, true);
        ctx.stroke();
        ctx.beginPath();
        ctx.lineWidth="3";
        ctx.arc(x, y, 1, 0, 2 * Math.PI, true);
        ctx.stroke();
        ctx.restore();
    }


    iChart.Charting.ChartBubble.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            [this.testContext.points[0], { "x": this.testContext.points[0].x, "y": this.testContext.points[1].y}],
            [{ "x": this.testContext.points[0].x, "y": this.testContext.points[1].y }, this.testContext.points[1]],
            [this.testContext.points[1], { "x": this.testContext.points[1].x, "y": this.testContext.points[0].y}],
            [{ "x": this.testContext.points[1].x, "y": this.testContext.points[0].y }, this.testContext.points[0]]
        ];
    };

})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartText = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Text";
        this.drawType = 'manually';
        this.maxPointCount = 2;
        this.hasSettings = true;
        this.hasPopupSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings, {text: ''});
    };

    inheritPrototype(iChart.Charting.ChartText, iChart.Charting.ChartElement);

    iChart.Charting.ChartText.prototype.onInsert = function () {
        this.selected = true;

        var coords = this.getCoordinates(null, this.points);

        if (coords.length < 2)
        {
            return;
        }

        this.settings.width = coords[1].x - coords[0].x;
        this.settings.height = coords[1].y - coords[0].y;
    };

    iChart.Charting.ChartText.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        if(typeof this.markers != "undefined") {
            var size = {
                width: coords[1].x - coords[0].x,
                height: coords[1].y - coords[0].y
            };

            this.settings.width = coords[1].x - coords[0].x;
            this.settings.height = coords[1].y - coords[0].y;
        } else if(this.settings.width && this.settings.height) {
            this.points[1].x = this.layer.area.getXValue(coords[0].x + this.settings.width) * 1000;
            this.points[1].y = this.layer.area.getYValue(coords[0].y + this.settings.height);
            coords[1].x = this.layer.area.getXPositionByValue(this.points[1].x / 1000);
            coords[1].y = this.layer.area.getYPosition(this.points[1].y);
        }

        this.initDrawSettings(ctx, this.settings);

        this.drawLabel(ctx, coords);

    };

    iChart.Charting.ChartText.prototype.drawLabel = function (ctx, coords)
    {

        var radius = 30,
            radiusMax = 5,
            width = Math.abs(coords[0].x - coords[1].x),
            heigh = Math.abs(coords[0].y - coords[1].y),
            xD = coords[0].x < coords[1].x ? true : false,
            yD = coords[0].y < coords[1].y ? true : false,
            handle = [{},{},{}],
            handleBase,
            handleBaseMax = 80,
            xSide = false,
            ySide = false;

        radius = Math.min(parseInt(width/3),parseInt(heigh/3), radiusMax);

        ctx.save();

        ctx.beginPath();
//        ctx.strokeStyle="black";
//        ctx.lineWidth="1";

        ctx.moveTo(coords[0].x + (xD ? radius:-radius), coords[0].y);
        ctx.lineTo(coords[1].x - (xD ? radius:-radius), coords[0].y);
        ctx.quadraticCurveTo(coords[1].x, coords[0].y, coords[1].x, coords[0].y + (yD ? radius:-radius));
        ctx.lineTo(coords[1].x, coords[1].y - (yD ? radius:-radius));
        ctx.quadraticCurveTo(coords[1].x, coords[1].y, coords[1].x - (xD ? radius:-radius), coords[1].y);
        ctx.lineTo(coords[0].x + (xD ? radius:-radius), coords[1].y);
        ctx.quadraticCurveTo(coords[0].x, coords[1].y, coords[0].x, coords[1].y - (yD ? radius:-radius));
        ctx.lineTo(coords[0].x, coords[0].y + (yD ? radius:-radius));
        ctx.quadraticCurveTo(coords[0].x, coords[0].y, coords[0].x + (xD ? radius:-radius), coords[0].y);

//ctx.fillStyle="rgba(255,0,0,.4)";

        ctx.closePath();
        ctx.fill();
        ctx.stroke();

//        this.drawCheckPoint(ctx, coords[0].x + (xD ? radius:-radius), coords[0].y, '1');
//        this.drawCheckPoint(ctx, coords[0].x, coords[1].y - (yD ? radius:-radius), '2');
//        this.drawCheckPoint(ctx, coords[0].x, coords[0].y + (yD ? radius:-radius), '3');
//        this.drawCheckPoint(ctx, coords[0].x + (xD ? radius:-radius), coords[1].y, '4');
//        this.drawCheckPoint(ctx, coords[1].x - (xD ? radius:-radius), coords[1].y, '5');
//        this.drawCheckPoint(ctx, coords[1].x, coords[1].y - (yD ? radius:-radius), '6');
//        this.drawCheckPoint(ctx, coords[1].x - (xD ? radius:-radius), coords[0].y, '7');
//        this.drawCheckPoint(ctx, coords[1].x, coords[0].y + (yD ? radius:-radius), '8');

        this.drawText(ctx, coords, radius, '');

        ctx.restore();


    }

    iChart.Charting.ChartText.prototype.drawText = function (ctx, coords, radius, text) {

        var
            padding = 5,
            width = Math.abs(coords[0].x - coords[1].x) - parseInt(radius*2/3) - padding*2,
            height = Math.abs(coords[0].y - coords[1].y) - parseInt(radius*2/3) - padding*2,
            x = Math.min(coords[0].x, coords[1].x) + parseInt(radius/3) + padding,
            y = Math.min(coords[0].y, coords[1].y) + parseInt(radius/3) + padding;

        var settings = this.settings;
//console.log(settings);

        if(!this.selected) {

            text = settings.text;

            ctx.save();

            ctx.beginPath();

            ctx.fillStyle = this.settings.fontColor;
            ctx.font = 'normal ' + this.settings.fontSize + 'px ' + this.settings.fontFamaly;
            ctx.textAlign = "left";
            ctx.textBaseline="top";

//console.log(x, y, width, height);
            ctx.rect(x, y, width, height);
            //ctx.stroke();
            ctx.clip();
            ctx.translate(x, y);

            //ctx.fillText(text, 0, 0);
//console.log(text);
            text = text.replace(/\n/g, ' [%br%] ');
//console.log(text);
            var words = text.split(/\s/);
            var countWords = words.length;
//console.log(words);

            var line = '';
            var textHeight = 0+Math.round(parseInt(this.settings.fontSize)/10);
            var lineHeight = parseInt(this.settings.fontSize) + Math.round(parseInt(this.settings.fontSize)/5);
            //var lineHeight = 16;

            for (var n = 0; n < countWords; n++) {
                var testLine = line + words[n] + " ";
                var testWidth = ctx.measureText(testLine).width;
                if (words[n] == "[%br%]") {
                    ctx.fillText(line, 0, textHeight);
                    line = '';
                    textHeight += lineHeight;
                } else if (testWidth > width) {
                    ctx.fillText(line, 0, textHeight);
                    line = words[n] + " ";
                    textHeight += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 0, textHeight);
            ctx.closePath();
            ctx.restore();

        } else {
            var top = y;
            var left = x + this.layer.area.innerOffset.left;

            if($('#chart-bubble-text').is(':visible')) {
                this.settings.text = $('#chart-bubble-text').val();
            } else {
                if($('#chart-element-bubble').length == 0) {
                    $(this.layer.chart.container).append('' +
                        '<div id="chart-element-bubble" style="z-index: 15002; position: absolute; ">' +
                        '<textarea id="chart-bubble-text"></textarea>' +
                        '</div>');
                }
                $('#chart-bubble-text').val('').focus().val(this.settings.text);
            }
            $('#chart-bubble-text').css({
                font: 'normal '+this.settings.fontSize+'px/'+(parseInt(this.settings.fontSize) + Math.round(parseInt(this.settings.fontSize)/5))+'px ' + this.settings.fontFamaly,
                background: "rgba(230,230,230,.0)",
                color: this.settings.fontColor,
                overflow: "hidden",
                border: "0px solid red",
                width: width +'px',
                height: height + 'px'
            });

            $('#chart-element-bubble').css({top: top -0 +'px', left: left -1 + 'px'}).show();
            $('#chart-bubble-text').width(width-2).height(height-2);

            $('#chart-element-bubble').off('click mousedown drag dragstart').on('click mousedown drag dragstart', function(e) {
                e.stopPropagation();
            });
        }

    };

    iChart.Charting.ChartText.prototype.drawPopupSettings = function (ctx, coord) {

        var data = {
            options: {
                sizes: [
                    {name: 8, value: 8},
                    {name: 9, value: 9},
                    {name: 10, value: 10},
                    {name: 11, value: 11},
                    {name: 12, value: 12},
                    {name: 14, value: 14},
                    {name: 16, value: 16},
                    {name: 20, value: 20},
                    {name: 24, value: 24},
                    {name: 28, value: 28},
                    {name: 32, value: 32},
                    {name: 40, value: 40}
                ],
                fonts: [
                    {name: 'Verdana', value: 'Verdana,Tahoma,Geneva,Arial,Sans-serif'},
                    {name: 'Courier New', value: 'Courier New,Monospace'},
                    {name: 'Times New Roman', value: 'TimesNewRoman,Times,Baskerville,Georgia,serif'},
                    {name: 'Arial', value: 'Arial,Helvetica,sans-serif'}
                ]
            },
            values: {
                fontSize: this.settings.fontSize,
                fontColor: this.settings.fontColor,
                fontFamaly: this.settings.fontFamaly,
                text: this.settings.text
            }
        };

        var $textPopupSettingsHtml = $($.render.iChart_textPopupSettingsTmpl(data));

        var _this = this;

        var onMinicolorsChange = function(value, opacity){
            var color = $(this).val(),
                colorRGBA = color,
                option = $(this).attr('data-option');

            if(!color.match(/^rgb.*/)) {
                colorRGBA = iChart.hexToRGB(color, opacity)
            }

            $textPopupSettingsHtml.find('.js-colorSelector[data-option="' + option + '"]').css('background-color', colorRGBA);
            $textPopupSettingsHtml.find('input[data-option="' + option + '"]').val(colorRGBA);

            $(this).minicolors('value', colorRGBA);
        };

        var onPaletteChange = function(){
            var color = this.value;
            var option = this.element.attr('data-option');
            var colorRGBA = color;

            if(!color.match(/^rgb.*/)) {
                colorRGBA = iChart.hexToRGB(color, 1);
            }

            $textPopupSettingsHtml.find('.js-colorSelector[data-option="' + option + '"]').css('background-color', colorRGBA);
            $textPopupSettingsHtml.find('input[data-option="' + option + '"]').val(colorRGBA);
            this.element.parent().find('.js-colorPicker').minicolors('value', colorRGBA);
        };

        $textPopupSettingsHtml.find('.js-colorSelector').each(function(){

            var $this = $(this),
                menu = $this.find('.menuHolder').html();

            $this.qtip({
                style: {
                    classes: 'qtip-light'
                },
                position: {
                    at: 'center right',
                    my: 'left center',
                    effect: false,
                    viewport: $('html'),
                    adjust: {
                        method: 'shift none'
                    }
                },
                content: {
                    text: menu
                },
                hide: {
                    fixed: true,
                    delay: 300
                },
                show: {
                    solo: true
                },
                events: {
                    show: function(event, api) {
                        $(event.currentTarget).find('.js-colorPicker').each(function(){
                            _this.layer.chart.env.ui.addMinicolors(this, event.currentTarget, onMinicolorsChange, onPaletteChange);
                        });
                    }
                }
            });
        });

        $textPopupSettingsHtml.on('click', '.js-textPopupSettings', {popupWindow:$textPopupSettingsHtml, element: _this}, function(e){
            if($(this).data('value') == "ok") {
                e.data.element.settings.fontSize = e.data.popupWindow.find("[name='fontSize']").val();
                e.data.element.settings.fontFamaly = e.data.popupWindow.find("[name='fontFamaly']").val();
                e.data.element.settings.text = e.data.popupWindow.find("[name='text']").val();
                $('#chart-bubble-text').val(e.data.element.settings.text);
                e.data.element.settings.fontColor = e.data.popupWindow.find("input[data-option='fontColor']").val();
                e.data.element.layer.render();
            }

            if($.modal.impl.d.data) {
                $.modal.impl.close();
            }
        });

        this.layer.chart.env.wrapper.append($textPopupSettingsHtml);
        $textPopupSettingsHtml.modal(
            {modal: false, minWidth: 500, zIndex: 1500, position: [coord.y + 'px', coord.x + 'px'], title: _t('17599', 'Настройки текста')})
        ;
    };

    iChart.Charting.ChartText.prototype.onSelect = function (ctx) {
        iChart.Charting.ChartElement.prototype.onSelect.call(this, ctx);
        if($('#chart-element-bubble').length == 0) {
            $(this.layer.chart.container).append('' +
                '<div id="chart-element-bubble" style="z-index: 15002; position: absolute; ">' +
                '<textarea id="chart-bubble-text"></textarea>' +
                '</div>');
            $('#chart-bubble-text').css({
                font: 'normal '+this.settings.fontSize+'px/'+(parseInt(this.settings.fontSize) + Math.round(parseInt(this.settings.fontSize)/5))+'px ' + this.settings.fontFamaly,
                background: "rgba(230,230,230,.0)",
                color: this.settings.fontColor,
                overflow: "hidden",
                border: "0px solid red"
            });
        }
        $('#chart-bubble-text').val('').focus().val(this.settings.text);
        //$('#chart-bubble-text').get(0).setSelectionRange(0, $('#chart-bubble-text').val().length);

    }

    iChart.Charting.ChartText.prototype.onBlur = function (ctx) {
        var settings = this.settings;
        settings.text = $('#chart-bubble-text').val();
        this.setSettings(settings);
        $('#chart-element-bubble').css({top: '-12000px', left: '-12000px'}).remove();
    }

    iChart.Charting.ChartText.prototype.onHover = function (ctx) {
        if(this.selected) {
            this.settings.text = $('#chart-bubble-text').val();
        }
    }

    iChart.Charting.ChartText.prototype.onOut = function (ctx) {
        if(this.selected) {
            this.settings.text = $('#chart-bubble-text').val();
        }
    }

    iChart.Charting.ChartText.prototype.onRemove = function () {
        $('#chart-element-bubble').css({top: '-12000px', left: '-12000px'}).hide();
    }

    iChart.Charting.ChartText.prototype.drawCheckPoint = function (ctx, x, y, text) {
        ctx.strokeText(text,x,y);
        ctx.beginPath();
        ctx.save();
        ctx.strokeStyle="rgba(50,50,50,.4)";
        ctx.arc(x, y, 40, 0, 2 * Math.PI, true);
        ctx.stroke();
        ctx.beginPath();
        ctx.lineWidth="3";
        ctx.arc(x, y, 1, 0, 2 * Math.PI, true);
        ctx.stroke();
        ctx.restore();
    }


    iChart.Charting.ChartText.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            [this.testContext.points[0], { "x": this.testContext.points[0].x, "y": this.testContext.points[1].y}],
            [{ "x": this.testContext.points[0].x, "y": this.testContext.points[1].y }, this.testContext.points[1]],
            [this.testContext.points[1], { "x": this.testContext.points[1].x, "y": this.testContext.points[0].y}],
            [{ "x": this.testContext.points[1].x, "y": this.testContext.points[0].y }, this.testContext.points[0]]
        ];
    };

})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartOrder = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Order";
        this.drawType = 'auto';
        this.hoverCursor = "row-resize";
        this.moveCursor = "row-resize";
        this.maxPointCount = 1;
        this.hasSettings = true;
        this.controlEnable = false;
        this.storageEnable = false;
        this.settings = {};
        this.positionAbsolute = true;
    };

    inheritPrototype(iChart.Charting.ChartOrder, iChart.Charting.ChartElement);

    iChart.Charting.ChartOrder.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 1)
        {
            return;
        }

        this.settings.fillStyle = this.settings.fillStyle || "#3AAE3E";

        var point = this.layer.chart.areas[0].xSeries[this.layer.chart.areas[0].xSeries.length-this.layer.chart.chartOptions.futureAmount-1];
        this.points[0].x = point * 1000;
        coords[0].x = this.layer.area.getXPositionByValue(point);

        var color = this.settings.fillStyle;
        var canvasWidth = getElementSize(ctx.canvas).width;

        if(this.selected || ctx.inHover) {
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.moveTo(0, coords[0].y);
            ctx.lineTo(canvasWidth, coords[0].y);
            ctx.stroke();
            ctx.restore();

            this.drawLable(ctx, color, this.settings.textColor, coords[0].x, coords[0].y, this.settings.text);
        } else {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();

            for (var x = 0; x <= canvasWidth; x += 20)
            {
                ctx.moveTo(x, coords[0].y);
                ctx.lineTo(x + 12, coords[0].y);
            }
            ctx.stroke();
            ctx.restore();

        }
        //this.drawTestSegments(ctx);

    }

    iChart.Charting.ChartOrder.prototype.drawExtended = function (ctx) {
        if (this.selected) {
            var pointCoords = this.getCoordinates(ctx, this.points);

            if (pointCoords.length < 1) {
                return;
            }

            var label = iChart.formatNumber(this.points[0].y, {
                "decimalPrecision": this.layer.chart.labelPrecision,
                "scale": 0
            });

            this.layer.chart.renderer.drawLable(ctx, this.settings.fillStyle, 0, this.layer.area.innerWidth, pointCoords[0].y, label);

            if (typeof this.markers !== "undefined") {
                var pointCoords = this.getCoordinates(ctx, this.markers);

                var label = iChart.formatNumber(this.markers[0].y, {
                    "decimalPrecision": this.layer.chart.labelPrecision,
                    "scale": 0
                });
                var color = !ctx.inHover ? this.settings.fillStyle : ( typeof this.settings.fillStyleHover != "undefined" ? this.settings.fillStyleHover : iChart.Charting.ChartOrder.lightColor(this.settings.fillStyle));
                this.layer.chart.renderer.drawLable(ctx, color, 0, this.layer.area.innerWidth, pointCoords[0].y, label);
            }
        }
    };

    iChart.Charting.ChartOrder.prototype.drawLable = function (ctx, fillColor, textColor, x, y, text)
    {
        fillColor = fillColor ? fillColor : "#333333";
        textColor = textColor ? textColor : "#FFFFFF";

        ctx.save();

        ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        ctx.fillStyle = fillColor;

        ctx.lineWidth="2";

        var textWidth = ctx.measureText(text).width;

        var width = textWidth;
        var x = getElementSize(ctx.canvas).width - 120;
        ctx.beginPath();
        ctx.moveTo(x-width-5, y+5);
        ctx.lineTo(x-width-5, y-5);
        ctx.quadraticCurveTo(x-width-5, y-10, x-width, y-10);
        ctx.lineTo(x, y-10);
        ctx.quadraticCurveTo(x+5, y-10, x+5, y-5);
        ctx.lineTo(x+5, y+5);
        ctx.quadraticCurveTo(x+5, y+10, x, y+10);
        ctx.lineTo(x-width, y+10);
        ctx.quadraticCurveTo(x-width-5, y+10, x-width-5, y+5);


        ctx.closePath();

        ctx.save();
        var shadowColor = this.layer.chart.chartOptions.shadowColor;
        if (this.selected) {

            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 15;
            ctx.shadowOffsetY = 15;

        } else if (ctx.inHover) {

            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;

        }
        ctx.fill();
        ctx.restore();

        this.drawCancelButton(ctx, x, y-10);

        ctx.fillStyle = textColor;
        ctx.fillText(text, x-width, y);


        ctx.restore();

    };


    iChart.Charting.ChartOrder.prototype.drawCancelButton = function (ctx, x, y) {

        ctx.beginPath();
        ctx.moveTo(x, y);

        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 2;

        ctx.lineTo(x, y+20);
        ctx.stroke();

        ctx.lineTo(x+15, y+20);
        ctx.quadraticCurveTo(x+20, y+20, x+20, y+15);
        ctx.lineTo(x+20, y+5);
        ctx.quadraticCurveTo(x+20, y, x+15, y);
        ctx.closePath();

        ctx.fillStyle = '#e53935';
        ctx.fill();


        //Рисуем крестик
        ctx.beginPath();
        ctx.moveTo(x+5, y+5);
        ctx.lineTo(x+15, y+15);
        ctx.moveTo(x+5, y+15);
        ctx.lineTo(x+15, y+5);
        ctx.stroke();
        ctx.closePath();



    }

    iChart.Charting.ChartOrder.prototype.drawTestSegments = function (ctx) {
        if(typeof this.testContext != 'undefined') {
            ctx.save();
            ctx.beginPath();
            ctx.fillStyle = 'rgba(0,0,0,0.75)';
            for(var i in this.testContext.segments) {
                var c = this.testContext.segments[i];
                ctx.moveTo(c[0].x, c[0].y);
                ctx.lineTo(c[1].x, c[1].y);
                ctx.stroke();
            }
            ctx.closePath();
            ctx.restore();
        }
    }




    iChart.Charting.ChartOrder.prototype.setTestSegments = function ()
    {
        if (this.selected) {
            var ctx = this.layer.context;
            ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            var width = ctx.measureText(this.settings.text).width;
            var x = getElementSize(ctx.canvas).width - 120;
            this.testContext.segments = [
                [{ "x": x-width, "y": this.testContext.points[0].y-4}, { "x": x, "y": this.testContext.points[0].y-4}],
                [{ "x": x, "y": this.testContext.points[0].y-4}, { "x": x, "y": this.testContext.points[0].y+4}],
                [{ "x": x, "y": this.testContext.points[0].y+4}, { "x": x-width, "y": this.testContext.points[0].y+4}],
                [{ "x": x-width, "y": this.testContext.points[0].y+4}, { "x": x-width, "y": this.testContext.points[0].y-4}],
                [{ "x": x-width, "y": this.testContext.points[0].y}, { "x": x, "y": this.testContext.points[0].y}],
                [{"x": this.layer.area.innerOffset.left, "y": this.testContext.points[0].y},{"x": this.layer.area.innerOffset.left + this.layer.area.innerWidth,"y": this.testContext.points[0].y}]
            ];
        } else {
            if(this.testContext) {
                this.testContext.segments = [
                    [{
                        "x": this.layer.area.innerOffset.left,
                        "y": this.testContext.points[0].y
                    }, {
                        "x": this.layer.area.innerOffset.left + this.layer.area.innerWidth,
                        "y": this.testContext.points[0].y
                    }]
                ];
            }
        }
    };

    iChart.Charting.ChartOrder.prototype.onDrag  = function (points)
    {
        if(typeof this.settings.restriction == 'function') {
            this.settings.restriction.call(this, points);
        }
    };

    iChart.Charting.ChartOrder.prototype.onSelect = function (ctx) {
        iChart.Charting.ChartElement.prototype.onSelect.call(this, ctx);
        this.setTestSegments();
    };

    iChart.Charting.ChartOrder.prototype.onBlur = function () {
        this.setTestSegments();
    };

    iChart.Charting.ChartOrder.prototype.onDrop = function () {
        if(typeof this.settings.onDrop == 'function') {
            this.settings.onDrop.call(this);
        }
    };

    iChart.Charting.ChartOrder.prototype.onHover = function () {
        clearTimeout(this.layer.chart.env.timers.orderClose);
        this.cancelControl(1);
    };

    iChart.Charting.ChartOrder.prototype.onOut = function () {
        clearTimeout(this.layer.chart.env.timers.orderClose);
        var self = this;
        this.layer.chart.env.timers.orderClose = setTimeout(function(){self.cancelControl(0);}, 300);
    };

    iChart.Charting.ChartOrder.prototype.cancelControl = function (state) {
        if(typeof this.settings.onCancel == 'function') {
            if(state) {
                $('#ichartOrderCancelCtrl').hide();
                var ctx = this.layer.context;
                var x = getElementSize(ctx.canvas).width - 120;
                var pointCoords = this.getCoordinates(ctx, this.points);
                if(!$('#ichartOrderCancelCtrl').length) {
                    $("<span/>", { id:'ichartOrderCancelCtrl', "style": "color:transparent", "class": "m-chart-instrument-delete", "text": "✕", "title": _t('2958', 'Снять') }).hide().appendTo(this.layer.chart.container);
                }

                var self = this;
                $('#ichartOrderCancelCtrl').unbind('click').bind('click', function(e) {
                    if(typeof self.settings.onCancel == 'function') {
                        
                        self.settings.onCancel.call(self);

                    }
                    $('#ichartOrderCancelCtrl').hide();
                }).bind('mouseover', function () {
                    clearTimeout(self.layer.chart.env.timers.orderClose);
                }).bind('mouseleave', function () {
                    clearTimeout(self.layer.chart.env.timers.orderClose);
                    self.layer.chart.env.timers.orderClose = setTimeout(function(){self.cancelControl(0);}, 1000);
                });

                var top = pointCoords[0].y-8;
                var left = x+2;

                $('#ichartOrderCancelCtrl').css({top: top, left: left}).show();
            } else {
                $('#ichartOrderCancelCtrl').hide();
            }
        }
    };

    iChart.Charting.ChartOrder.lightColor = function (rgb)
    {
        rgb = rgb.substring(rgb.indexOf('(') + 1, rgb.lastIndexOf(')')).split(/,\s*/);
        for (var i = 0; i < 3; i++) {
            rgb[i] = parseInt(rgb[i]) + 40;
        }
        return 'rgba(' + rgb.join(", ") + ')';
    };

    iChart.Charting.ChartOrder.prototype.onMouseDown = function (e) {
        if (typeof this.settings.onSelect == 'function') {
            this.settings.onSelect.call(this, e);
        }
    };


})();


/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartVisualtrade = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Visualtrade";
        this.drawType = 'auto';
        this.hoverCursor = MOBILE_BROWSER_DETECTED ? "move" : "url('" + this.layer.chart.env.lib_path + "/styles/cursors/red_vertical_cursor.cur'), move";
        this.moveCursor = MOBILE_BROWSER_DETECTED ? "move": "url('" + this.layer.chart.env.lib_path + "/styles/cursors/red_vertical_cursor.cur'), move";
        this.maxPointCount = 5;
        this.hasSettings = true;
        this.controlEnable = true;
        this.storageEnable = false;
        this.settings = {
            redColor: '#bc353d',
            greenColor: '#7fcc1a',
            blueColor: '#4684c6',
            greyColor: '#999999',
            offset: 40//вправо от последий свечи
        };
        this.drawSingle = true;

    };

    inheritPrototype(iChart.Charting.ChartVisualtrade, iChart.Charting.ChartElement);

    iChart.Charting.ChartVisualtrade.prototype.setSettings = function (settings) {

        this.settings = $.extend(this.settings, settings);

        this.settings.onDrop = function (mode) {
            if(!isNaN(parseInt(mode))) {
                var i = parseInt(mode) - 1;
                if(i === 0) {
                    $(jNTChartTrading).trigger('priceExternalUpdate', ['price', iChart.roundToPrecision(this.points[0].y, this.layer.chart.env.userSettings.currentSecurity.min_step)]);
                } else if (i === 1) {
                    var order_type = this.getControlValue('order_type');
                    if (order_type == 'sell_at' || order_type == 'sell') {
                        $(jNTChartTrading).trigger('priceExternalUpdate', ['tp', iChart.roundToPrecision(this.points[1].y, this.layer.chart.env.userSettings.currentSecurity.min_step)]);
                    } else {
                        $(jNTChartTrading).trigger('priceExternalUpdate', ['sl', iChart.roundToPrecision(this.points[1].y, this.layer.chart.env.userSettings.currentSecurity.min_step)]);
                    }
                } else if (i === 2) {
                    var order_type = this.getControlValue('order_type');
                    if (order_type == 'sell_at' || order_type == 'sell') {
                        $(jNTChartTrading).trigger('priceExternalUpdate', ['sl', iChart.roundToPrecision(this.points[2].y, this.layer.chart.env.userSettings.currentSecurity.min_step)]);
                    } else {
                        $(jNTChartTrading).trigger('priceExternalUpdate', ['tp', iChart.roundToPrecision(this.points[2].y, this.layer.chart.env.userSettings.currentSecurity.min_step)]);
                    }
                }
            }
        };

        this.priceControl = {
            width: 180,
            height: 30
        };

        this.elementArea = {
            top: 70,
            bottom: 47,
            left: 10,
            right: 10
        };

        this.points[0].fActive = 1;
        this.points[1].fActive = 0;
        this.points[2].fActive = 0;
        this.points[0].enable = 1;
        this.points[1].enable = !!this.settings.stoplossEnable;
        this.points[2].enable = !!this.settings.takeprofitEnable;
        this.points[1].fHover = 0;
        this.points[2].fHover = 0;

        this.controls = {
            1: {
                enabled: false,
                element: this,
                x: 10, y: 10, w: 100, h: 17,
                click: function () {
                    this.element.switchControl(this);
                },
                type: 'order_type',
                label: _t('4018','Продать'),
                value: 'sell_at',
                active: false
            },
            2: {
                enabled: false,
                element: this,
                x: 10, y: 33, w: 100, h: 17,
                click: function () {
                    this.element.switchControl(this);
                },
                type: 'order_type',
                label: _t('4875', "Продать по рынку"),
                value: 'sell',
                active: false
            },
            3: {
                enabled: false,
                element: this,
                x: 120, y: 10, w: 100, h: 17,
                click: function () {
                    this.element.switchControl(this);
                },
                type: 'order_type',
                label: _t('4019','Купить'),
                value: 'buy_at',
                active: false
            },
            4: {
                enabled: false,
                element: this,
                x: 120, y: 33, w: 100, h: 17,
                click: function () {
                    this.element.switchControl(this);
                },
                type: 'order_type',
                label: _t('5452', 'Купить по рынку'),
                value: 'buy',
                active: false
            },
            5: {
                enabled: false,
                element: this,
                x: 120, y: -27, w: 100, h: 17,
                click: function () {
                    var order_type = this.element.getControlValue('order_type');
                    var operMap = {
                        'sell_at' : 3,
                        'sell': 4,
                        'buy_at': 1,
                        'buy': 2
                    };

                    var price = iChart.roundToPrecision(this.element.points[0].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step),
                        sl = 0,
                        tp = 0;

                    if(order_type == 'buy_at' || order_type == 'buy') {
                        sl = Math.min(iChart.roundToPrecision(this.element.points[1].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step), iChart.roundToPrecision(this.element.points[2].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step));
                        tp = Math.max(iChart.roundToPrecision(this.element.points[1].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step), iChart.roundToPrecision(this.element.points[2].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step));
                        if(price == sl) {
                            sl = null;
                        }
                        if(price == tp) {
                            tp = null;
                        }
                    } else if (order_type == 'sell_at' || order_type == 'sell') {
                        sl = Math.min(iChart.roundToPrecision(this.element.points[1].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step), iChart.roundToPrecision(this.element.points[2].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step));
                        tp = Math.max(iChart.roundToPrecision(this.element.points[1].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step), iChart.roundToPrecision(this.element.points[2].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step));
                        if(price == sl) {
                            sl = null;
                        }
                        if(price == tp) {
                            tp = null;
                        }
                    }

                    //jNTPanel.show(userSettings.currentSecurity.nt_ticker, operMap[order_type], price, sl, tp); @deprecated
                },
                type: 'action',
                label: _t('614','Ok'),
                value: 'ok',
                active: false
            },
            6: {
                enabled: false,
                element: this,
                x: 10, y: -27, w: 100, h: 17,
                click: function () {
                    this.element.remove();
                },
                type: 'action',
                label: _t('1403','Отмена'),
                value: 'cancel',
                active: false
            },
            7: {
                enabled: true,
                element: this,
                click: function () {
                    jNTChartTrading.close();
                    this.element.layer.chart.env.removeVisualTrade();
                },
                type: 'close',
                value: 'stoploss'
            },
            8: {
                enabled: true,
                element: this,
                click: function () {
                    jNTChartTrading.close();
                    this.element.layer.chart.env.removeVisualTrade();
                },
                type: 'close',
                value: 'takeprofit'
            },
            9: {
                enabled: true,
                element: this,
                active: true,
                click: function () {
                    this.element.points[0].fActive = 0;
                    jNTChartTrading.close();
                    this.element.layer.chart.env.removeVisualTrade();
                },
                type: 'close',
                value: 'price'
            }
        };
        for(var c=0; c < this.settings.controls.length; c++) {
            for(var i in this.controls) {
                if(this.settings.controls[c].type == this.controls[i].type && this.settings.controls[c].value == this.controls[i].value) {
                    this.controls[i].active = true;
                }
            }
        }

        this.maps = {
            0: {
                element: this,
                click: function () {
                    this.element.points[0].fActive = 1;
                    this.element.points[1].fActive = 0;
                    this.element.points[2].fActive = 0;
                    this.element.setTestSegments();
                    $(jNTChartTrading).trigger('priceExternalUpdate', ['price', iChart.roundToPrecision(this.element.points[0].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step)]);
                },
                hoverIn: function () {
                    this.element.points[0].fHover = 1;
                    this.element.layer.render();
                },
                hoverOut: function () {
                    this.element.points[0].fHover = 0;
                    this.element.layer.render();
                },
                type: 'sltp',
                value: 'price'
            },
            1: {
                element: this,
                click: function () {
                    this.element.points[1].fActive = 1;
                    this.element.points[0].fActive = 0;
                    this.element.points[2].fActive = 0;
                    this.element.setTestSegments();
                    var order_type = this.element.getControlValue('order_type');
                    if (order_type == 'sell_at' || order_type == 'sell') {
                        $(jNTChartTrading).trigger('priceExternalUpdate', ['tp', iChart.roundToPrecision(this.element.points[1].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step)]);
                    } else {
                        $(jNTChartTrading).trigger('priceExternalUpdate', ['sl', iChart.roundToPrecision(this.element.points[1].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step)]);
                    }
                },
                hoverIn: function () {
                    this.element.points[1].fHover = 1;
                    this.element.layer.render();
                },
                hoverOut: function () {
                    this.element.points[1].fHover = 0;
                    this.element.layer.render();
                },
                type: 'sltp',
                value: 'stoploss'
            },
            2: {
                element: this,
                click: function () {
                    this.element.points[2].fActive = 1;
                    this.element.points[0].fActive = 0;
                    this.element.points[1].fActive = 0;
                    this.element.setTestSegments();
                    var order_type = this.element.getControlValue('order_type');
                    if (order_type == 'sell_at' || order_type == 'sell') {
                        $(jNTChartTrading).trigger('priceExternalUpdate', ['sl', iChart.roundToPrecision(this.element.points[2].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step)]);
                    } else {
                        $(jNTChartTrading).trigger('priceExternalUpdate', ['tp', iChart.roundToPrecision(this.element.points[2].y, this.element.layer.chart.env.userSettings.currentSecurity.min_step)]);
                    }
                },
                hoverIn: function () {
                    this.element.points[2].fHover = 1;
                    this.element.layer.render();
                },
                hoverOut: function () {
                    this.element.points[2].fHover = 0;
                    this.element.layer.render();
                },
                type: 'sltp',
                value: 'takeprofit'
            }
        }
    };

    /**
     *
     * @param ctx
     * @param coords
     */
    iChart.Charting.ChartVisualtrade.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 3) { return; }

        var lastPoint = this.layer.chart.env.viewData.chart.areas[0].getXPositionByIndex(this.layer.chart.env.viewData.chart.areas[0].xSeries.length-1-this.layer.chart.env.viewData.chart.chartOptions.futureAmount) + this.settings.offset;
        lastPoint = Math.min(lastPoint, this.layer.chart.env.viewData.chart.areas[0].getXPositionByIndex(this.layer.chart.env.viewData.chart.areas[0].xSeries.length-1));
        var point = this.layer.chart.env.viewData.chart.areas[0].getXValue(lastPoint);

        this.points[0].x = point * 1000;
        this.points[1].x = this.points[2].x = this.points[0].x;


        coords[0].x = this.layer.area.getXPositionByValue(point);
        coords[1].x = coords[2].x = coords[0].x;

        if(this.selected) {
            this.drawArea(ctx, coords);
        }

        ctx.fillStyle = 'rgba(255,255,255,1)';

        for (var i = coords.length-1; i >= 0; i--) {
            if(i>=3) { continue; }
            this.drawPriceBox(ctx, coords, i);
            this.drawLabel(ctx, coords, i);
        }

        //габаритные точки для ресайза области видимости
        var areaPoints = this.getElementAreaPos(coords);
        this.points[3].y = this.layer.area.getYValue(areaPoints[0].y).toFixed(2);
        this.points[4].y = this.layer.area.getYValue(areaPoints[1].y).toFixed(2);
    };

    iChart.Charting.ChartVisualtrade.prototype.drawPoints = function (ctx, pointCoords) {};

    iChart.Charting.ChartVisualtrade.prototype.drawTestSegments = function (ctx) {
        if(typeof this.testContext != 'undefined') {
            ctx.save();
            ctx.fillStyle = '#000000';
            for(var i in this.testContext.controls) {
                var c = this.testContext.controls[i];
                ctx.rect(c[0].x, c[0].y, c[1].x - c[0].x, c[1].y - c[0].y);
                ctx.stroke();
            }
            ctx.restore();
        }
    }

    iChart.Charting.ChartVisualtrade.prototype.getColorForPoint = function (type)
    {
        var fillStyle = '#999999';
        switch (type) {
            case 0:
                fillStyle = this.settings.blueColor;
                break;
            case 1:
                if(this.points[type].fActive) {
                    if (this.getControlValue('order_type') == "sell" || this.getControlValue('order_type') == "sell_at") {
                        fillStyle = this.settings.greenColor;
                    } else {
                        fillStyle = this.settings.redColor;
                    }
                }
                break;
            case 2:
                if(this.points[type].fActive) {
                    if (this.getControlValue('order_type') == "sell" || this.getControlValue('order_type') == "sell_at") {
                        fillStyle = this.settings.redColor;
                    } else {
                        fillStyle = this.settings.greenColor;
                    }
                }
                break;
            default:
                fillStyle = '#5a6378';
                break;
        }
        return fillStyle;
    };

    iChart.Charting.ChartVisualtrade.prototype.drawExtended = function (ctx)
    {
        if (typeof this.markers !== "undefined") {
            var pointCoords = this.getCoordinates(ctx, this.markers);
            var points = this.markers;
        } else {
            var pointCoords = this.getCoordinates(ctx, this.points);
            var points = this.points;
        }

        if (pointCoords.length < 1) { return; }

        for(var i = 0; i < pointCoords.length && i<3; i++) {
            if(points[i].fActive) {
                var label = iChart.roundToPrecision(points[i].y, this.layer.chart.env.userSettings.currentSecurity.min_step);
                this.layer.chart.renderer.drawLable(ctx, this.getColorForPoint(i), 0, this.layer.area.innerWidth, pointCoords[i].y, label);
            }
        }
    };

    iChart.Charting.ChartVisualtrade.prototype.drawArea = function (ctx, coords) {

        var areaPoints = this.getElementAreaPos(coords);

        //ctx.fillStyle = 'rgba(113,121,138,0.5)';
        //ctx.fillRect(areaPoints[0].x, areaPoints[0].y, areaPoints[1].x - areaPoints[0].x, areaPoints[1].y - areaPoints[0].y);

        if(this.selected) {
            for(var i in this.controls) {
                var control = this.controls[i];

                if (!control.enabled) { continue; }
                this.drawControl(ctx, coords, control)
            }
        }
    };

    iChart.Charting.ChartVisualtrade.prototype.drawControl = function (ctx, coords, control)
    {
        ctx.save();
        var areaPoints = this.getElementAreaPos(coords);

        if(control.type == 'order_type' || control.type == 'action') {
            if(control.active) {
                ctx.fillStyle = 'rgba(57,63,79,1)';
            } else {
                ctx.fillStyle = '#ffffff';
            }

            if(control.y >= 0) {
                ctx.fillRect(areaPoints[0].x + control.x, areaPoints[0].y + control.y, control.w, control.h);
            } else {
                ctx.fillRect(areaPoints[0].x + control.x, areaPoints[1].y + control.y, control.w, control.h);
            }

            if(control.active) {
                ctx.fillStyle = '#ffffff';
                ctx.font = 'normal 11px Arial,Helvetica,sans-serif';
            } else {
                ctx.fillStyle = '#428bca';
                ctx.font = 'normal 11px Arial,Helvetica,sans-serif';
            }

            ctx.textAlign = "left";
            ctx.textBaseline = "top";

            if(control.y >= 0) {
                ctx.fillText(control.label, areaPoints[0].x + control.x + 2, areaPoints[0].y + control.y + 4);
            } else {
                ctx.fillText(control.label, areaPoints[0].x + control.x + 2, areaPoints[1].y + control.y + 4);
            }
        } else if(control.type == 'close') {
            if(control.value == 'stoploss' || control.value == 'takeprofit') {
                if (this.getControlValue('order_type') == "sell" || this.getControlValue('order_type') == "sell_at") {
                    if(control.value == 'stoploss' && this.points[2].fActive) {
                        var point = coords[2];
                    } else if (control.value == 'takeprofit' && this.points[1].fActive) {
                        var point = coords[1];
                    }
                } else if (this.getControlValue('order_type') == "buy" || this.getControlValue('order_type') == "buy_at") {
                    if(control.value == 'stoploss' && this.points[1].fActive) {
                        var point = coords[1];
                    } else if (control.value == 'takeprofit' && this.points[2].fActive) {
                        var point = coords[2];
                    }
                }
            } else if(this.points[0].fActive) {
                var point = coords[0];
            }

            if(point) {
                ctx.fillStyle = '#ff9999';
                //ctx.fillRect(point.x + this.priceControl.width + 2, point.y - 23, 16, 16);
                ctx.strokeStyle = '#777777';
                ctx.beginPath();
                //ctx.arc(point.x + this.priceControl.width + 10, point.y - 15, 8, 0, 2*Math.PI);
                ctx.lineWidth = 2;
                ctx.moveTo(point.x + this.priceControl.width + 10-4, point.y - 15-4);
                ctx.lineTo(point.x + this.priceControl.width + 10+4, point.y - 15+4);

                ctx.moveTo(point.x + this.priceControl.width + 10+4, point.y - 15-4);
                ctx.lineTo(point.x + this.priceControl.width + 10-4, point.y - 15+4);

                ctx.closePath();

                ctx.stroke();
            }

        }
        ctx.restore();
    };

    iChart.Charting.ChartVisualtrade.prototype.drawPriceBox = function (ctx, coords, type)
    {
        var fillStyle = '';

        switch (type) {
            case 0:
                fillStyle = this.settings.blueColor;
                break;
            case 1:
                if(this.points[type].fActive) {
                    switch (this.getControlValue('order_type')) {
                        case "sell":
                        case "sell_at":
                            fillStyle = this.settings.greenColor;
                            break;
                        case "buy":
                        case "buy_at":
                            fillStyle = this.settings.redColor;
                            break;
                    }
                } else {
                    fillStyle = this.settings.greyColor;
                }
                break;
            case 2:
                if(this.points[type].fActive) {
                    switch (this.getControlValue('order_type')) {
                        case "sell":
                        case "sell_at":
                            fillStyle = this.settings.redColor;
                            break;
                        case "buy":
                        case "buy_at":
                            fillStyle = this.settings.greenColor;
                            break;
                    }
                } else {
                    fillStyle = this.settings.greyColor;
                }
                break;
            default:
                fillStyle = 'ffffff';
                break;
        }

        if(this.points[type].fActive) {
            ctx.save();
            ctx.fillStyle = fillStyle;
            //Прямоугольник
            ctx.beginPath();
            ctx.moveTo(coords[type].x-10, coords[type].y-10);
            ctx.lineTo(coords[type].x+this.priceControl.width, coords[type].y-10);
            ctx.lineTo(coords[type].x+this.priceControl.width + 8, coords[type].y);
            ctx.lineTo(coords[type].x+this.priceControl.width, coords[type].y+10);
            ctx.lineTo(coords[type].x-10, coords[type].y+10);
            ctx.lineTo(coords[type].x-10, coords[type].y-10);
            ctx.moveTo(coords[type].x+10, coords[type].y-10);
            ctx.lineTo(coords[type].x+10, coords[type].y+10);
            ctx.closePath();
            //ctx.stroke();
            ctx.fill();
            ctx.restore();

            //Штрихи слева
            ctx.save();
            ctx.strokeStyle = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(coords[type].x-5, coords[type].y-3);
            ctx.lineTo(coords[type].x+5, coords[type].y-3);
            ctx.moveTo(coords[type].x-5, coords[type].y);
            ctx.lineTo(coords[type].x+5, coords[type].y);
            ctx.moveTo(coords[type].x-5, coords[type].y+3);
            ctx.lineTo(coords[type].x+5, coords[type].y+3);
            ctx.closePath();
            ctx.stroke();

            //Направляющие
            ctx.strokeStyle = fillStyle;
            ctx.beginPath();
            ctx.moveTo(coords[type].x + this.priceControl.width + 8, coords[type].y);
            ctx.lineTo(getElementSize(ctx.canvas).width, coords[type].y);
            ctx.moveTo(0, coords[type].y);
            ctx.lineTo(coords[type].x - 10, coords[type].y);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        } else {
            if(this.points[type].enable) {
                ctx.save();
                //ctx.strokeStyle = 'rgba(170,170,170)';
                if (this.points[type].fHover) {
                    ctx.strokeStyle = this.settings.blueColor;
                } else {
                    ctx.strokeStyle = '#AAAAAA';
                }
                //Прямоугольник
                ctx.beginPath();
                ctx.moveTo(coords[type].x - 10, coords[type].y - 10);
                ctx.lineTo(coords[type].x + this.priceControl.width, coords[type].y - 10);
                ctx.lineTo(coords[type].x + this.priceControl.width + 8, coords[type].y);
                ctx.lineTo(coords[type].x + this.priceControl.width, coords[type].y + 10);
                ctx.lineTo(coords[type].x - 10, coords[type].y + 10);
                ctx.lineTo(coords[type].x - 10, coords[type].y - 10);
                //ctx.moveTo(coords[type].x+10, coords[type].y-10);
                //ctx.lineTo(coords[type].x+10, coords[type].y+10);
                ctx.closePath();
                ctx.stroke();
                //ctx.fill();
                ctx.restore();
            }
        }
    };

    iChart.Charting.ChartVisualtrade.prototype.drawLabel = function (ctx, coords, type)
    {

        var label = '',
            fillStyle = 'rgba(0,0,0,1)';

        switch (type) {
            case 0:
                var price = this.points[0].y;
                if (typeof this.markers !== "undefined") {
                    price = this.markers[0].y;
                }
                switch (this.getControlValue('order_type')) {
                    case "sell":
                        label = _t('4875', 'Продать по рынку');
                        break;
                    case "sell_at":
                        label = _t('4876', "Продать по") + iChart.roundToPrecision(price, this.layer.chart.env.userSettings.currentSecurity.min_step);
                        break;
                    case "buy":
                        label = _t('5452', 'Купить по рынку');
                        break;
                    case "buy_at":
                        label = _t('5458', 'Купить по') + iChart.roundToPrecision(price, this.layer.chart.env.userSettings.currentSecurity.min_step);
                        break;
                }
                break;
            case 1:
                var price = this.points[1].y;
                if (typeof this.markers !== "undefined") {
                    price = this.markers[1].y;
                }
                switch (this.getControlValue('order_type')) {
                    case "sell":
                    case "sell_at":
                        label = _t('3917', 'TakeProfit') + ' ';
                        var pp = (this.points[0].y / price - 1) * 100;
                        break;
                    case "buy":
                    case "buy_at":
                        label = _t('3916', 'StopLoss') + ' ';
                        var pp = (1 - this.points[0].y / price) * 100;
                        break;
                }
                label  +=  pp.toFixed(2) + '%';
                break;
            case 2:
                var price = this.points[2].y;
                if (typeof this.markers !== "undefined") {
                    price = this.markers[2].y;
                }
                switch (this.getControlValue('order_type')) {
                    case "sell":
                    case "sell_at":
                        label = _t('3916', 'StopLoss') + ' ';
                        var pp = (1- price / this.points[0].y) * 100;
                        break;
                    case "buy":
                    case "buy_at":
                        label = _t('3917', 'TakeProfit') + ' ';
                        var pp = (price / this.points[0].y - 1) * 100;
                        break;
                }
                label  += pp.toFixed(2) + '%';
                break;
        }

        ctx.save();
        ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillStyle = '#ffffff';

        if(this.points[type].fActive) {
            ctx.fillText(label, coords[type].x + 15, coords[type].y);
        } else {
            if(this.points[type].fHover) {
                ctx.fillStyle = this.settings.blueColor;
            } else {
                ctx.fillStyle = '#AAAAAA';
            }
            if(this.points[type].enable) {
                ctx.fillText(label, coords[type].x + 15, coords[type].y);
            }
        }

        ctx.restore();
    };


    iChart.Charting.ChartVisualtrade.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            //[{ "x": this.testContext.points[0].x, "y": this.testContext.points[0].y}, { "x": this.testContext.points[0].x + this.priceControl.width, "y": this.testContext.points[0].y}]
        ];

        var areaPoints = this.getElementAreaPos(this.testContext.points);

        this.testContext.elementArea = areaPoints;

        this.testContext.controls = {};
        for(var i in this.controls) {
            if(!this.controls[i].enabled) { continue; }
            if(this.controls[i].type == 'order_type' || this.controls[i].type == 'action') {
                if (this.controls[i].y >= 0) {
                    this.testContext.controls[i] = [{
                        x: areaPoints[0].x + this.controls[i].x,
                        y: areaPoints[0].y + this.controls[i].y
                    }, {
                        x: areaPoints[0].x + this.controls[i].x + this.controls[i].w,
                        y: areaPoints[0].y + this.controls[i].y + this.controls[i].h
                    }];
                } else {//рисовать от нижнег к
                    this.testContext.controls[i] = [{
                        x: areaPoints[0].x + this.controls[i].x,
                        y: areaPoints[1].y + this.controls[i].y
                    }, {
                        x: areaPoints[0].x + this.controls[i].x + this.controls[i].w,
                        y: areaPoints[1].y + this.controls[i].y + this.controls[i].h
                    }];
                }
            } else if(this.controls[i].type == 'close') {
                var control = this.controls[i];

                if(control.value == 'stoploss' || control.value == 'takeprofit') {
                    if (this.getControlValue('order_type') == "sell" || this.getControlValue('order_type') == "sell_at") {
                        if(control.value == 'stoploss' && this.points[2].fActive) {
                            var point = this.testContext.points[2];
                        } else if (control.value == 'takeprofit' && this.points[1].fActive) {
                            var point = this.testContext.points[1];
                        }
                    } else {
                        if(control.value == 'stoploss' && this.points[1].fActive) {
                            var point = this.testContext.points[1];
                        } else if (control.value == 'takeprofit' && this.points[2].fActive) {
                            var point = this.testContext.points[2];
                        }
                    }
                } else if(this.points[0].fActive) {
                    var point = this.testContext.points[0];
                }


                if(point) {
                    this.testContext.controls[i] = [{
                        x: point.x + this.priceControl.width + 2,
                        y: point.y - 23
                    }, {
                        x: point.x + this.priceControl.width + 2 + 16,
                        y: point.y - 23 + 16
                    }];
                }
            }
        }

        this.testContext.maps = {};
        if(!this.points[0].fActive) {
            this.testContext.maps[0] = [{x: this.testContext.points[0].x + 10, y: this.testContext.points[0].y - 10},
                {x: this.testContext.points[0].x + this.priceControl.width + 10, y: this.testContext.points[0].y + 10}];
        }

        if(!this.points[1].fActive && this.points[1].enable) {
            this.testContext.maps[1] = [{x: this.testContext.points[1].x + 10, y: this.testContext.points[1].y - 10},
                {x: this.testContext.points[1].x + this.priceControl.width + 10, y: this.testContext.points[1].y + 10}];
        }
        if(!this.points[2].fActive && this.points[2].enable) {
            this.testContext.maps[2] = [{x: this.testContext.points[2].x + 10, y: this.testContext.points[2].y - 10},
                {x: this.testContext.points[2].x + this.priceControl.width + 10, y: this.testContext.points[2].y + 10}];
        }
    };

    iChart.Charting.ChartVisualtrade.prototype.onDrag  = function (points)
    {
        if(typeof this.settings.restriction == 'function') {
            this.settings.restriction.call(this, points);
        }
    };

    iChart.Charting.ChartVisualtrade.prototype.onDrop = function (mode) {
        if(typeof this.settings.onDrop == 'function') {
            this.settings.onDrop.call(this, mode);
        }
    };

    iChart.Charting.ChartVisualtrade.prototype.getElementAreaPos = function (coords)
    {
        var max = Math.max.apply(Math,coords.map(function(o, i){return i < 3 ? o.y : null;}));
        var min = Math.min.apply(Math,coords.map(function(o, i){return i < 3 ? o.y : max;}));

        if(this.selected) {
            return [
                { x: coords[0].x - this.elementArea.left, y: min - this.elementArea.top },
                { x: coords[0].x + this.priceControl.width + this.elementArea.right, y: max + this.elementArea.bottom }
            ];
        } else {
            return [
                { x: coords[0].x - this.elementArea.left, y: min - this.elementArea.top + 30 },
                { x: coords[0].x + this.priceControl.width + this.elementArea.right, y: max + this.elementArea.bottom }
            ];
        }
    };

    iChart.Charting.ChartVisualtrade.prototype.switchControl = function (control)
    {
        for(var i in this.controls) {
            if(control.type == this.controls[i].type) {
                this.controls[i].active = false;
            }
        }
        control.active = true;

        this.layer.render();
    };

    iChart.Charting.ChartVisualtrade.prototype.getControl = function (type, value)
    {
        for(var i in this.controls) {
            if(this.controls[i].type == type && this.controls[i].value == value) {
                return this.controls[i];
            }
        }
    };

    iChart.Charting.ChartVisualtrade.prototype.getControlValue = function (type)
    {
        for(var i in this.controls) {
            if(this.controls[i].type == type && this.controls[i].active) {
                return this.controls[i].value;
            }
        }
    };

    iChart.Charting.ChartVisualtrade.lightColor = function (rgb)
    {
        rgb = rgb.substring(rgb.indexOf('(') + 1, rgb.lastIndexOf(')')).split(/,\s*/);
        for (var i = 0; i < 3; i++) {
            rgb[i] = parseInt(rgb[i]) + 40;
        }
        return 'rgba(' + rgb.join(", ") + ')';
    };
})();


/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartButton = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Button";
        this.drawType = 'auto';
        this.maxPointCount = 1;
        this.hasSettings = true;
        this.controlEnable = true;
        this.storageEnable = false;
        this.settings = {
            controls: []
        };
    };

    inheritPrototype(iChart.Charting.ChartButton, iChart.Charting.ChartElement);

    iChart.Charting.ChartButton.prototype.setSettings = function (settings) {

        this.settings = $.extend(this.settings, settings);

        this.points[0].fActive = 1;

        this.controls = {
            1: {
                enabled: true,
                element: this,
                x: 0, y: 0, w: 100, h: 17,
                click: function () {
                    console.log(this);
                },
                label: _t('6346','Новый приказ'),
                fillColor: 'rgba(220,220,220,1)',
                strokeStyle: '#999999'
            }
        };
        for(var c=0; c < this.settings.controls.length; c++) {
            for(var i in this.controls) {
                if(this.settings.controls[c].type == this.controls[i].type && this.settings.controls[c].value == this.controls[i].value) {
                    this.controls[i].active = true;
                }
            }
        }

        this.maps = {
            0: {
                element: this,
                click: function () {
                    this.element.settings.click.call(this);
                },
                hoverIn: function () {
                    this.element.points[0].fHover = 1;
                    this.element.layer.render();
                },
                hoverOut: function () {
                    this.element.points[0].fHover = 0;
                    this.element.layer.render();
                }
            }
        }
    };

    iChart.Charting.ChartButton.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 1)
        {
            return;
        }

        this.settings.fillStyle = this.settings.fillStyle || "#3AAE3E";

        var lastPoint = this.layer.chart.areas[0].getXPositionByIndex(this.layer.chart.areas[0].xSeries.length-1-this.layer.chart.chartOptions.futureAmount) + 40;
        lastPoint = Math.min(lastPoint, this.layer.chart.areas[0].getXPositionByIndex(this.layer.chart.areas[0].xSeries.length-1));
        var pointX = this.layer.chart.areas[0].getXValue(lastPoint);

        var pointY = this.layer.chart.areas[0].ySeries[0].points[this.layer.chart.areas[0].ySeries[0].points.length-this.layer.chart.chartOptions.futureAmount-1];

        this.points[0].x = pointX * 1000;
        this.points[0].y = pointY[2];

        coords[0].x = this.layer.area.getXPositionByValue(pointX);

        for(var i in this.controls) {
            var control = this.controls[i];

            if (!control.enabled) { continue; }
            this.drawControl(ctx, coords, control)
        }
    }

    iChart.Charting.ChartButton.prototype.drawControl = function (ctx, coords, control)
    {
        ctx.save();

        ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        ctx.fillStyle = !this.points[0].fHover ? control.fillColor : 'rgba(58,174,62,1)';

        ctx.lineWidth="1";

        var textWidth = ctx.measureText(control.label).width;

        var point = coords[0];

        ctx.strokeStyle = control.strokeStyle;
        var width = textWidth;
        ctx.beginPath();
        ctx.moveTo(point.x, point.y + Math.round(control.h/2));
        ctx.lineTo(point.x, point.y-Math.round(control.h/2));
        ctx.quadraticCurveTo(point.x, point.y-Math.round(control.h/2)-5, point.x+5, point.y-Math.round(control.h/2)-5);
        ctx.lineTo(point.x+width+5, point.y-Math.round(control.h/2)-5);
        ctx.quadraticCurveTo(point.x+width+10, point.y-Math.round(control.h/2)-5, point.x+width+10, point.y-Math.round(control.h/2));
        ctx.lineTo(point.x+width+10, point.y+Math.round(control.h/2));
        ctx.quadraticCurveTo(point.x+width+10, point.y+Math.round(control.h/2)+5, point.x+width+5, point.y+Math.round(control.h/2)+5);
        ctx.lineTo(point.x+5, point.y+Math.round(control.h/2)+5);
        ctx.quadraticCurveTo(point.x, point.y+Math.round(control.h/2)+5, point.x, point.y+Math.round(control.h/2));
        ctx.closePath();
        ctx.fill();

        ctx.stroke();

        ctx.fillStyle = "#FFFFFF";
        ctx.fillText(control.label, point.x+5, point.y);

        ctx.restore();
    }

    iChart.Charting.ChartButton.prototype.drawPoints = function (ctx, pointCoords) {}

    iChart.Charting.ChartButton.prototype.setTestSegments = function ()
    {
        var ctx = this.layer.context;
        ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        var width = ctx.measureText(this.controls['1'].label).width;
        this.testContext.segments = [];

        this.testContext.maps = {};
        this.testContext.maps[0] = [{x: this.testContext.points[0].x, y: this.testContext.points[0].y - Math.round(this.controls['1'].h/2) - 5},
                                    {x: this.testContext.points[0].x + width + 10, y: this.testContext.points[0].y + Math.round(this.controls['1'].h/2) + 5}];
    };

    iChart.Charting.ChartButton.prototype.lightColor = function (rgb)
    {
        rgb = rgb.substring(rgb.indexOf('(') + 1, rgb.lastIndexOf(')')).split(/,\s*/);
        for (var i = 0; i < 3; i++) {
            rgb[i] = parseInt(rgb[i]) + 40;
        }
        return 'rgba(' + rgb.join(", ") + ')';
    };


})();


/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartEvent = function (layer)
    {

        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Event";
        this.drawType = 'auto';
        this.maxPointCount = 1;
        this.hasSettings = true;
        this.controlEnable = false;
        this.id = 0;
        this.settings = {
            color: 'red',
            size: 5,
            shape: 'disk', //[disk,circle,square,diamond,triangle]
            pointFormatter: function () {
                return '';
            },
            onHover: function () {},
            onOut: function () {}
        };
    };

    inheritPrototype(iChart.Charting.ChartEvent, iChart.Charting.ChartElement);

    iChart.Charting.ChartEvent.prototype.setSettings = function (settings)
    {
        this.settings = $.extend(this.settings, settings);
    };

    iChart.Charting.ChartEvent.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 1)
        {
            return;
        }

        ctx.save();

        ctx.fillStyle = this.settings.color;

        if(ctx.inHover) {
            ctx.fillStyle = '#0000ff';
            ctx.stokeStyle = '#000';
        }


        switch (this.settings.shape) {
            case 'circle':
                this.drawCircle(ctx, coords);
                break;
            case 'disk':
                this.drawDisc(ctx, coords);
                break;
            case 'square':
                this.drawSquare(ctx, coords);
                break;
            case 'diamond':
                this.drawDiamond(ctx, coords);
                break;
            case 'triangle':
                this.drawTriangle(ctx, coords);
                break;
            default:
                this.drawDisc(ctx, coords);
                break;
        }

        ctx.restore();

    };

    iChart.Charting.ChartEvent.prototype.drawDisc = function (ctx, coords) {
        ctx.beginPath();

        ctx.arc(coords[0].x, coords[0].y, this.settings.size, 0, 2 * Math.PI, true);

        ctx.fill();
        ctx.closePath();

    };

    iChart.Charting.ChartEvent.prototype.drawCircle = function (ctx, coords) {

        ctx.beginPath();

        ctx.lineWidth=this.settings.size*0.5;
        ctx.arc(coords[0].x, coords[0].y, this.settings.size, 0, 2 * Math.PI, true);
        ctx.closePath();

        if(!ctx.inHover) {
            ctx.strokeStyle = this.settings.color;
        }

        ctx.stroke();

    };

    iChart.Charting.ChartEvent.prototype.drawSquare = function (ctx, coords) {
        ctx.beginPath();

        var ds = this.settings.size;
        ctx.moveTo(coords[0].x-ds, coords[0].y-ds);
        ctx.lineTo(coords[0].x-ds, coords[0].y+ds);
        ctx.lineTo(coords[0].x+ds, coords[0].y+ds);
        ctx.lineTo(coords[0].x+ds, coords[0].y-ds);
        ctx.lineTo(coords[0].x-ds, coords[0].y-ds);

        ctx.fill();
        ctx.closePath();

    };

    iChart.Charting.ChartEvent.prototype.drawDiamond = function (ctx, coords) {
        ctx.beginPath();

        var ds = this.settings.size;
        ctx.moveTo(coords[0].x, coords[0].y-ds);
        ctx.lineTo(coords[0].x-ds*2/3, coords[0].y);
        ctx.lineTo(coords[0].x, coords[0].y+ds);
        ctx.lineTo(coords[0].x+ds*2/3, coords[0].y);
        ctx.lineTo(coords[0].x, coords[0].y-ds);

        ctx.fill();
        ctx.closePath();

    };

    iChart.Charting.ChartEvent.prototype.drawTriangle = function (ctx, coords) {
        ctx.beginPath();

        var ds = this.settings.size*2*Math.sin(Math.PI/3)/2;
        ctx.moveTo(coords[0].x, coords[0].y-ds);
        ctx.lineTo(coords[0].x-ds, coords[0].y+this.settings.size);
        ctx.lineTo(coords[0].x+ds, coords[0].y+this.settings.size);
        ctx.lineTo(coords[0].x, coords[0].y-ds);

        ctx.fill();
        ctx.closePath();

    };

    iChart.Charting.ChartEvent.prototype.onHover = function (ctx) {
        var coords = this.getCoordinates(ctx, this.points);
        var top = coords[0].y + /*$(iChart.viewData.chart.container).position().top + */$(this.layer.chart.container).offset().top;
        var left = coords[0].x + /*$(iChart.viewData.chart.container).position().left + */$(this.layer.chart.container).offset().left;

        this.drawTooltip(this.settings, top, left);

        if(typeof this.settings.onHover == "function") {
            this.settings.onHover.call(this);
        }
    };

    iChart.Charting.ChartEvent.prototype.onOut = function (ctx) {
        $('[chart-element-tooltip]').hide();
        if(typeof this.settings.onOut == "function") {
            this.settings.onOut.call(this);
        }
    };

    iChart.Charting.ChartEvent.prototype.drawTooltip = function (data, top, left) {

        if(this.layer.chart.env.wrapper.find('[chart-element-tooltip]').length == 0) {
            $('body').append('' +
            '<div chart-element-tooltip class="qtip qtip-default qtip-tipsy qtip-pos-rc" tracking="false" role="alert" aria-live="polite" aria-atomic="false" style="z-index: 15002;">' +
                '<div class="qtip-tip" style="background-color: transparent ! important; border: 0px none ! important; height: 6px; width: 6px; line-height: 6px; top: 50%; margin-top: -3px; right: -6px;"><canvas style="background-color: transparent ! important; border: 0px none ! important;" height="6" width="6"></canvas></div>' +
                '<div class="qtip-content" id="qtip-34-content" aria-atomic="true">' +
                '</div>' +
                '</div>' +
            '</div>');
        }

        var dataView = this.settings.pointFormatter.call(this.settings);

        if(dataView) {
            $('[chart-element-tooltip] .qtip-content').html(dataView);
            $('[chart-element-tooltip]').css({
                top: top - $('[chart-element-tooltip]').height() - 0 + 'px',
                left: left + 12 + 'px'
            }).show();
        }
    };

    iChart.Charting.ChartEvent.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            [this.testContext.points[0], { "x": this.testContext.points[0].x, "y": this.testContext.points[0].y}]
        ];
    };

})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartLevel = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Level";
        this.drawType = 'auto';
        this.hoverCursor = MOBILE_BROWSER_DETECTED ? "move" : "url('" + this.layer.chart.env.lib_path + "/styles/cursors/red_vertical_cursor.cur'), move";
        this.moveCursor = MOBILE_BROWSER_DETECTED ? "move" : "url('" + this.layer.chart.env.lib_path + "/styles/cursors/red_vertical_cursor.cur'), move";
        this.maxPointCount = 1;
        this.hasSettings = true;
        this.controlEnable = true;
        this.storageEnable = false;
        this.settings = {
            text: '',
            color: '#ED1ACE',
            textColor: 'red',
            inactiveHoverColor: '#4684c6',
            inactiveColor: '#AAAAAA',
            offset: 40,//вправо от последий свечи
            width: 150,
            height: 30
        };
        this.drawSingle = true;

    };

    inheritPrototype(iChart.Charting.ChartLevel, iChart.Charting.ChartElement);

    iChart.Charting.ChartLevel.prototype.setSettings = function (settings) {

        this.points[0].fActive = 1;
        this.points[0].fHover = 0;

        this.settings.onDrop =  function(mode){
            if(!isNaN(parseInt(mode))) {
                var i = parseInt(mode) - 1;
                var data = {
                    event: 'drop',
                    element: this,
                    value: this.points[0].y
                };
                this.layer.chart.env.wrapper.trigger('iguanaChartEvents', ['instrument', data]);
            }
        };

        this.controls = {
            0: {
                active: true,
                enabled: false,
                element: this,
                click: function () {
                    var data = {
                        event: 'close',
                        element: this,
                        value: this.points[0].y
                    };

                    this.layer.chart.env.wrapper.trigger('iguanaChartEvents', ['instrument', data]);
                    this.element.setTestSegments();
                    this.element.layer.render();
                },
                type: 'close',
                value: 'element'
            }
        };

        this.maps = {
            0: {
                element: this,
                click: function () {
                    this.element.points[0].fActive = 1;
                    this.element.setTestSegments();
                    var data = {
                        event: 'click',
                        element: this.element,
                        value: this.element.points[0].y
                    };

                    this.element.layer.chart.env.wrapper.trigger('iguanaChartEvents', ['instrument', data]);

                },
                hoverIn: function () {
                    this.element.points[0].fHover = 1;
                    this.element.layer.render();
                    var data = {
                        event: 'hoverIn',
                        element: this.element,
                        value: this.element.points[0].y
                    };

                    this.element.layer.chart.env.wrapper.trigger('iguanaChartEvents', ['instrument', data]);
                },
                hoverOut: function () {
                    this.element.points[0].fHover = 0;
                    this.element.layer.render();
                    var data = {
                        event: 'hoverOut',
                        element: this.element,
                        value: this.element.points[0].y
                    };

                    this.element.layer.chart.env.wrapper.trigger('iguanaChartEvents', ['instrument', data]);
                },
                type: 'element',
                value: 'element'
            }
        }

        this.settings = $.extend(this.settings, settings);

    };

    /**
     *
     * @param ctx
     * @param coords
     */
    iChart.Charting.ChartLevel.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 1) { return; }

        var lastPoint = this.layer.chart.env.viewData.chart.areas[0].getXPositionByIndex(this.layer.chart.env.viewData.chart.areas[0].xSeries.length-1-this.layer.chart.env.viewData.chart.chartOptions.futureAmount) + this.settings.offset;
        lastPoint = Math.min(lastPoint, this.layer.chart.env.viewData.chart.areas[0].getXPositionByIndex(this.layer.chart.env.viewData.chart.areas[0].xSeries.length-1));
        var point = this.layer.chart.env.viewData.chart.areas[0].getXValue(lastPoint);

        this.points[0].x = point * 1000;

        coords[0].x = this.layer.area.getXPositionByValue(point);


        //if(this.selected) {
        for(var i in this.controls) {
            var control = this.controls[i];

            if (!control.enabled) { continue; }
            this.drawControl(ctx, coords, control)
        }

        //}


        ctx.fillStyle = 'rgba(255,255,255,1)';

        for (var i = coords.length-1; i >= 0; i--) {
            if(i>=3) { continue; }
            this.drawPriceBox(ctx, coords, i);
            this.drawLabel(ctx, coords, i);
        }

    };

    iChart.Charting.ChartLevel.prototype.drawPoints = function (ctx, pointCoords) {};

    iChart.Charting.ChartLevel.prototype.drawExtended = function (ctx)
    {
        if (typeof this.markers !== "undefined") {
            var pointCoords = this.getCoordinates(ctx, this.markers);
            var points = this.markers;
        } else {
            var pointCoords = this.getCoordinates(ctx, this.points);
            var points = this.points;
        }

        if (pointCoords.length < 1) { return; }

        for(var i = 0; i < pointCoords.length && i<3; i++) {
            if(points[i].fActive) {
                var label = iChart.roundToPrecision(points[i].y, this.layer.chart.env.userSettings.currentSecurity.min_step);
                this.layer.chart.renderer.drawLable(ctx, this.settings.color, this.settings.textColor, this.layer.area.innerWidth, pointCoords[i].y, label);
            }
        }
    };

    iChart.Charting.ChartLevel.prototype.drawControl = function (ctx, coords, control)
    {
        ctx.save();

        if(control.type == 'close') {

            var point = coords[0];

            if(point) {
                ctx.fillStyle = '#ff9999';
                //ctx.fillRect(point.x + this.settings.width + 2, point.y - 23, 16, 16);
                ctx.strokeStyle = '#777777';
                ctx.beginPath();
                //ctx.arc(point.x + this.settings.width + 10, point.y - 15, 8, 0, 2*Math.PI);
                ctx.lineWidth = 2;
                ctx.moveTo(point.x + this.settings.width + 10-4, point.y - 15-4);
                ctx.lineTo(point.x + this.settings.width + 10+4, point.y - 15+4);

                ctx.moveTo(point.x + this.settings.width + 10+4, point.y - 15-4);
                ctx.lineTo(point.x + this.settings.width + 10-4, point.y - 15+4);

                ctx.closePath();

                ctx.stroke();
            }

        }
        ctx.restore();
    };


    iChart.Charting.ChartLevel.prototype.drawPriceBox = function (ctx, coords, type)
    {
        var fillStyle = this.settings.color;

        if(this.points[type].fActive) {
            ctx.save();
            ctx.fillStyle = fillStyle;
            //Прямоугольник
            ctx.beginPath();
            ctx.moveTo(coords[type].x-10, coords[type].y-10);
            ctx.lineTo(coords[type].x+this.settings.width, coords[type].y-10);
            ctx.lineTo(coords[type].x+this.settings.width + 8, coords[type].y);
            ctx.lineTo(coords[type].x+this.settings.width, coords[type].y+10);
            ctx.lineTo(coords[type].x-10, coords[type].y+10);
            ctx.lineTo(coords[type].x-10, coords[type].y-10);
            ctx.moveTo(coords[type].x+10, coords[type].y-10);
            ctx.lineTo(coords[type].x+10, coords[type].y+10);
            ctx.closePath();
            //ctx.stroke();
            ctx.fill();
            ctx.restore();

            //Штрихи слева
            ctx.save();
            ctx.strokeStyle = this.settings.textColor;
            ctx.beginPath();
            ctx.moveTo(coords[type].x-5, coords[type].y-3);
            ctx.lineTo(coords[type].x+5, coords[type].y-3);
            ctx.moveTo(coords[type].x-5, coords[type].y);
            ctx.lineTo(coords[type].x+5, coords[type].y);
            ctx.moveTo(coords[type].x-5, coords[type].y+3);
            ctx.lineTo(coords[type].x+5, coords[type].y+3);
            ctx.closePath();
            ctx.stroke();

            //Направляющие
            ctx.strokeStyle = fillStyle;
            ctx.beginPath();
            ctx.moveTo(coords[type].x + this.settings.width + 8, coords[type].y);
            ctx.lineTo(getElementSize(ctx.canvas).width, coords[type].y);
            ctx.moveTo(0, coords[type].y);
            ctx.lineTo(coords[type].x - 10, coords[type].y);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        } else {
            ctx.save();
            //ctx.strokeStyle = 'rgba(170,170,170)';
            if(this.points[type].fHover) {
                ctx.strokeStyle = this.settings.inactiveHoverColor;
            } else {
                ctx.strokeStyle = this.settings.inactiveColor;
            }
            //Прямоугольник
            ctx.beginPath();
            ctx.moveTo(coords[type].x-10, coords[type].y-10);
            ctx.lineTo(coords[type].x+this.settings.width, coords[type].y-10);
            ctx.lineTo(coords[type].x+this.settings.width + 8, coords[type].y);
            ctx.lineTo(coords[type].x+this.settings.width, coords[type].y+10);
            ctx.lineTo(coords[type].x-10, coords[type].y+10);
            ctx.lineTo(coords[type].x-10, coords[type].y-10);
            //ctx.moveTo(coords[type].x+10, coords[type].y-10);
            //ctx.lineTo(coords[type].x+10, coords[type].y+10);
            ctx.closePath();
            ctx.stroke();
            //ctx.fill();
            ctx.restore();

        }
    };

    iChart.Charting.ChartLevel.prototype.drawLabel = function (ctx, coords, type)
    {

        var label = '',
            fillStyle = 'rgba(0,0,0,1)';

        var price = this.points[0].y;
        if (typeof this.markers !== "undefined") {
            price = this.markers[0].y;
        }
        label = this.settings.text;

        ctx.save();
        ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillStyle = this.settings.textColor;

        if(this.points[type].fActive) {

        } else {
            if(this.points[type].fHover) {
                ctx.fillStyle = this.settings.inactiveHoverColor;
            } else {
                ctx.fillStyle = this.settings.inactiveColor;
            }
        }

        ctx.fillText(label, coords[type].x + 15, coords[type].y);
        ctx.restore();
    };


    iChart.Charting.ChartLevel.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            //[{ "x": this.testContext.points[0].x, "y": this.testContext.points[0].y}, { "x": this.testContext.points[0].x + this.settings.width, "y": this.testContext.points[0].y}]
        ];

        this.testContext.controls = {};
        for(var i in this.controls) {
            var point = this.testContext.points[i];
            if(point) {
                this.testContext.controls[i] = [{
                    x: point.x + this.settings.width + 2,
                    y: point.y - 23
                }, {
                    x: point.x + this.settings.width + 2 + 16,
                    y: point.y - 23 + 16
                }];
            }

        }

        this.testContext.maps = {};
        //if(!this.points[0].fActive || 1) {
            this.testContext.maps[0] = [{x: this.testContext.points[0].x + 10, y: this.testContext.points[0].y - 10},
                {x: this.testContext.points[0].x + this.settings.width + 10, y: this.testContext.points[0].y + 10}];
        //}
    };

    iChart.Charting.ChartLevel.prototype.onDrag  = function (points)
    {
        if(typeof this.settings.restriction == 'function') {
            this.settings.restriction.call(this, points);
        }
    };

    iChart.Charting.ChartLevel.prototype.onDrop = function (mode) {
        if(typeof this.settings.onDrop == 'function') {
            this.settings.onDrop.call(this, mode);
        }
    };

    iChart.Charting.ChartLevel.prototype.setValue = function (value)
    {
        this.points[0].y = value;
        this.layer.render();
    };

    iChart.Charting.ChartLevel.lightColor = function (rgb)
    {
        rgb = rgb.substring(rgb.indexOf('(') + 1, rgb.lastIndexOf(')')).split(/,\s*/);
        for (var i = 0; i < 3; i++) {
            rgb[i] = parseInt(rgb[i]) + 40;
        }
        return 'rgba(' + rgb.join(", ") + ')';
    };
})();


/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartRange = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Range";
        this.drawType = 'auto';
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartRange, iChart.Charting.ChartElement);

    iChart.Charting.ChartRange.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        ctx.save();
        ctx.beginPath();

        this.initDrawSettings(ctx, this.settings);


        var canvasHeight = getElementSize(ctx.canvas).height;

        ctx.beginPath();
        ctx.moveTo(coords[0].x, 0);
        ctx.lineTo(coords[0].x, canvasHeight);
        ctx.stroke();

        ctx.beginPath();
        ctx.lineTo(coords[1].x, 0);
        ctx.lineTo(coords[1].x, canvasHeight);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(coords[0].x, 0);
        ctx.lineTo(coords[0].x, canvasHeight);
        ctx.lineTo(coords[1].x, canvasHeight);
        ctx.lineTo(coords[1].x, 0);
        ctx.fill();

        ctx.restore();
    };

    iChart.Charting.ChartRange.prototype.setTestSegments = function ()
    {
        var ctx = this.layer.context,
            minX = this.testContext.points[0].x,
            maxX = this.testContext.points[1].x,
            hoverStepPx = 16;

        this.testContext.segments = [];
        for (var i = minX; i <= maxX; i = i + hoverStepPx) {
            this.testContext.segments.push([
                {x: i, y: 0},
                {x: i, y: 10e+10}
            ]);
        }
        this.testContext.segments.push([{ "x": maxX, "y": 0}, { "x": maxX, "y": 10e+10}]);

        //this.testContext.segments = [
        //    [{ "x": this.testContext.points[0].x, "y": 0}, { "x": this.testContext.points[0].x, "y": 10e+10}],
        //    [{ "x": this.testContext.points[1].x, "y": 0}, { "x": this.testContext.points[1].x, "y": 10e+10}]
        //];
    };
})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartPosition = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Position";
        this.drawType = 'auto';
        this.hoverCursor = "default";
        this.moveCursor = "default";
        this.maxPointCount = 1;
        this.hasSettings = true;
        this.controlEnable = false;
        this.storageEnable = false;
        this.settings = {};
        this.positionAbsolute = true;
    };

    inheritPrototype(iChart.Charting.ChartPosition, iChart.Charting.ChartElement);

    iChart.Charting.ChartPosition.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 1)
        {
            return;
        }

        this.settings.fillStyle = this.settings.fillStyle || "#3AAE3E";

        var point = this.layer.chart.areas[0].xSeries[this.layer.chart.areas[0].xSeries.length-this.layer.chart.chartOptions.futureAmount-1];
        this.points[0].x = point * 1000;
        coords[0].x = this.layer.area.getXPositionByValue(point);



        var color = this.settings.fillStyle;

        var coordinates = this.getCoordinates(ctx, [{x: this.settings.time, y: 0}]);
        var start = 0;
        var canvasWidth = getElementSize(ctx.canvas).width;

        if(coordinates.length) {
            start = coordinates[0].x;
        }

        if(this.selected || ctx.inHover) {
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.moveTo(start, coords[0].y);
            ctx.lineTo(canvasWidth, coords[0].y);
            ctx.stroke();
            ctx.restore();

            this.drawLable(ctx, color, this.settings.textColor, coords[0].x, coords[0].y, this.settings);

        } else {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            //for (var x = coords[0].x; x <= canvasWidth; x += 20)
            for (var x = 0; x <= canvasWidth; x += 20)
            {
                ctx.moveTo(x, coords[0].y);
                ctx.lineTo(x + 12, coords[0].y);
            }
            ctx.stroke();
            ctx.restore();
        }
        //this.drawTestSegments(ctx);

    }




    iChart.Charting.ChartPosition.prototype.drawExtended = function (ctx) {
        if (this.selected) {
            var pointCoords = this.getCoordinates(ctx, this.points);

            if (pointCoords.length < 1) {
                return;
            }

            var label = iChart.formatNumber(this.points[0].y, {
                "decimalPrecision": this.layer.chart.labelPrecision,
                "scale": 0
            });

            this.layer.chart.renderer.drawLable(ctx, this.settings.fillStyle, 0, this.layer.area.innerWidth, pointCoords[0].y, label);

            if (typeof this.markers !== "undefined") {
                var pointCoords = this.getCoordinates(ctx, this.markers);

                var label = iChart.formatNumber(this.markers[0].y, {
                    "decimalPrecision": this.layer.chart.labelPrecision,
                    "scale": 0
                });
                var color = !ctx.inHover ? this.settings.fillStyle : ( typeof this.settings.fillStyleHover != "undefined" ? this.settings.fillStyleHover : iChart.Charting.ChartPosition.lightColor(this.settings.fillStyle));
                this.layer.chart.renderer.drawLable(ctx, color, 0, this.layer.area.innerWidth, pointCoords[0].y, label);
            }
        }
    };


    //Отрисовка сделок
    iChart.Charting.ChartPosition.prototype.drawTrades = function (ctx, x, settings) {

        var _this = this;
        var points = [];

        //Время и цена сделки
        $.each(settings.trades, function(i, trade){
            points.push({
                x: trade.x,
                y: trade.y
            });
        });

        //Кординаты точек на графике
        var coordinates = _this.getCoordinates(ctx, points);

        coordinates.forEach(function(tradeCoordinates){

            if (tradeCoordinates.x > x) return;

            ctx.save();
            ctx.beginPath();

            ctx.arc(tradeCoordinates.x, tradeCoordinates.y, 5, 0, 2 * Math.PI, true);
            ctx.fillStyle = '#607d8b';
            ctx.fill();

            ctx.arc(tradeCoordinates.x, tradeCoordinates.y, 2, 0, 2 * Math.PI, true);
            ctx.fillStyle = '#ffffff';
            ctx.fill();

            ctx.closePath();

            ctx.restore();
        })
    };


    iChart.Charting.ChartPosition.prototype.drawLable = function (ctx, fillColor, textColor, x, y, settings)
    {
        fillColor = fillColor ? fillColor : "#333333";
        textColor = textColor ? textColor : "#FFFFFF";

        ctx.save();

        ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        ctx.fillStyle = fillColor;

        ctx.lineWidth="1";


        var width = ctx.measureText(settings.positionText + settings.profitText).width;
        var canvasWidth = getElementSize(ctx.canvas).width;
        x = canvasWidth - 120;
        var _x = canvasWidth - 120 - width;

        ctx.beginPath();
        ctx.moveTo(x-width-5, y+5);
        ctx.lineTo(x-width-5, y-5);
        ctx.quadraticCurveTo(x-width-5, y-10, x-width, y-10);
        ctx.lineTo(x, y-10);
        ctx.quadraticCurveTo(x+5, y-10, x+5, y-5);
        ctx.lineTo(x+5, y+5);
        ctx.quadraticCurveTo(x+5, y+10, x, y+10);
        ctx.lineTo(x-width, y+10);
        ctx.quadraticCurveTo(x-width-5, y+10, x-width-5, y+5);
        ctx.closePath();
        ctx.fill();

        if (settings.profitText) {

            ctx.fillStyle = textColor;
            ctx.fillText(settings.positionText, x-width, y);

            width = ctx.measureText(settings.profitText).width;
            ctx.fillStyle = settings.profitColor;
            ctx.beginPath();
            ctx.moveTo(x-width, y+5);
            ctx.lineTo(x-width, y-5);
            ctx.lineTo(x-width, y-10);
            ctx.lineTo(x, y-10);
            ctx.quadraticCurveTo(x+5, y-10, x+5, y-5);
            ctx.lineTo(x+5, y+5);
            ctx.quadraticCurveTo(x+5, y+10, x, y+10);
            ctx.lineTo(x-width, y+10);
            ctx.lineTo(x-width, y+10);
            ctx.closePath();
            ctx.fill();

            this.drawCancelButton(ctx, x, y-10);

            ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            ctx.fillStyle = textColor;
            ctx.fillText(settings.profitText, x-width, y);
        }



        ctx.restore();

        this.drawTrades(ctx, _x, this.settings);


    }

    iChart.Charting.ChartPosition.prototype.drawCancelButton = function (ctx, x, y) {

        ctx.beginPath();
        ctx.moveTo(x, y);

        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 2;

        ctx.lineTo(x, y+20);
        ctx.stroke();

        ctx.lineTo(x+15, y+20);
        ctx.quadraticCurveTo(x+20, y+20, x+20, y+15);
        ctx.lineTo(x+20, y+5);
        ctx.quadraticCurveTo(x+20, y, x+15, y);
        ctx.closePath();

        ctx.fillStyle = '#e53935';
        ctx.fill();

        //Рисуем крестик
        ctx.beginPath();
        ctx.moveTo(x+5, y+5);
        ctx.lineTo(x+15, y+15);
        ctx.moveTo(x+5, y+15);
        ctx.lineTo(x+15, y+5);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();


    }

    iChart.Charting.ChartPosition.prototype.drawPoints = function (ctx, pointCoords) {}

    iChart.Charting.ChartPosition.prototype.drawTestSegments = function (ctx) {
        if(typeof this.testContext != 'undefined') {
            ctx.save();
            ctx.beginPath();
            ctx.fillStyle = 'rgba(0,0,0,0.75)';
            for(var i in this.testContext.segments) {
                var c = this.testContext.segments[i];
                ctx.moveTo(c[0].x, c[0].y);
                ctx.lineTo(c[1].x, c[1].y);
                ctx.stroke();
            }
            ctx.closePath();
            ctx.restore();
        }
    }


    iChart.Charting.ChartPosition.prototype.setTestSegments = function ()
    {
        if (this.selected) {
             var ctx = this.layer.context;
             ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
             ctx.textAlign = "left";
             ctx.textBaseline = "middle";
             var width = ctx.measureText(this.settings.text).width;
             var x = getElementSize(ctx.canvas).width - 120;
             this.testContext.segments = [
             [{ "x": x-width, "y": this.testContext.points[0].y-4}, { "x": x, "y": this.testContext.points[0].y-4}],
             [{ "x": x, "y": this.testContext.points[0].y-4}, { "x": x, "y": this.testContext.points[0].y+4}],
             [{ "x": x, "y": this.testContext.points[0].y+4}, { "x": x-width, "y": this.testContext.points[0].y+4}],
             [{ "x": x-width, "y": this.testContext.points[0].y+4}, { "x": x-width, "y": this.testContext.points[0].y-4}],
             [{ "x": x-width, "y": this.testContext.points[0].y}, { "x": x, "y": this.testContext.points[0].y}],
             [{"x": this.layer.area.innerOffset.left, "y": this.testContext.points[0].y},{"x": this.layer.area.innerOffset.left + this.layer.area.innerWidth,"y": this.testContext.points[0].y}]
             ];
        } else {
            if(this.testContext) {
                this.testContext.segments = [
                    [{
                        "x": this.layer.area.innerOffset.left,
                        "y": this.testContext.points[0].y
                    }, {
                        "x": this.layer.area.innerOffset.left + this.layer.area.innerWidth,
                        "y": this.testContext.points[0].y
                    }]
                ];
            }
        }
    };

    iChart.Charting.ChartPosition.prototype.onDrag  = function (points)
    {
        if(typeof this.settings.restriction == 'function') {
            this.settings.restriction.call(this, points);
        }
    };

    iChart.Charting.ChartPosition.prototype.onSelect = function (ctx) {
        iChart.Charting.ChartElement.prototype.onSelect.call(this, ctx);
        this.setTestSegments();
    };

    iChart.Charting.ChartPosition.prototype.onBlur = function () {
        this.setTestSegments();
    };

    iChart.Charting.ChartPosition.prototype.onDrop = function () {
        if(typeof this.settings.onDrop == 'function') {
            this.settings.onDrop.call(this);
        }
    };

    iChart.Charting.ChartPosition.prototype.onHover = function () {
        clearTimeout(this.layer.chart.env.timers.positionClose);
        this.cancelControl(1);
    };

    iChart.Charting.ChartPosition.prototype.onOut = function () {
        clearTimeout(this.layer.chart.env.timers.positionClose);
        var self = this;
        this.layer.chart.env.timers.orderClose = setTimeout(function(){self.cancelControl(0);}, 300);
    };

    iChart.Charting.ChartPosition.prototype.cancelControl = function (state) {

        if(typeof this.settings.onCancel == 'function') {
            if(state) {
                $('#ichartPositionCancelCtrl').hide();
                var ctx = this.layer.context;
                var x = getElementSize(ctx.canvas).width - 120;
                var pointCoords = this.getCoordinates(ctx, this.points);
                if(!$('#ichartPositionCancelCtrl').length) {
                    $("<span/>", { id:'ichartPositionCancelCtrl', "style": "color:transparent", "class": "m-chart-instrument-delete", "text": "✕", "title": _t('15807', 'Закрыть позицию по рынку') }).hide().appendTo(this.layer.chart.container);
                }

                var self = this;
                $('#ichartPositionCancelCtrl').unbind('click').bind('click', function(e) {
                    if(typeof self.settings.onCancel == 'function') {
                        self.settings.onCancel.call(self);
                    }
                    $('#ichartOrderCancelCtrl').hide();
                }).bind('mouseover', function () {
                    clearTimeout(self.layer.chart.env.timers.positionClose);
                }).bind('mouseleave', function () {
                    clearTimeout(self.layer.chart.env.timers.positionClose);
                    self.layer.chart.env.timers.positionClose = setTimeout(function(){self.cancelControl(0);}, 1000);
                });

                var top = pointCoords[0].y-8;
                var left = x+2;

                $('#ichartPositionCancelCtrl').css({top: top, left: left}).show();
            } else {
                $('#ichartPositionCancelCtrl').hide();
            }
        }
    };

    iChart.Charting.ChartPosition.lightColor = function (rgb)
    {
        rgb = rgb.substring(rgb.indexOf('(') + 1, rgb.lastIndexOf(')')).split(/,\s*/);
        for (var i = 0; i < 3; i++) {
            rgb[i] = parseInt(rgb[i]) + 40;
        }
        return 'rgba(' + rgb.join(", ") + ')';
    };


})();


/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartTradePanel = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "TradePanel";
        this.drawType = 'auto';
        this.hoverCursor = (this.selected) ? "row-resize" : 'pointer';
        this.moveCursor = (this.selected) ? "row-resize" : 'pointer';
        this.maxPointCount = 1;
        this.hasSettings = true;
        this.controlEnable = false;
        this.storageEnable = false;
        this.settings = {};
        this.positionAbsolute = true;
    };

    inheritPrototype(iChart.Charting.ChartTradePanel, iChart.Charting.ChartElement);

    iChart.Charting.ChartTradePanel.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 1)
        {
            return;
        }

        this.hoverCursor = (this.selected) ? "row-resize" : 'pointer';
        this.moveCursor = (this.selected) ? "row-resize" : 'pointer';

        if (this.settings.autoInit) {

            this.selected = true;
            this.layer.selected = this;

            this.settings.autoInit = false;
        }

        //Отсортируем все панели так, чтобы заселекченная была выше всех
        this.layer.history.sort(function(a, b){
            if (a && a.elementType == 'TradePanel' && a.selected) return 1;
            return -1;
        });

        //Не могу вылечить иначе баг с двумя селектами сразу
        if (this.selected && !this.layer.selected || this.selected && this.id != this.layer.selected.id) {

            this.selected = false;
        }



        coords[0].x = this.layer.area.getXPositionByValue(point);


        //Цена
        var price = (this.markers) ? this.markers[0].y : this.points[0].y;


        //Цвет
        if (this.settings.type == 'limit') {

            this.settings.fillStyle = (jNTChartTrading.order.operation_type < 3) ? '#7cb342' : '#e53935';

        } else if (this.settings.type == 'sl') {

            this.settings.fillStyle = '#e53935';

        } else if (this.settings.type == 'tp') {

            this.settings.fillStyle = '#7cb342';
        }

        this.settings.fillStyle = (this.selected) ? this.settings.fillStyle : 'rgba(238, 238, 238, 0.3)';
        this.settings.fillStyle = (!this.selected && ctx.inHover) ? 'rgba(238, 238, 238, 1)' : this.settings.fillStyle;

        this.settings.textColor = (this.selected) ? "#FFFFFF" : this.layer.chart.chartOptions.labelColor;


        //Преобразуем текст
        this.settings.text = (jNTChartTrading.order.operation_type < 3) ? this.settings.buyText : this.settings.sellText;
        this.settings.price = _s(price, _d(this.settings.min_step));
        this.settings.quantity = _s(this.settings.quantity);

        var percent = (this.settings.price/this.settings.ltp - 1)*100;
        percent = ((percent>0)?'+':'') + _s(percent, 2) + '%';

        this.settings.text = this.settings.text.replace('%quantity%', this.settings.quantity.trim());
        this.settings.text = this.settings.text.replace('%price%', this.settings.price.trim());
        this.settings.text = this.settings.text.replace('%percent%', percent);

        //Есои приказ в стадии отправки, то будет немного иначе выгодяеть
        if (this.settings.sendingOrder) {

            this.settings.text = _t('15808', 'Выставляем новый приказ ...');
            this.settings.fillStyle = "rgba(119,119,119,1)" /*темно серый*/;
            this.settings.textColor = '#ffffff'; /*белый*/
        }


        //Определения координат
        var point = this.layer.chart.areas[0].xSeries[this.layer.chart.areas[0].xSeries.length-this.layer.chart.chartOptions.futureAmount-1];
        this.points[0].x = point * 1000;
        coords[0].x = this.layer.area.getXPositionByValue(point) + 50;

        var color = this.settings.fillStyle;

        if(this.selected || ctx.inHover) {
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.moveTo(0, coords[0].y);
            ctx.lineTo(getElementSize(ctx.canvas).width, coords[0].y);
            ctx.stroke();
            ctx.restore();

        }

        this.drawLable(ctx, color, this.settings.textColor, coords[0].x, coords[0].y, this.settings.text);

        //this.drawTestSegments(ctx);

    };

    iChart.Charting.ChartTradePanel.prototype.drawExtended = function (ctx) {
        if (this.selected) {
            var pointCoords = this.getCoordinates(ctx, this.points);

            if (pointCoords.length < 1) {
                return;
            }

            var label = iChart.formatNumber(this.points[0].y, {
                "decimalPrecision": this.layer.chart.labelPrecision,
                "scale": 0
            });

            this.layer.chart.renderer.drawLable(ctx, this.settings.fillStyle, 0, this.layer.area.innerWidth, pointCoords[0].y, label);

            if (typeof this.markers !== "undefined") {
                var pointCoords = this.getCoordinates(ctx, this.markers);

                var label = iChart.formatNumber(this.markers[0].y, {
                    "decimalPrecision": this.layer.chart.labelPrecision,
                    "scale": 0
                });
                var color = !ctx.inHover ? this.settings.fillStyle : ( typeof this.settings.fillStyleHover != "undefined" ? this.settings.fillStyleHover : iChart.Charting.ChartTradePanel.lightColor(this.settings.fillStyle));
                this.layer.chart.renderer.drawLable(ctx, color, 0, this.layer.area.innerWidth, pointCoords[0].y, label);
            }
        }
    };


    iChart.Charting.ChartTradePanel.prototype.drawLable = function (ctx, fillColor, textColor, x, y, text)
    {

        ctx.save();

        ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        //ctx.fillStyle = fillColor;
        ctx.fillStyle = this.settings.fillStyle;
        ctx.strokeStyle = '#eeeeee';

        ctx.lineWidth="1";

        var width = ctx.measureText(text).width;
        x = x + width;
        ctx.beginPath();
        ctx.moveTo(x-width-5, y+5);
        ctx.lineTo(x-width-5, y-5);
        ctx.quadraticCurveTo(x-width-5, y-10, x-width, y-10);
        ctx.lineTo(x, y-10);
        ctx.lineTo(x+8, y);
        ctx.lineTo(x, y+10);
        ctx.lineTo(x-width, y+10);
        ctx.quadraticCurveTo(x-width-5, y+10, x-width-5, y+5);

        ctx.closePath();
        ctx.save();
        var shadowColor = this.layer.chart.chartOptions.shadowColor;
        if (this.selected) {

            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;

            ctx.fill();

            //Наконечник
            ctx.lineWidth="3";
            ctx.strokeStyle = ctx.fillStyle;
            ctx.beginPath();
            ctx.moveTo(x+10, y-10);
            ctx.lineTo(x+18, y);
            ctx.lineTo(x+10, y+10);
            ctx.moveTo(x+10, y-10);
            ctx.closePath();
            ctx.stroke();



        } else if (ctx.inHover) {

            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            ctx.fill();

        } else {


            ctx.stroke();
        }
        ctx.restore();

        ctx.fillStyle = this.settings.textColor;
        ctx.fillText(text, x-width, y);


        ctx.restore();



    };

    iChart.Charting.ChartTradePanel.prototype.drawPoints = function (ctx, pointCoords) {}

    iChart.Charting.ChartTradePanel.prototype.drawTestSegments = function (ctx) {
        if(typeof this.testContext != 'undefined') {
            ctx.save();
            ctx.beginPath();
            ctx.fillStyle = 'rgba(0,0,0,0.75)';
            for(var i in this.testContext.segments) {
                var c = this.testContext.segments[i];
                ctx.moveTo(c[0].x, c[0].y);
                ctx.lineTo(c[1].x, c[1].y);
                ctx.stroke();
            }
            ctx.closePath();
            ctx.restore();
        }
    };

    iChart.Charting.ChartTradePanel.prototype.setTestSegments = function ()
    {
        if (!this.testContext) return;

        var ctx = this.layer.context;
        ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        var width = ctx.measureText(this.settings.text).width;


        var x = this.layer.area.getXPositionByValue(this.points[0].x / 1000) + width + 50;

        this.testContext.segments = [
            [{ "x": x-width, "y": this.testContext.points[0].y-4}, { "x": x, "y": this.testContext.points[0].y-4}],
            [{ "x": x, "y": this.testContext.points[0].y+4}, { "x": x-width, "y": this.testContext.points[0].y+4}],

        ];
    };

    iChart.Charting.ChartTradePanel.prototype.onDrag  = function (points)
    {
        if(typeof this.settings.restriction == 'function') {
            this.settings.restriction.call(this, points);
        }

        if(typeof this.settings.onDrag == 'function') {
            this.settings.onDrag.call(this, points);
        }
    };

    iChart.Charting.ChartTradePanel.prototype.onSelect = function (ctx) {
        iChart.Charting.ChartElement.prototype.onSelect.call(this, ctx);
        //this.setTestSegments();
    };

    iChart.Charting.ChartTradePanel.prototype.onBlur = function () {
        //this.setTestSegments();
    };

    iChart.Charting.ChartTradePanel.prototype.onDrop = function () {
        if(typeof this.settings.onDrop == 'function') {
            this.settings.onDrop.call(this);
        }
    };


    iChart.Charting.ChartTradePanel.lightColor = function (rgb)
    {
        rgb = rgb.substring(rgb.indexOf('(') + 1, rgb.lastIndexOf(')')).split(/,\s*/);
        for (var i = 0; i < 3; i++) {
            rgb[i] = parseInt(rgb[i]) + 40;
        }
        return 'rgba(' + rgb.join(", ") + ')';
    };

    iChart.Charting.ChartTradePanel.prototype.onMouseDown = function (e) {
        if (typeof this.settings.onSelect == 'function') {
            this.settings.onSelect.call(this, e);
        }
    };


})();


/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartTrendorder = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "Trendorder";
        this.drawType = 'auto';
        this.hoverCursor = "row-resize";
        this.moveCursor = "row-resize";
        this.hoverPointCursor = "move";
        this.movePointCursor = "move";
        this.maxPointCount = 2;
        this.hasSettings = true;
        this.controlEnable = true;
        this.storageEnable = false;
        this.drawSingle = true;
        /**
         * Непроизводить корректировку точек, т.к. элемент находиться под обрабатой внешним методом
         * @type {boolean}
         */
        this.freezed = true;
        this.settings = {
            text: '',
            textHeight: 13,
            fillStyle: '#f44336',
            textColor: '#FFFFFF',
            mode: "line", //trend
        };
        this.positionAbsolute = true;
    };

    inheritPrototype(iChart.Charting.ChartTrendorder, iChart.Charting.ChartElement);

    iChart.Charting.ChartTrendorder.prototype.setSettings = function (settings) {
        this.settings = $.extend(this.settings, settings);

        //points = [{'x':new Date(), 'y':data.price}];
        if(typeof settings.price2 == "undefined") {
            this.points[0] = {x: settings.date, y: settings.price};
            this.points[1] = {x: settings.date, y: settings.price};
        } else {
            this.points[0] = {x: settings.date, y: settings.price};
            this.points[1] = {x: settings.date2, y: settings.price2};

            var coords = this.getFloatCoords();

            this.trendLineSettings = {
                points: this.getBorderPoints(coords)
            };
        }
    };

    /**
     * Расчет удобного положение управляющих точек
     * @param x
     * @param length
     */
    iChart.Charting.ChartTrendorder.prototype.calcPointsPosition = function (x, length) {
        length = length ? length : 150;
        var coords = this.getCoordinates(this.layer.context, this.points);
        var borderPoints = this.getBorderPoints(coords);

        var xCenter = (borderPoints[0].x + borderPoints[1].x) / 2;

        if( x < xCenter) {
            this.points[0].x = this.layer.area.getXValue(x) * 1000;
            var foundPoint = iChart.getLineEquation(this.trendLineSettings.points[0], this.trendLineSettings.points[1], x);
            this.points[0].y = this.layer.area.getYValue(foundPoint.y);

            var foundPoint = iChart.getLineEquation(this.trendLineSettings.points[0], this.trendLineSettings.points[1], xCenter);
            this.points[1].x = this.layer.area.getXValue(xCenter) * 1000;
            this.points[1].y = this.layer.area.getYValue(foundPoint.y);

            var coords = this.getCoordinates(this.layer.context, this.points);

            //Перенос центральной точки, если управляющая слишком близко к ней
            if(Math.sqrt(Math.pow(coords[0].x - coords[1].x, 2) + Math.pow(coords[0].y - coords[1].y, 2)) < length) {

                var alpha = Math.atan((coords[0].y - coords[1].y) / (coords[0].x - coords[1].x));
                var newPx = coords[0].x + (length+5) * Math.cos(alpha);
                var foundPoint = iChart.getLineEquation(this.trendLineSettings.points[0], this.trendLineSettings.points[1], newPx);

                this.points[1].x = this.layer.area.getXValue(newPx) * 1000;
                this.points[1].y = this.layer.area.getYValue(foundPoint.y);
            }

        } else {

            this.points[1].x = this.layer.area.getXValue(x) * 1000;
            var foundPoint = iChart.getLineEquation(this.trendLineSettings.points[0], this.trendLineSettings.points[1], x);
            this.points[1].y = this.layer.area.getYValue(foundPoint.y);

            var foundPoint = iChart.getLineEquation(this.trendLineSettings.points[0], this.trendLineSettings.points[1], xCenter);
            this.points[0].x = this.layer.area.getXValue(xCenter) * 1000;
            this.points[0].y = this.layer.area.getYValue(foundPoint.y);

            var coords = this.getCoordinates(this.layer.context, this.points);

            if(Math.sqrt(Math.pow(coords[0].x - coords[1].x, 2) + Math.pow(coords[0].y - coords[1].y, 2)) < length) {

                var alpha = Math.atan((coords[0].y - coords[1].y) / (coords[0].x - coords[1].x));
                var newPx = coords[1].x - (length+5) * Math.cos(alpha);
                var foundPoint = iChart.getLineEquation(this.trendLineSettings.points[0], this.trendLineSettings.points[1], newPx);

                this.points[0].x = this.layer.area.getXValue(newPx) * 1000;
                this.points[0].y = this.layer.area.getYValue(foundPoint.y);
            }
        }

    };

    /**
     *
     * @param points
     * @returns {*[]}
     */
    iChart.Charting.ChartTrendorder.prototype.getFloatCoords = function (points) {
        points = (typeof points != "undefined") ? points : this.points;
        var coords = [{x:0, y:0},{x:0,y:0}];
        coords[0].x = this.layer.area.getXPositionByValue(points[0].x / 1000);
        coords[0].y = this.layer.area.getYPosition(points[0].y);
        coords[1].x = this.layer.area.getXPositionByValue(points[1].x / 1000);
        coords[1].y = this.layer.area.getYPosition(points[1].y);
        return coords;
    };

    iChart.Charting.ChartTrendorder.prototype.normalizeCoords = function (ctx, coords)
    {
        this.moveForward();
        return this.getCoordinates(ctx, this.points);
    };

    iChart.Charting.ChartTrendorder.prototype.lineNormalizeCoords = function (ctx, coords) {
        var canvasWidth = getElementSize(ctx.canvas).width;

        coords[1].x = canvasWidth - 80;
        this.points[1].x = this.layer.area.getXValue(coords[1].x) * 1000;

        ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        var textWidth = ctx.measureText(this.settings.text).width;

        coords[0].x = canvasWidth - 80 - textWidth - 80;
        this.points[0].x = this.layer.area.getXValue(coords[0].x) * 1000;

    };

    iChart.Charting.ChartTrendorder.prototype.drawLineMode = function (ctx, coords) {

        this.settings.fillStyle = this.settings.fillStyle || "#3AAE3E";

        //var point = this.layer.chart.areas[0].xSeries[this.layer.chart.areas[0].xSeries.length-this.layer.chart.futureAmount-1];
        //this.points[0].x = point * 1000;
        //coords[0].x = this.layer.area.getXPositionByValue(point);

        var color = this.settings.fillStyle;
        var canvasWidth = getElementSize(ctx.canvas).width;

        if(this.selected || ctx.inHover) {
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.moveTo(0, coords[0].y);
            ctx.lineTo(canvasWidth, coords[0].y);
            ctx.stroke();
            ctx.restore();

            this.drawLable(ctx, color, this.settings.textColor, coords[0].x, coords[0].y, this.settings.text);

            if(this.selected) {
                this.drawPoint(ctx, coords[0].x, coords[0].y, color, 4);
                this.drawPoint(ctx, coords[1].x, coords[1].y, color, 4);
            }
        } else {
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.beginPath();
            //for (var x = coords[0].x; x <= canvasWidth; x += 20)
            for (var x = 0; x <= canvasWidth; x += 20)
            {
                ctx.moveTo(x, coords[0].y);
                ctx.lineTo(x + 12, coords[0].y);
            }
            ctx.stroke();
            ctx.restore();
        }
    };

    /**
     * Время и координата первой точки условия приказа
     * @returns {{time: *, x}}
     */
    iChart.Charting.ChartTrendorder.prototype.getOpenOrderData = function () {
        var openTime = this.layer.chart.areas[0].xSeries[this.layer.chart.areas[0].xSeries.length - this.layer.chart.chartOptions.futureAmount - 1];
        var openX = this.layer.area.getXPositionByValue(openTime);

        return {time: openTime, x: openX};
    };

    /**
     * Время и координата второй точки условия приказа
     * @returns {{time: Date, x}}
     */
    iChart.Charting.ChartTrendorder.prototype.getExpireOrderData = function () {
        var openOrder = this.getOpenOrderData();
        var expireTime = new Date((openOrder.time + this.layer.chart.env.dataSource.dataSettings.timeframe * 60) *  1000);

        var expireX = this.layer.area.getXPositionByValue(expireTime / 1000);

        return {time: expireTime, x: expireX};
    };


    /**
     *
     * @param coords {[{x:,y:},{x,y}]}
     * @returns {{x, y, k, b}}
     */
    iChart.Charting.ChartTrendorder.prototype.getOpenCoords = function (coords) {
        var openOrder = this.getOpenOrderData();
        return iChart.getLineEquation(coords[0], coords[1], openOrder.x);
    };

    /**
     *
     * @param coords
     * @returns {{x, y, k, b}}
     */
    iChart.Charting.ChartTrendorder.prototype.getExpireCoords = function (coords) {
        var expireOrder = this.getExpireOrderData();
        return iChart.getLineEquation(coords[0], coords[1], expireOrder.x);
    };

    /**
     * Получение параметров для приказа
     * @param ctx
     * @param coords
     */
    iChart.Charting.ChartTrendorder.prototype.getOrderParams = function (coords) {

        var foundOpenCoords = this.getOpenCoords(coords);
        var foundExpireCoords = this.getExpireCoords(coords);

        var newOrderParams = {
            points: [
                {x: this.layer.area.getXValue(foundOpenCoords.x) * 1000, y: this.layer.area.getYValue(foundOpenCoords.y)},
                {x: this.layer.area.getXValue(foundExpireCoords.x) * 1000, y: this.layer.area.getYValue(foundExpireCoords.y)}
            ]
        };

        return newOrderParams;
    };

    /**
     * Получить координаты точке пересечение прямой с границами экрана
     * @param coords
     * @returns {*[]}
     */
    iChart.Charting.ChartTrendorder.prototype.getBorderPoints = function (coords) {
        var canvasSize = getElementSize(this.layer.canvas);

        if(coords[0].y < 0 || coords[0].y > canvasSize.height || coords[0].x < 0 || coords[0].x >canvasSize.width) {

            var foundPoint1 = iChart.getLineEquation(coords[0], coords[1], 0);
            var foundPoint2 = iChart.getLineEquation(coords[0], coords[1], canvasSize.width);

        } else {

            var foundPoint1 = iChart.getLineEquation(coords[0], coords[1], 0);
            if (foundPoint1.y < 0) {
                foundPoint1.y = 0;
                foundPoint1.x = (foundPoint1.y - foundPoint1.b) / foundPoint1.k;
            } else if (foundPoint1.y > canvasSize.height) {
                foundPoint1.y = canvasSize.height;
                foundPoint1.x = (foundPoint1.y - foundPoint1.b) / foundPoint1.k;
            }

            var foundPoint2 = iChart.getLineEquation(coords[0], coords[1], canvasSize.width);
            if(foundPoint2.y < 0 ) {
                foundPoint2.y = 0;
                foundPoint2.x = (foundPoint2.y - foundPoint2.b) / foundPoint2.k;
            } else if(foundPoint2.y > canvasSize.height) {
                foundPoint2.y = getElementSize(this.layer.canvas).height;
                foundPoint2.x = (foundPoint2.y - foundPoint2.b) / foundPoint2.k;
            }
        }

        return [foundPoint1, foundPoint2];
    };

    /**
     * Рендер в режиме наклонной прямой
     * @param ctx
     * @param coords
     */
    iChart.Charting.ChartTrendorder.prototype.drawTrendMode = function (ctx, coords) {

        if (typeof this.markers !== "undefined")
        {
            var points = this.markers;

        } else {
            if(!this.selected && !this.freezed) {
                console.trace();
                this.moveForward();
            }
            var points = this.points;
        }

        this.trendLineSettings = {
            points: this.getBorderPoints(this.getFloatCoords(points))
        };

        var foundOpenCoords = this.getOpenCoords(coords);

        ctx.save();
        ctx.beginPath();

        ctx.setLineDash([8, 3]);
        var color = this.settings.fillStyle;
        ctx.strokeStyle = color;

        ctx.moveTo(foundOpenCoords.x, foundOpenCoords.y);
        ctx.lineTo(this.trendLineSettings.points[0].x, this.trendLineSettings.points[0].y);

        ctx.stroke();

        ctx.restore();


        ctx.save();
        ctx.lineWidth = 4;
        ctx.strokeStyle = this.settings.fillStyle;
        ctx.beginPath();
        ctx.moveTo(foundOpenCoords.x, foundOpenCoords.y);
        ctx.lineTo(this.trendLineSettings.points[1].x, this.trendLineSettings.points[1].y);
        ctx.stroke();
        ctx.restore();

        this.settings.newOrderParams = this.getOrderParams(coords);

        if(this.selected) {
            this.drawPoint(ctx, coords[0].x, coords[0].y, color, 4);
            this.drawPoint(ctx, coords[1].x, coords[1].y, color, 4);
            this.drawLableTrend(ctx, coords);
        } else if (ctx.inHover) {
            this.drawLableTrend(ctx, coords);
        }

        /*
        var point = this.layer.chart.areas[0].xSeries[this.layer.chart.areas[0].xSeries.length - this.layer.chart.chartOptions.futureAmount - 1];
        var lastX = this.layer.area.getXPositionByValue(point);
        var foundCoords = iChart.getLineEquation(coords[0], coords[1], lastX);

         var linePoints = [points[0]];
         linePoints[1] = {x: this.layer.area.getXValue(foundCoords.x) * 1000, y:this.layer.area.getYValue(foundCoords.y)};

         ctx.save();
         ctx.beginPath();
         ctx.strokeStyle = '#66FF66';
         ctx.setLineDash([8, 3]);
         var step = Math.round(Math.abs(linePoints[1].x - linePoints[0].x) / 150);
         var foundBaseCoords = this.getCoordinates(ctx, linePoints);
         foundPoint = iChart.getLineEquation(linePoints[1], points[1], linePoints[0].x);
         foundCoords = this.getCoordinates(ctx, [foundPoint]);
         ctx.moveTo(foundCoords[0].x, foundCoords[0].y);
         for(var i=Math.min(linePoints[0].x, linePoints[1].x); i <= Math.max(linePoints[0].x, linePoints[1].x); i+=step) {
             var foundPoint = iChart.getLineEquation(linePoints[1], points[1], i);
             foundCoords = this.getCoordinates(ctx, [foundPoint]);
             ctx.lineTo(foundCoords[0].x, foundCoords[0].y);
             this.drawPoint(ctx, foundCoords[0].x, foundCoords[0].y, '#FF6666');
         }

         //ctx.lineTo(foundBaseCoords[1].x, foundBaseCoords[1].y);
         ctx.stroke();
         ctx.restore();
        */

        //this.pointsForward(ctx);
        //this.pointsBack(ctx);

    };

    /**
     * Расчет значения y на прямой с учем пропуска интервалов
     * @param {float} x - timestamp ms
     * @returns {float}
     */
    iChart.Charting.ChartTrendorder.prototype.findYForward = function (x) {
        var startIndex = iChart.Charting.indexOfFirstElementGreaterThanOrEqualTo(this.layer.chart.areas[0].xSeries, this.settings.date / 1000);
        var endIndex = this.layer.area.getXIndexByValue(x / 1000);

        var timeframe = this.layer.chart.env.dataSource.dataSettings.timeframe * 60;
        var basePoint1 = {x:this.settings.date, y: this.settings.price},
            basePoint2 = {x: this.settings.date2, y: this.settings.price2};


        var correction = 0;
        for(var i = startIndex+1; i <= endIndex; i++) {
            var dt = this.layer.chart.areas[0].xSeries[i] - this.layer.chart.areas[0].xSeries[i - 1];
            if(dt / timeframe > 1) {
                var foundPoint1 = iChart.getLineEquation(basePoint1, basePoint2, this.layer.chart.areas[0].xSeries[i-1] * 1000);
                var foundPoint2 = iChart.getLineEquation(basePoint1, basePoint2, (this.layer.chart.areas[0].xSeries[i-1] + dt - timeframe) * 1000);
                correction += foundPoint1.y - foundPoint2.y;
            }
        }

        var foundPoint = iChart.getLineEquation(basePoint1, basePoint2, x);
        var y = foundPoint.y + correction;

        return y;
    };

    /**
     * Скорректировать прямую с учетом пропусков свечей
     */
    iChart.Charting.ChartTrendorder.prototype.moveForward = function () {
        if(this.points[1].x < $.now()) {
            this.points[1].x = $.now();
            this.points[1].y = this.findYForward(this.points[1].x);
        }
    };

    iChart.Charting.ChartTrendorder.prototype.pointsForward = function (ctx) {
        var startIndex = iChart.Charting.indexOfFirstElementGreaterThanOrEqualTo(this.layer.chart.areas[0].xSeries, this.settings.date / 1000);
        var endIndex = this.layer.chart.areas[0].xSeries.length - 1;

        var timeframe = this.layer.chart.env.dataSource.dataSettings.timeframe * 60;
        var basePoint1 = {x:this.settings.date, y: this.settings.price},
            basePoint2 = {x: this.settings.date2, y: this.settings.price2};

        for(var i = startIndex; i <= endIndex; i++) {
            var foundPoint = iChart.getLineEquation(basePoint1, basePoint2, this.layer.chart.areas[0].xSeries[i] * 1000);
            var x = this.layer.area.getXPositionByValue(foundPoint.x / 1000);
            var y = this.layer.area.getYPosition(foundPoint.y);
            this.drawPoint(ctx, x, y, 'rgba(255,100,100, 0.3)',4);
        }

        var correction = 0;
        for(var i = startIndex+1; i <= endIndex; i++) {
            var dt = this.layer.chart.areas[0].xSeries[i] - this.layer.chart.areas[0].xSeries[i - 1];
            if(dt / timeframe > 1) {
                var foundPoint1 = iChart.getLineEquation(basePoint1, basePoint2, this.layer.chart.areas[0].xSeries[i-1] * 1000);
                var foundPoint2 = iChart.getLineEquation(basePoint1, basePoint2, (this.layer.chart.areas[0].xSeries[i-1] + dt - timeframe) * 1000);
                correction += foundPoint1.y - foundPoint2.y;
            }

            var foundPoint = iChart.getLineEquation(basePoint1, basePoint2, this.layer.chart.areas[0].xSeries[i] * 1000);
            var x = this.layer.area.getXPositionByValue(foundPoint.x / 1000);
            var y = this.layer.area.getYPosition(foundPoint.y + correction);

            this.drawPoint(ctx, x, y, '#66FF66', 3);
        }
    };


    iChart.Charting.ChartTrendorder.prototype.pointsBack = function (ctx) {
        //var startIndex = iChart.Charting.indexOfLastElementLessThanOrEqualTo(this.layer.chart.areas[0].xSeries, this.settings.date / 1000);
        var startIndex = this.layer.chart.areas[0].xSeries.length - 2;
        var endIndex = this.layer.chart.areas[0].viewport.x.min;

        var timeframe = this.layer.chart.env.dataSource.dataSettings.timeframe * 60;
        var basePoint1 = {x:this.settings.date, y: this.settings.price},
            basePoint2 = {x: this.settings.date2, y: this.settings.price2};

        /*
        for(var i = startIndex; i > endIndex; i--) {
            var foundPoint = iChart.getLineEquation(basePoint1, basePoint2, this.layer.chart.areas[0].xSeries[i] * 1000);
            var x = this.layer.area.getXPositionByValue(foundPoint.x / 1000);
            var y = this.layer.area.getYPosition(foundPoint.y);
            this.drawPoint(ctx, x, y, '#FF6666', 4);
        }*/

        var correction = 0;
        for(var i = startIndex; i > endIndex; i--) {

            var dt = this.layer.chart.areas[0].xSeries[i+1] - this.layer.chart.areas[0].xSeries[i];
            if(dt / timeframe > 1) {

                 //выставлялось на дневном смотрим на
                if(1) {
                    if(dt / 86400 > 1) {
                        dt = dt - dt % 86400;
                        //dt = dt % 86400;
                    }
                }


                var foundPoint1 = iChart.getLineEquation(basePoint1, basePoint2, this.layer.chart.areas[0].xSeries[i-1] * 1000);
                var foundPoint2 = iChart.getLineEquation(basePoint1, basePoint2, (this.layer.chart.areas[0].xSeries[i-1] + dt - timeframe) * 1000);
                correction += foundPoint2.y - foundPoint1.y;
            }

            var foundPoint = iChart.getLineEquation(basePoint1, basePoint2, this.layer.chart.areas[0].xSeries[i] * 1000);
            var x = this.layer.area.getXPositionByValue(foundPoint.x / 1000);
            var y = this.layer.area.getYPosition(foundPoint.y + correction);
            this.drawPoint(ctx, x, y, '#66FF66');
        }
    };

    iChart.Charting.ChartTrendorder.prototype.drawInternal = function (ctx, coords)
    {
        //this.normalizeCoords(coords);
        if (coords.length < 2)
        {
            return;
        }


        if(this.settings.mode == 'line') {

            this.lineNormalizeCoords(ctx, coords);
            this.drawLineMode(ctx, coords);

        } else {
            var toCalc = false;
            if(!this.settings.newOrderParams) {
                coords = this.normalizeCoords(ctx, coords);
                toCalc = true;
            }
            this.drawTrendMode(ctx, coords);

            if(toCalc) {
                this.calcPointsPosition(coords[1].x, 150);
            }
        }

    };

    iChart.Charting.ChartTrendorder.prototype.drawPoint = function (ctx, x, y, color, r) {
        ctx.save();
        ctx.beginPath();

        ctx.lineWidth = 1;
        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        r = r || 2;
        ctx.arc(x, y, r, 0, 2 * Math.PI, true);
        ctx.closePath();

        ctx.fill();
        ctx.restore();

    };

    iChart.Charting.ChartTrendorder.prototype.drawExtended = function (ctx) {
        if (this.selected) {
            var pointCoords = this.getCoordinates(ctx, this.points);

            if (pointCoords.length < 1) {
                return;
            }

            var label = iChart.formatNumber(this.points[0].y, {
                "decimalPrecision": this.layer.chart.labelPrecision,
                "scale": 0
            });

            this.layer.chart.renderer.drawLable(ctx, this.settings.fillStyle, 0, this.layer.area.innerWidth, pointCoords[0].y, label);

            if (typeof this.markers !== "undefined") {
                var pointCoords = this.getCoordinates(ctx, this.markers);

                var label = iChart.formatNumber(this.markers[0].y, {
                    "decimalPrecision": this.layer.chart.labelPrecision,
                    "scale": 0
                });
                var color = !ctx.inHover ? this.settings.fillStyle : ( typeof this.settings.fillStyleHover != "undefined" ? this.settings.fillStyleHover : iChart.Charting.ChartTrendorder.lightColor(this.settings.fillStyle));
                this.layer.chart.renderer.drawLable(ctx, color, 0, this.layer.area.innerWidth, pointCoords[0].y, label);
            }
        }
    };

    iChart.Charting.ChartTrendorder.prototype.drawLable = function (ctx, fillColor, textColor, x, y, text)
    {
        fillColor = fillColor ? fillColor : "#333333";
        textColor = textColor ? textColor : "#FFFFFF";

        ctx.save();

        ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";

        ctx.fillStyle = fillColor;

        ctx.lineWidth="2";

        var textWidth = ctx.measureText(text).width;

        var width = textWidth + 5;
        var x = getElementSize(ctx.canvas).width - 120;
        ctx.beginPath();
        ctx.moveTo(x-width-5, y+5);
        ctx.lineTo(x-width-5, y-5);
        ctx.quadraticCurveTo(x-width-5, y-10, x-width, y-10);
        ctx.lineTo(x, y-10);
        ctx.quadraticCurveTo(x+5, y-10, x+5, y-5);
        ctx.lineTo(x+5, y+5);
        ctx.quadraticCurveTo(x+5, y+10, x, y+10);
        ctx.lineTo(x-width, y+10);
        ctx.quadraticCurveTo(x-width-5, y+10, x-width-5, y+5);


        ctx.closePath();


        ctx.save();
        var shadowColor = this.layer.chart.chartOptions.shadowColor;
        if (this.selected) {

            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 15;
            ctx.shadowOffsetY = 15;

        } else if (ctx.inHover) {

            ctx.shadowColor = shadowColor;
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;

        }
        ctx.restore();
        ctx.fill();


        this.drawCancelButton(ctx, x, y-10);

        ctx.fillStyle = textColor;
        ctx.fillText(text, x-width, y);


        ctx.restore();

    };

    iChart.Charting.ChartTrendorder.prototype.drawLableTrend = function (ctx, coords) {

        var text = this.settings.text,
            textColor = this.settings.textColor,
            textHeight = this.settings.textHeight,
            h = textHeight * 1.2,
            center = {
                x: (coords[0].x + coords[1].x) / 2,
                y: (coords[0].y + coords[1].y) / 2
            },
            labelCoords = {
                center: {x: '', y: ''},
                left: {x: '', y: ''},
                right: {x: '', y: ''}
            },
            alpha = Math.atan((coords[0].y - coords[1].y) / (coords[0].x - coords[1].x));

        ctx.save();
        ctx.font = 'normal ' + textHeight + 'px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.lineWidth = "1";
        var textWidth = ctx.measureText(text).width;
        ctx.restore();

        labelCoords.center.x = center.x - h * Math.cos(Math.PI / 2 + alpha);
        labelCoords.center.y = center.y - h * Math.sin(Math.PI / 2 + alpha);
        labelCoords.left.x = labelCoords.center.x - textWidth / 2 * Math.cos(alpha);
        labelCoords.left.y = labelCoords.center.y - textWidth / 2 * Math.sin(alpha);
        labelCoords.right.x = labelCoords.center.x + (textWidth / 2 + 20) * Math.cos(alpha);
        labelCoords.right.y = labelCoords.center.y + (textWidth / 2 + 20) * Math.sin(alpha);

        this.trendLabelSettings = {
            alpha: alpha,
            labelCoords: labelCoords
        };

        ctx.save();

        ctx.font = 'normal ' + textHeight + 'px Arial,Helvetica,sans-serif';
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.lineWidth = "1";

        ctx.strokeStyle = this.settings.fillStyle;
        ctx.fillStyle = this.settings.fillStyle;

        var textHeight2 = Math.round(textHeight / 2);
        var x = 0, y = 0, padding = 3;

        ctx.translate( labelCoords.left.x, labelCoords.left.y);
        ctx.rotate(alpha);

        ctx.beginPath();
        ctx.moveTo(x - padding, y + textHeight2);
        ctx.lineTo(x - padding, y - textHeight2);
        ctx.quadraticCurveTo(x - padding, y - textHeight2 - padding, x, y - textHeight2 - padding);
        ctx.lineTo(x + textWidth, y - textHeight2 - padding);
        ctx.quadraticCurveTo(x + textWidth + padding, y - textHeight2 - padding, x + textWidth + padding, y - textHeight2);
        ctx.lineTo(x + textWidth + padding, y + textHeight2);
        ctx.quadraticCurveTo(x + textWidth + padding, y + textHeight2 + padding, x + textWidth, y + textHeight2 + padding);
        ctx.lineTo(x, y + textHeight2 + padding);
        ctx.quadraticCurveTo(x - padding, y + textHeight2 + padding, x - padding, y + textHeight2);
        ctx.closePath();
        ctx.fill();
        //ctx.stroke();

        ctx.fillStyle = textColor;
        ctx.fillText(text, x, y);

        this.drawCancelButton(ctx, x + textWidth + 3, y - textHeight2 - padding);

        ctx.restore();

/*
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = '#0000FF';
        ctx.arc(center.x, center.y, 5, 0, 2 * Math.PI, true);
        ctx.fill();
        ctx.closePath();

        ctx.beginPath();
        ctx.arc(labelCoords.center.x, labelCoords.center.y, 5, 0, 2 * Math.PI, true);
        ctx.fill();
        ctx.closePath();

        ctx.beginPath();
        ctx.arc(labelCoords.left.x, labelCoords.left.y, 5, 0, 2 * Math.PI, true);
        ctx.fill();
        ctx.closePath();

        ctx.beginPath();
        ctx.arc(labelCoords.right.x, labelCoords.right.y, 5, 0, 2 * Math.PI, true);
        ctx.fill();
        ctx.closePath();

        ctx.restore();
*/

    };

    iChart.Charting.ChartTrendorder.prototype.drawCancelButton = function (ctx, x, y) {

        ctx.beginPath();
        ctx.moveTo(x, y);

        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 2;

        ctx.lineTo(x, y+20);
        ctx.stroke();

        ctx.lineTo(x+15, y+20);
        ctx.quadraticCurveTo(x+20, y+20, x+20, y+15);
        ctx.lineTo(x+20, y+5);
        ctx.quadraticCurveTo(x+20, y, x+15, y);
        ctx.closePath();

        ctx.fillStyle = '#e53935';
        ctx.fill();


        //Рисуем крестик
        ctx.beginPath();
        ctx.moveTo(x+5, y+5);
        ctx.lineTo(x+15, y+15);
        ctx.moveTo(x+5, y+15);
        ctx.lineTo(x+15, y+5);
        ctx.stroke();
        ctx.closePath();
    };


    iChart.Charting.ChartTrendorder.prototype.drawPoints = function (ctx, pointCoords) {
        //console.log(pointCoords);

        if(!this.selected) {
            return 0;
        }

        function drawArrows (ctx, x, y, radius, alpha, right) {
            var x = x + (right ? -1 : 1) * radius * Math.cos(alpha),
                y = y + (right ? -1 : 1) * radius * Math.sin(alpha),
                h = 10,
                beta;

            ctx.lineWidth = 1;

            var angleStart = right ? (-0.2 * Math.PI + alpha) : (0.8 * Math.PI + alpha),
                angleEnd = right ? (0.2 * Math.PI + alpha) : (1.2 * Math.PI + alpha),
                angleBase = right ? (0 * Math.PI + alpha) : (1 * Math.PI + alpha),
                x1 = x + (right ? -1 : 1) * h * Math.cos(Math.PI / 2 + alpha),
                y1 = y + (right ? -1 : 1) * h * Math.sin(Math.PI / 2 + alpha),
                x2 = x + (right ? 1 : -1) * h * Math.cos(Math.PI / 2 + alpha),
                y2 = y + (right ? 1 : -1) * h * Math.sin(Math.PI / 2 + alpha);

            ctx.beginPath();
            ctx.arc(x1, y1, radius, angleStart, angleBase);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(x2, y2, radius, angleBase, angleEnd);
            ctx.stroke();

            var ax = x1 + radius * Math.cos(angleStart),
                ay = y1 + radius * Math.sin(angleStart),
                beta = (angleStart) + Math.PI / 16,
                ax1 = x1 + radius * 0.9 * Math.cos(beta),
                ay1 = y1 + radius * 0.9 * Math.sin(beta),
                ax2 = x1 + radius * 1.1 * Math.cos(beta),
                ay2 = y1 + radius * 1.1 * Math.sin(beta);

            ctx.beginPath();
            ctx.moveTo(ax1, ay1);
            ctx.lineTo(ax, ay);
            ctx.lineTo(ax2, ay2);

            var ax = x2 + radius * Math.cos(angleEnd),
                ay = y2 + radius * Math.sin(angleEnd),
                beta = angleEnd - Math.PI / 16,
                ax1 = x2 + radius * 0.9 * Math.cos(beta),
                ay1 = y2 + radius * 0.9 * Math.sin(beta),
                ax2 = x2 + radius * 1.1 * Math.cos(beta),
                ay2 = y2 + radius * 1.1 * Math.sin(beta);

            ctx.moveTo(ax1, ay1);
            ctx.lineTo(ax, ay);
            ctx.lineTo(ax2, ay2);

            ctx.stroke();
        }

        var alpha = Math.atan((pointCoords[0].y - pointCoords[1].y) / (pointCoords[0].x - pointCoords[1].x)),
            radius = 30;

        ctx.save();

        ctx.strokeStyle = this.settings.fillStyle;
        ctx.fillStyle = this.settings.fillStyle;

        drawArrows(ctx, pointCoords[0].x, pointCoords[0].y, radius, alpha, false);
        drawArrows(ctx, pointCoords[1].x, pointCoords[1].y, radius, alpha, true);

        ctx.restore();
    };


    iChart.Charting.ChartTrendorder.prototype.setTestSegments = function ()
    {
        if(this.settings.mode == 'line') {
            if (this.selected) {
                var ctx = this.layer.context;
                ctx.font = 'normal 13px Arial,Helvetica,sans-serif';
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
                var width = ctx.measureText(this.settings.text).width;
                var x = getElementSize(ctx.canvas).width - 120;
                this.testContext.segments = [
                    [{ "x": x-width, "y": this.testContext.points[0].y-4}, { "x": x, "y": this.testContext.points[0].y-4}],
                    [{ "x": x-width, "y": this.testContext.points[0].y+4}, { "x": x, "y": this.testContext.points[0].y+4}],
                    [{"x": this.layer.area.innerOffset.left, "y": this.testContext.points[0].y},{"x": this.layer.area.innerOffset.left + this.layer.area.innerWidth,"y": this.testContext.points[0].y}]
                ];
            } else {
                if(this.testContext) {
                    this.testContext.segments = [
                        [{
                            "x": this.layer.area.innerOffset.left,
                            "y": this.testContext.points[0].y
                        }, {
                            "x": this.layer.area.innerOffset.left + this.layer.area.innerWidth,
                            "y": this.testContext.points[0].y
                        }]
                    ];
                }
            }
        } else {
            this.testContext.segments = [];

                this.testContext.segments = [
                    [{ "x": this.trendLineSettings.points[0].x, "y": this.trendLineSettings.points[0].y}, { "x": this.trendLineSettings.points[1].x, "y": this.trendLineSettings.points[1].y}]
                ];

            if(this.trendLabelSettings) {
                this.testContext.segments.push([{ "x": this.trendLabelSettings.labelCoords.left.x, "y": this.trendLabelSettings.labelCoords.left.y}, { "x": this.trendLabelSettings.labelCoords.right.x, "y": this.trendLabelSettings.labelCoords.right.y}]);
            }

        }
    };


    iChart.Charting.ChartTrendorder.prototype.onDrag  = function (points)
    {

        if(!points[0] || !points[1]) {
            return false;
        }

        if(this.settings.mode == 'line') {
            if (points[0].y != this.points[0].y && this.points[1].y == points[1].y || points[0].y == this.points[0].y && this.points[1].y != points[1].y) {
                this.settings.mode = 'trend';
                this.settings.date2 = new Date(points[1].x);
                this.settings.price2 = this.points[1].y;
                var coords = this.getCoordinates(this.layer.context, points);
                this.settings.newOrderParams = this.getOrderParams(coords);
            }
        } else {

        }

        var minDiff = (this.layer.area.getXValue(1) - this.layer.area.getXValue(0)) * 1000;

        if (this.points[0].x != points[0].x && points[0].x >= points[1].x - minDiff) {
            points[0].x = points[1].x - minDiff;
        } else if (this.points[1].x != points[1].x && points[1].x <= points[0].x + minDiff) {
            points[1].x = points[0].x + minDiff;
        }

        if(typeof this.settings.restriction == 'function') {
            this.settings.restriction.call(this, points);
        }

    };
    iChart.Charting.ChartTrendorder.prototype.onSelect = function (ctx) {
        //console.log('onSelect', this);
        iChart.Charting.ChartElement.prototype.onSelect.call(this, ctx);
        this.getTestContext(true);
    };

    iChart.Charting.ChartTrendorder.prototype.onBlur = function () {
        //console.log('onBlur', this);
        if(this.settings.mode == 'trend') {
            //this.normalizeCoords(this.getCoordinates(this.layer.context, this.points));
        }
        this.getTestContext(true);
    };

    iChart.Charting.ChartTrendorder.prototype.onDrop = function () {
        //console.log('onDrop', this);
        if(this.settings.mode == 'trend') {
            console.log('newOrderParams', this.settings.newOrderParams);
        }

        if(typeof this.settings.onDrop == 'function') {
            this.settings.onDrop.call(this);
        }
    };

    iChart.Charting.ChartTrendorder.prototype.onHover = function (x, y) {
        //console.log('onHover', this);
        clearTimeout(this.layer.chart.env.timers.orderClose);
        this.cancelControl(1);
    };

    iChart.Charting.ChartTrendorder.prototype.onOut = function () {
        //console.log('onOut', this);
        clearTimeout(this.layer.chart.env.timers.orderClose);
        var self = this;
        this.layer.chart.env.timers.orderClose = setTimeout(function(){self.cancelControl(0);}, 300);
    };

    iChart.Charting.ChartTrendorder.prototype.cancelControl = function (state) {
        if(typeof this.settings.onCancel == 'function') {
            if(state) {
                $('#ichartOrderCancelCtrl').hide();
                var ctx = this.layer.context;
                var x = getElementSize(ctx.canvas).width - 120;
                var pointCoords = this.getCoordinates(ctx, this.points);
                if(!$('#ichartOrderCancelCtrl').length) {
                    $("<span/>", { id:'ichartOrderCancelCtrl', "style": "color:transparent", "class": "m-chart-instrument-delete", "text": "✕", "title": _t('2958', 'Снять') }).hide().appendTo(this.layer.chart.container);
                }

                var self = this;
                $('#ichartOrderCancelCtrl').unbind('click').bind('click', function(e) {
                    if(typeof self.settings.onCancel == 'function') {

                        self.settings.onCancel.call(self);

                    }
                    $('#ichartOrderCancelCtrl').hide();
                }).bind('mouseover', function () {
                    clearTimeout(self.layer.chart.env.timers.orderClose);
                }).bind('mouseleave', function () {
                    clearTimeout(self.layer.chart.env.timers.orderClose);
                    self.layer.chart.env.timers.orderClose = setTimeout(function(){self.cancelControl(0);}, 1000);
                });

                if(this.settings.mode == 'line') {
                    var top = pointCoords[0].y - 8;
                    var left = x + 2;
                } else {
                    if(this.trendLabelSettings) {
                        var top = this.trendLabelSettings.labelCoords.right.y - 10 - 10 * Math.sin(this.trendLabelSettings.alpha);
                        var left = this.trendLabelSettings.labelCoords.right.x - 10  - 10 * Math.cos(this.trendLabelSettings.alpha);
                    }
                }

                $('#ichartOrderCancelCtrl').css({top: top, left: left}).show();
            } else {
                $('#ichartOrderCancelCtrl').hide();
            }
        }
    };

    iChart.Charting.ChartTrendorder.prototype.onMouseDown = function (e, x ,y) {
        //console.log('onMouseDown', arguments, this);
        if(this.settings.mode == 'trend' && !this.selected) {

            this.calcPointsPosition(x, 150);
        }

        if (typeof this.settings.onSelect == 'function') {
            this.settings.onSelect.call(this, e);
        }
    };


    iChart.Charting.ChartTrendorder.lightColor = function (rgb)
    {
        //rgb = rgb.substring(rgb.indexOf('(') + 1, rgb.lastIndexOf(')')).split(/,\s*/);
        //for (var i = 0; i < 3; i++) {
        //    rgb[i] = parseInt(rgb[i]) + 40;
        //}
        //return 'rgba(' + rgb.join(", ") + ')';

    };


})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ()
{
    "use strict";

    iChart.Charting.ChartHorizontalRange = function (layer)
    {
        iChart.Charting.ChartElement.prototype.constructor.call(this, layer);

        this.elementType = "HorizontalRange";
        this.drawType = 'manually';
        this.maxPointCount = 2;
        this.hasSettings = true;
        this.settings = $.extend({}, layer.chart.env.userSettings.chartSettings.contextSettings);
    };

    inheritPrototype(iChart.Charting.ChartHorizontalRange, iChart.Charting.ChartElement);

    iChart.Charting.ChartHorizontalRange.prototype.drawInternal = function (ctx, coords)
    {
        if (coords.length < 2)
        {
            return;
        }

        var canvasWidth = getElementSize(ctx.canvas).width;
        var point = this.layer.area.getXValue(canvasWidth - 200);
        this.points[0].x = point * 1000;
        coords[0].x = canvasWidth - 200;
        this.points[1].x = point * 1000;
        coords[1].x = canvasWidth - 200;

        ctx.save();
        ctx.beginPath();
        this.initDrawSettings(ctx, this.settings);

        ctx.moveTo(0, coords[0].y);
        ctx.lineTo(canvasWidth, coords[0].y);
        ctx.stroke();
        ctx.moveTo(0, coords[1].y);
        ctx.lineTo(canvasWidth, coords[1].y);
        ctx.stroke();

        ctx.moveTo(0, coords[0].y);
        ctx.lineTo(canvasWidth, coords[0].y);
        ctx.lineTo(canvasWidth, coords[1].y);
        ctx.lineTo(0, coords[1].y);
        ctx.lineTo(0, coords[0].y);
        ctx.fill();

        ctx.restore();

    };

    iChart.Charting.ChartHorizontalRange.prototype.drawExtended = function (ctx)
    {
        if(this.settings.drawLabel) {
            var pointCoords = this.getCoordinates(ctx, this.points);

            if (pointCoords.length < 2) {
                return;
            }
            var settings = this.settings;
            var label = this.layer.chart.renderer.formatNumber(this.layer.area.getYValue(pointCoords[0].y), {
                "decimalPrecision": this.layer.chart.labelPrecision,
                "scale": 0
            });
            this.layer.chart.renderer.drawLable(ctx, settings.strokeStyle, 0, this.layer.area.innerWidth, pointCoords[0].y, label);
        }
    };

    iChart.Charting.ChartHorizontalRange.prototype.setTestSegments = function ()
    {
        this.testContext.segments = [
            [
                { "x": this.layer.area.innerOffset.left, "y": this.testContext.points[0].y },
                { "x": this.layer.area.innerOffset.left + this.layer.area.innerWidth, "y": this.testContext.points[0].y }
            ],
            [
                { "x": this.layer.area.innerOffset.left, "y": this.testContext.points[1].y },
                { "x": this.layer.area.innerOffset.left + this.layer.area.innerWidth, "y": this.testContext.points[1].y }
            ]
        ];
    };
})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */


(function ($)
{
    "use strict";

    iChart.Charting.Crosshair = function (settings)
    {
        /// <summary>
        /// Initializes a new instance of the iChart.Charting.Crosshair class attached to the specified chart.
        /// </summary>
        /// <param name="settings" type="Object">Object containing crosshair settings.</param>
        /// <field name="$chart" type="jQuery">Chart container jQuery object.</field>
        /// <field name="areas">A list of chart areas.</field>
        /// <field name="dots">A collection of dots used for highlighting data points.</field>
        /// <field name="hidden" type="Boolean">A value indicating whether the crosshair is currently hidden.</field>
        /// <field name="pageX">Latest known X cursor coordinate.</field>
        /// <field name="pageY">Latest known Y cursor coordinate.</field>
        /// <field name="pointMap">Data point map used for finding the point clossest to the current cursor position.</field>
        /// <field name="yLabel">Latest displayed Y label.</field>

        this.$chart = settings.$chart;
        this.container = null;
        this.areas = null;
        this.dots = null;
        this.hidden = true;
        this.pageX = null;
        this.pageY = null;
        this.pointMap = undefined;
        this.yLabel = null;
    };

    iChart.Charting.Crosshair.prototype.hide = function ()
    {
        /// <summary>
        /// Hides all crosshair elements.
        /// </summary>

        if (this.hidden)
        {
            return;
        }

        for (var i = 0; i < this.dots.length; ++i)
        {
            this.dots[i].style.display = "none";
        }

        if (this.yLabel !== null)
        {
            this.yLabel.style.display = "none";
        }

        for (var i = 0; i < this.areas.length; ++i)
        {
            var area = this.areas[i];
            if (area.enabled === false || area.isLayer || area.isScroller)
            {
                continue;
            }

            area.horizontal.style.display = "none";
            area.vertical.style.display = "none";
            area.tooltip.innerHTML = area.tooltipInnerHtml || "";
        }

        this.hidden = true;
    };

    iChart.Charting.Crosshair.prototype.render = function (pageX, pageY, force) {

        force = typeof force !== undefined ? force : false;
        if (pageX === this.pageX && pageY === this.pageY && !force)
        {
            return;
        }

        this.pageX = pageX;
        this.pageY = pageY;

        var chartOffset = this.$chart.offset();
        var chartOffset = this.areas[0].chart._containerSize.offset;

        var offset = {};
        offset.left = Math.round(this.pageX - chartOffset.left);
        offset.top = Math.round(this.pageY - chartOffset.top);

        var inside = {};
        inside.x = false;
        inside.y = false;
        for (var i = 0; i < this.areas.length; ++i)
        {
            var area = this.areas[i];
            if (area.enabled === false || area.isLayer || area.isScroller)
            {
                continue;
            }

            if(area.chart.chartOptions.tooltipPosition == 'top') {
                var top = area.innerOffset.top - 20;
            } else if(area.chart.chartOptions.tooltipPosition == 'bottom') {
                var top = area.innerOffset.top - 38 + area.innerHeight;
            }
            $(area.tooltip).css({ "left": area.innerOffset.left + "px", "top": top + "px"});

            inside[i] = {};
            inside.x = (inside[i].x = offset.left >= area.innerOffset.left && offset.left <= area.innerOffset.left + area.innerWidth) || inside.x;
            inside.y = (inside[i].y = offset.top >= area.innerOffset.top && offset.top <= area.innerOffset.top + area.innerHeight) || inside.y;
        }

        if (!inside.x || !inside.y)
        {
            this.hide();
            return;
        }

        var point;
        if (typeof this.pointMap === "undefined")
        {
            var area = this.areas[0];
            if (area.xSeries.length === 0)
            {
                this.hide();
                return;
            }

            var xIndex = area.getXIndex(offset.left - area.innerOffset.left);
            if (xIndex < area.viewport.x.bounded.min || xIndex > area.viewport.x.bounded.max)
            {
                this.hide();
                return;
            }

            xIndex = Math.max(area.viewport.x.bounded.min, Math.min(area.viewport.x.bounded.max, Math.round(xIndex)));
            offset.left = area.innerOffset.left + Math.round(area.getXPositionByIndex(xIndex));
            for (var i = 0; i < this.dots.length; ++i)
            {
                var dot = this.dots[i];
                var area = this.areas[dot.areaIndex];
                var series = area.ySeries[dot.seriesIndex2];
                var values = series.points[xIndex];
                if (values)
                {
                    var value = values[dot.yValueIndex];
                    if (series.multiplier)
                    {
                        value = (series.multiplier * value) - 100;
                    }

                    var position = area.getYPosition(value);
                    if (position >= 0 && position <= area.innerHeight)
                    {
                        dot.style.display = "";
                        dot.style.left = (offset.left - 4) + "px";
                        dot.style.top = (area.innerOffset.top + position - 4) + "px";
                    }
                    else
                    {
                        dot.style.display = "none";
                    }
                }
                else
                {
                    dot.style.display = "none";
                }
            }

            for (var i = 0; i < this.areas.length; ++i)
            {
                var area = this.areas[i];
                if (area.enabled === false || area.isScroller)
                {
                    continue;
                }

                var tooltips = [];
                if (!area.isLayer)
                {
                    var dateTime = new Date(1000 * area.xSeries[xIndex]);
                    tooltips.push(iChart.formatDateTime(dateTime, "dd.MM.yyyy" + (this.showTime ? " HH:mm" : "")));
                }

                for (var j = 0; j < area.ySeries.length; ++j)
                {
                    var series = area.ySeries[j];
                    for (var k = 0; k < series.labels.length; ++k)
                    {
                        var labelIndex = series.labels[k][0];
                        var labelText = series.labels[k][1];
                        var values = series.points[xIndex];
                        if (values)
                        {
                            var value = values[labelIndex];
                            if (series.multiplier)
                            {
                                value = (series.multiplier * value) - 100;
                                value = (value > 0 ? "+" : "") + iChart.formatNumber(value, series.formatProvider) + "%";
                            }
                            else
                            {
                                //value = iChart.formatNumber(value, series.formatProvider);
                                if(value < 100) {
                                    value = iChart.formatNumber( value, { decimalPlaces: null, decimalPrecision: 6, "scale": 0 });
                                } else {
                                    value = iChart.formatNumber( value, { decimalPlaces: 2, decimalPrecision: null, "scale": 0 });
                                }
                            }

                            tooltips.push(labelText + " <span class='m-chart-legend-value'>" + value + "</span>");
                        }
                    }
                }

                if (area.isLayer)
                {
                    $.grep(this.areas, function (x) { return x.name === area.parentName })[0].tooltip.innerHTML += " &ensp; " + tooltips.join(" &ensp; ");
                }
                else
                {
                    area.tooltip.innerHTML = tooltips.join(" &ensp; ");
                }
            }
        }
        else
        {
            point = this.pointMap[offset.left];
            if (typeof point === "undefined")
            {
                this.hide();
                return;
            }

            offset.left = point.offset;

            for (var i = 0; i < this.dots.length; ++i)
            {
                var dot = this.dots[i];
                var values = point.y[dot.seriesIndex];
                if (values)
                {
                    var position = values[dot.yValueIndex].p;
                    var area = this.areas[dot.areaIndex];
                    if (area.enabled === false || area.isScroller)
                    {
                        continue;
                    }

                    if (position >= area.innerOffset.top && position <= area.innerOffset.top + area.innerHeight)
                    {
                        dot.style.display = "";
                        dot.style.left = (offset.left - 4) + "px";
                        dot.style.top = (position - 4) + "px";
                    }
                    else
                    {
                        dot.style.display = "none";
                    }
                }
                else
                {
                    dot.style.display = "none";
                }
            }

            for (var i = 0; i < this.areas.length; ++i)
            {
                var area = this.areas[i];
                if (area.enabled === false || area.isScroller)
                {
                    continue;
                }

                area.tooltip.innerHTML = point.tooltips[i];
            }
        }

        for (var i = 0; i < this.areas.length; ++i)
        {
            var area = this.areas[i];
            if (area.enabled === false || area.isLayer || area.isScroller)
            {
                continue;
            }

            area.tooltip.style.display = "";
            if (inside[i].x)
            {
                area.vertical.style.display = "";
                area.vertical.style.left = offset.left + "px";
                if (inside[i].y)
                {
                    area.horizontal.style.display = "";
                    area.horizontal.style.top = offset.top-0 + "px";
                    if (this.yLabel !== null && !area.chart.overlay.drag)
                    {
                        this.yLabel.innerHTML = iChart.formatNumber(this._getYValue(area, offset.top - area.innerOffset.top), { "decimalPrecision": 5 });
                        this.yLabel.style.display = "";
                        this.yLabel.style.top = (offset.top - 8) + "px";
                    } else {
                        this.yLabel.style.display = "none";
                    }
                }
                /*
                 var ctx = this.$chart[0].getContext("2d");
                 iChart.viewData.chart.render({"context": ctx, "forceRecalc": false, "resetViewport": false, "testForIntervalChange": false });
                 ctx.save();
                 ctx.beginPath();
                 ctx.arc(offset.left, offset.top, 20, 0, 2 * Math.PI, true);
                 ctx.fillStyle = '#fff';
                 ctx.globalAlpha = 1;
                 ctx.lineWidth = 2;
                 ctx.stokeStyle = '#eee';
                 ctx.fill();
                 ctx.stroke();
                 ctx.restore();
                 */
//console.log(this.$chart[0]);

                else
                {
                    area.horizontal.style.display = "none";
                }
            }
            else
            {
                area.horizontal.style.display = "none";
                area.vertical.style.display = "none";
            }
        }

        this.hidden = false;
    }

    iChart.Charting.Crosshair.prototype.mouseMoveHandler = function (e)
    {
        /// <summary>
        /// Handles MouseMove event.
        /// </summary>


        if (typeof e === "undefined")
        {
            e = window.event;
        }

        var pageX;
        var pageY;

        if (typeof e.pageX !== "undefined")
        {
            pageX = e.pageX;
            pageY = e.pageY;
        }
        else
        {
            pageX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            pageY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
        }

        pageX = Math.round(pageX);
        pageY = Math.round(pageY);

        this.render(pageX, pageY);

    };

    iChart.Charting.Crosshair.prototype.update = function (data, container)
    {
        /// <summary>
        /// Updates crosshair data.
        /// </summary>
        /// <param name="data" type="Object">New chart data to use in crosshair.</param>

        this.container = container;
        this._clear();

        if (!data || !data.areas)
        {
            throw "No data available.";
        }

        this.areas = data.areas;
        this.chartWidth = this.areas[0].chart._containerSize.width;
        this.showTime = data.showTime;

        this._initDots();
        this._initYLabel();
        this._initPointMap(data);
        //iChart.Charting.Crosshair.addMouseMoveHandler(this, container);
        this.addMouseMoveHandler(this);
    };

    iChart.Charting.Crosshair.prototype._clear = function ()
    {
        /// <summary>
        /// Removes associated DOM elements and event listeners and clears all stored data.
        /// </summary>
        //iChart.Charting.Crosshair.removeMouseMoveHandler(container);
        this.removeMouseMoveHandler();

        $(".m-chart-d, .m-chart-h, .m-chart-t, .m-chart-v, .m-chart-y", this.$chart.parent()).remove();

        this.areas = [];
        this.dots = [];
        this.yLabel = null;
    };

    iChart.Charting.Crosshair.prototype._getYValue = function (area, position)
    {
        /// <summary>
        /// Gets Y value at the specified Y pixel position.
        /// </summary>
        /// <param name="area" type="iChart.Charting.ChartArea">Chart area containing the point.</param>
        /// <param name="position" type="Number">Y coordinate of the point.</param>
        /// <returns type="Number" />

        if (area.axisY.scale === 0)
        {
            return area.axisY.max;
        }

        return area.axisY.max - (position / area.axisY.scale);
    };

    iChart.Charting.Crosshair.prototype._initDots = function ()
    {
        /// <summary>
        /// Initializes crosshair dot DIVs used for highlighting series data points.
        /// </summary>

        this.dots = [];
        for (var i = 0; i < this.areas.length; ++i)
        {
            var area = this.areas[i];
            if (area.enabled === false || area.isLayer || area.isScroller)
            {
                continue;
            }

            for (var j = 0; j < area.ySeries.length; ++j)
            {
                var series = area.ySeries[j];
                var dotColor = series.dotColor || series.color || "";
                if (dotColor === "")
                {
                    continue;
                }

                var dot = $("<div/>", { "class": "m-chart-d" }).css({ "background-color": dotColor, "display": "none" }).insertAfter(this.$chart).get(0);
                dot.areaIndex = i;
                dot.seriesIndex = series.index;
                dot.seriesIndex2 = j;
                dot.yValueIndex = series.dotIndex || 0;
                this.dots.push(dot);
            }
        }
    };

    iChart.Charting.Crosshair.prototype._initPointMap = function (data)
    {
        /// <summary>
        /// Initializes point map.
        /// </summary>
        /// <param name="data" type="Object">Chart data for the crosshair.</param>

        for (var i = 0; i < this.areas.length; ++i)
        {
            var area = this.areas[i];

            if (area.enabled === false || area.isScroller)
            {
                continue;
            }

            if (!area.isLayer)
            {
                area.horizontal = $("<div/>", { "class": "m-chart-h" }).css({ "display": "none", "left": area.innerOffset.left + "px", "width": area.innerWidth + "px" }).insertAfter(this.$chart).get(0);
                area.vertical = $("<div/>", { "class": "m-chart-v" }).css({ "display": "none", "top": area.innerOffset.top + "px", "height": area.innerHeight + "px" }).insertAfter(this.$chart).get(0);
            }

            if (typeof data.pointMap === "undefined")
            {
                if (area.viewport.x.bounded.min <= area.viewport.x.bounded.max)
                {
                    var tooltips = [];
                    var boundedMax = Math.min(area.viewport.x.bounded.max, area.xSeries.length - 1 - area.chart.chartOptions.futureAmount);
                    if (!area.isLayer)
                    {
                        var dateTime = new Date(1000 * area.xSeries[boundedMax]);
                        tooltips.push(iChart.formatDateTime(dateTime, "dd.MM.yyyy" + (this.showTime ? " HH:mm" : "")));
                    }

                    for (var j = 0; j < area.ySeries.length; ++j)
                    {
                        var series = area.ySeries[j];
                        for (var k = 0; k < series.labels.length; ++k)
                        {
                            var labelIndex = series.labels[k][0];
                            var labelText = series.labels[k][1];
                            var values = series.points[boundedMax];
                            if (values)
                            {
                                var value = values[labelIndex];
                                if (series.multiplier)
                                {
                                    value = (series.multiplier * value) - 100;
                                    value = (value > 0 ? "+" : "") + iChart.formatNumber(value, series.formatProvider) + "%";
                                }
                                else
                                {
                                    //value = iChart.formatNumber(value, series.formatProvider);
                                    if(value < 100) {
                                        value = iChart.formatNumber( value, { decimalPlaces: null, decimalPrecision: 6, "scale": 0 });
                                    } else {
                                        value = iChart.formatNumber( value, { decimalPlaces: 2, decimalPrecision: null, "scale": 0 });
                                    }
                                }

                                tooltips.push(labelText + " <span class='m-chart-legend-value'>" + value + "</span>");
                            }
                        }
                    }

                    if (area.isLayer)
                    {
                        $.grep(this.areas, function (x) { return x.name === area.parentName })[0].tooltipInnerHtml += " &ensp; " + tooltips.join(" &ensp; ");
                    }
                    else
                    {
                        area.tooltipInnerHtml = tooltips.join(" &ensp; ");
                    }
                }
            }
            else
            {
                for (var pointKey in data.pointMap)
                {
                    if (!data.pointMap.hasOwnProperty(pointKey))
                    {
                        continue;
                    }

                    var point = data.pointMap[pointKey];
                    if (typeof point.tooltips === "undefined")
                    {
                        point.tooltips = new Array(this.areas.length);
                    }

                    var tooltips = [];
                    tooltips.push(point.x);
                    for (var j = 0; j < area.ySeries.length; ++j)
                    {
                        var ySeries = area.ySeries[j];
                        for (var k = 0; k < ySeries.labels.length; ++k)
                        {
                            var labelIndex = ySeries.labels[k][0];
                            var labelText = ySeries.labels[k][1];
                            var temp = point.y[ySeries.index];
                            if (temp)
                            {
                                tooltips.push(labelText + " <span class='m-chart-legend-value'>" + temp[labelIndex].v + "</span>");
                            }
                        }
                    }

                    area.tooltipInnerHtml = tooltips.join(" &nbsp; ");
                    point.offset = pointKey;
                    point.tooltips[i] = area.tooltipInnerHtml;
                }
            }

            if (area.isLayer)
            {
                var parentArea = $.grep(this.areas, function (x) { return x.name === area.parentName })[0];
                $(parentArea.tooltip).html(parentArea.tooltipInnerHtml || "");
            }
            else
            {
                if(area.chart.chartOptions.tooltipPosition == 'top') {
                    var top = area.innerOffset.top - 20;
                } else if(area.chart.chartOptions.tooltipPosition == 'bottom') {
                    var top = area.innerOffset.top - 38 + area.innerHeight;
                }
                area.tooltip = $("<div/>", { "class": "m-chart-t" })
                    .css({ "left": area.innerOffset.left + "px", "top": top + "px", background: area.chart.chartOptions.backgroundColor })
                    .html(area.tooltipInnerHtml || "")
                    .insertAfter(this.$chart)
                    .get(0);
            }
        }

        if (typeof data.pointMap !== "undefined")
        {
            this.pointMap = new Array(this.chartWidth);
            for (var i = 0; i < this.chartWidth; ++i)
            {
                var j = 0;
                var point = data.pointMap[i];
                while (this._isEmptyPoint(point) && ((i - j) > 0 || (i + j) < this.chartWidth))
                {
                    ++j;
                    point = data.pointMap[i - j];
                    if (this._isEmptyPoint(point))
                    {
                        point = data.pointMap[i + j];
                    }
                }

                if (!this._isEmptyPoint(point))
                {
                    this.pointMap[i] = point;
                }
            }
        }
    };

    iChart.Charting.Crosshair.prototype._initYLabel = function ()
    {
        /// <summary>
        /// Initializes Y label DIV used for displaying ordinate value to the left of the chart.
        /// </summary>

        var area = this.areas[0];
        if (!area || area.enabled === false || area.isScroller)
        {
            return;
        }

        this.yLabel = $("<div/>", { "class": "m-chart-y" })
            .css({
                "background": area.chart.chartOptions.backgroundColor,
                "display": "none",
                "left": (area.innerOffset.left + area.innerWidth - (area.chart.chartOptions.yLabelsOutside ? 0 : 50)) + "px",
                "position": "absolute",
                "margin": "0 0 0 5px"
            })
            .insertAfter(this.$chart)
            .get(0);
    };

    iChart.Charting.Crosshair.prototype._isEmptyPoint = function (point)
    {
        /// <summary>
        /// Gets a value indicating whether the specified data point is considered empty.
        /// </summary>
        /// <param name="point">Data point to check.</param>
        /// <returns type="Boolean" />

        if (typeof point === "undefined")
        {
            return true;
        }

        for (var i = 0; i < point.y.length; ++i)
        {
            if (point.y[i] !== null)
            {
                return false;
            }
        }

        return true;
    };

    iChart.Charting.Crosshair.prototype.addMouseMoveHandler = function (crosshair)
    {
        /// <summary>
        /// Adds crosshair mousemove event listener.
        /// </summary>
        /// <param name="crosshair" type="iChart.Charting.Crosshair">Crosshair to add the event handler to.</param>
        //console.log('iChart.Charting.Crosshair.prototype.addMouseMoveHandler');
        if (this.mouseMoveHandler) {
            this.removeMouseMoveHandler();
        }
        this.mouseMoveHandler = crosshair.mouseMoveHandler.bind(this); //$.proxy(crosshair.mouseMoveHandler, crosshair);
        //$(document.body).on('mousemove move', function(e) {

        $(this.container).on('mousemove', this.mouseMoveHandler); //$.proxy(this.mouseMoveHandler, this));

        //$('#chartContainerWrapper').on('mousemove', iChart.Charting.Crosshair.mouseMoveHandler);

//        iChart.Charting.Crosshair.mouseMoveHandler = $.proxy(crosshair.mouseMoveHandler, crosshair);
//        if (typeof document.addEventListener !== "undefined")
//        {
//            document.addEventListener("mousemove", iChart.Charting.Crosshair.mouseMoveHandler, false);
//        }
//        else if (typeof document.attachEvent !== "undefined")
//        {
//            document.attachEvent("onmousemove", iChart.Charting.Crosshair.mouseMoveHandler);
//        }
//        else
//        {
//            throw "Browser does not support document.addEventListener/attachEvent.";
//        }
    };

    iChart.Charting.Crosshair.prototype.removeMouseMoveHandler = function ()
    {
        /// <summary>
        /// Removes crosshair mousemove event listener if present.
        /// </summary>

        //console.log(1, container);

        //var $chart = crosshair.areas[0].chart.container;
        //if (typeof iChart.Charting.Crosshair.mouseMoveHandler !== "undefined") {
        //console.log('iChart.Charting.Crosshair.prototype.removeMouseMoveHandler');
        if (typeof this.mouseMoveHandler !== "undefined") {
            //$(document.body).off('mousemove move', iChart.Charting.Crosshair.mouseMoveHandler);
            $(this.container).off('mousemove ', this.mouseMoveHandler);
        }

//        if (typeof iChart.Charting.Crosshair.mouseMoveHandler !== "undefined")
//        {
//            if (typeof document.addEventListener !== "undefined")
//            {
//                document.removeEventListener("mousemove", iChart.Charting.Crosshair.mouseMoveHandler, false);
//            }
//            else
//            {
//                document.detachEvent("onmousemove", iChart.Charting.Crosshair.mouseMoveHandler);
//            }
//        }
    };

    $.fn.crosshair = function (data, container)
    {
        /// <summary>
        /// Updates a chart crosshair overlay.
        /// </summary>
        /// <param name="data" type="Object">Chart data for the crosshair.</param>
        /// <returns type="jQuery" />

        if (!this.length)
        {
            return this;
        }

        var crosshair = this.data("crosshair");
        if (typeof crosshair === "undefined")
        {
            crosshair = new iChart.Charting.Crosshair({ "$chart": this });
            this.data("crosshair", crosshair);
        }

        crosshair.update(data, container);
        return this;
    };
})(jQuery);
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartDataSource = function (chart, settings)
    {
        /**
         Через эту функцию график осуществляет получение данных.
         Вызов производится в двух случаях
         1 — при инициализации
         2 — при прокрутке по достижению границы имеющихся данных.
         Функция получает объект параметров, по которому должна сформировать запрос.
         Результат должен передаться в callback(data)
         data — объект со следующей структурой

         data = {
            "hloc":{
                "<STOCK_1>": [[<high>, <low>, <open>, <close>],...k],
                ...
                "<STOCK_N>": [[<high>, <low>, <open>, <close>],...l],
            },
            "vl":{
                "<STOCK_1>": [<volume1>, <volume2>,...k],
                ...
                "<STOCK_N>": [<volume1>, <volume2>,...l],
            },
            "xSeries":{
                "<STOCK_1>": [<timestamp1>, <timestamp2>,...k],
                ...
                "<STOCK_N>": [<timestamp1>, <timestamp2>,...l],
            }

        };


         Минимальный набор поступающих параметров, может быть расширен
        params = {
            "useHash": false,
            "date_from": "31.12.2013 00:00",
            "date_to": "23.01.2015",
            "graphicIndicators": "",
            "hash": "",
            "id": "LKOH",
            "interval": "D1",
            "timeframe": 1440,
            "start": "23.01.2015 00:00",
            "intervalMode": "ClosedRay",
            "count": -1
        }
         */
        function onRequestCallback (callback, params) {
            console.log(params);
            var data = this.dataAdapter(this.data, params);
            this.chart.wrapper.trigger('iguanaChartEvents', ['chartDataReceived', data]);
            callback(data);
            this.chart.wrapper.trigger('iguanaChartEvents', ['chartDataReady', data]);
            this.chart.dataRequestCounter++;
        };

        /**
        Параметры известны, перед инициализацией можно произвести
        дополнительные манипуляции с параметрами, сделать запросы.
        В конце всех действий должен быть вызов параметрической колбэк функции
        с параметрами графика initReadyCallback(params.chartOptions);
        */
        function preInitCallback(initReadyCallback, params) {
            initReadyCallback(params.chartOptions);
        };

        var dataSettings = {
            useHash: false,
            date_from: formatDate(-90),
            date_to: formatDate(0),
            graphicIndicators: '',
            hash: '',
            id: "",
            interval: "D1",
            timeframe: 1440
        };

        settings = settings || {};
        /**
         * @var IguanaChart
         */
        this.chart = chart;
        this.data = settings.data || {};
        this.dataSettings = settings.dataSettings || dataSettings;
        this.preInitCallback = (typeof settings.preInitCallback == "function") ? settings.preInitCallback.bind(this) : preInitCallback.bind(this);
        this.onRequestCallback = (typeof settings.onRequestCallback == "function") ? settings.onRequestCallback.bind(this) : onRequestCallback.bind(this);
    };

    iChart.Charting.ChartDataSource.prototype.set = function (settings)
    {

    };

    iChart.Charting.ChartDataSource.prototype.preInit = function (callback, params)
    {

        this.dataSettings.date_from = params.date_from || this.dataSettings.date_from  || formatDate(-90);
        this.dataSettings.date_to = params.date_to || this.dataSettings.date_to || formatDate(0);

        if(params.period) {
            var periodDates = this.chart.getPeriodDates(params.period);
            this.dataSettings.date_from = periodDates.date_from;
            this.dataSettings.date_to = periodDates.date_to;
        }

        this.dataSettings.start = this.dataSettings.start || this.dataSettings.date_from;
        this.dataSettings.end = this.dataSettings.end || this.dataSettings.date_to;
        this.dataSettings.interval = params.interval || this.dataSettings.interval;
        this.dataSettings.timeframe = iChart.getChartTimeframe(this.dataSettings.interval);

        params.chartOptions = $.extend(true, {}, params.chartOptions);
        params.theme = typeof params.theme != "undefined" ? params.theme : IGUANACHART_THEME;

        if(params.theme) {
            var theme = $.grep($iguanaChart.thems, function(theme) {return (theme.name == params.theme ? theme : null);} )[0];
            if(typeof theme !== "undefined") {
                params.chartOptions = $.extend(true, {}, params.chartOptions, theme.settings);
            } else if (params.theme == 'default') {
                params.chartOptions = $.extend(true, {}, params.chartOptions, $iguanaChart.defaultTheme);
            }
        }

        this.preInitCallback(callback, params);
    };

    iChart.Charting.ChartDataSource.prototype.onRequest = function (callback, params)
    {
        this.onRequestCallback(callback, params);
    };

    iChart.Charting.ChartDataSource.prototype.dataAdapter = function (data, params) {
        var chartData = {
            "xSeries": [],
            "ySeries": [],
            "success": true,
            "warnings": [],
            "message": ''
        };

        var hloc = {
            "chartType": "Column",
            "enabled": true,
            "formatProvider": {
                "decimalPlaces": "2",
                "decimalPrecision": null
            },
            "indicatorIndex": null,
            "indicatorIndex2": null,
            "kind": "HLOC",
            "name": params.id,
            "overlay": false,
            "points": [],
            "valuesPerPoint": 4
        };

        var volume = {
            "chartType": "Column",
            "enabled": true,
            "formatProvider": {
                "decimalPlaces": null,
                "decimalPrecision": null
            },
            "indicatorIndex": null,
            "indicatorIndex2": null,
            "kind": "Volume",
            "name": params.id + " - V",
            "overlay": false,
            "points": [],
            "valuesPerPoint": 1
        };

        if(data.hloc) {
            var tickers = Object.keys(data.hloc);

            if(tickers.length == 1) {
                chartData.ySeries[0] = $.extend(true,{},hloc);
                chartData.ySeries[1] = $.extend(true,{},volume);
                chartData.ySeries[0].name = tickers[0];

                for (var i = 0; i < data.xSeries[tickers[0]].length; i++) {
                    //chartData.xSeries.push(+(data.xSeries[tickers[0]][i]));
                    chartData.xSeries.push(+(data.xSeries[tickers[0]][i]) + getTimeOffsetServer(tzOffsetMoscow));
                    chartData.ySeries[0].points.push(data.hloc[tickers[0]][i]);
                    chartData.ySeries[1].points.push([data.vl[tickers[0]][i]]);
                }

            } else if (tickers.length > 1) {
                // При сравнении нескольких бумаг
                //Нормализация по времени
                var x = {}
                for (var j = 0; j < tickers.length; j++) {
                    for (var i = 0; i < data.xSeries[tickers[j]].length; i++) {
                        if(typeof x[data.xSeries[tickers[j]][i]] == "undefined") {
                            x[data.xSeries[tickers[j]][i]] = {}
                        }
                        x[data.xSeries[tickers[j]][i]][tickers[j]] = data.hloc[tickers[j]][i];
                    }
                }

                for (var j = 0; j < tickers.length; j++) {
                    chartData.ySeries[j] = $.extend(true,{},hloc);
                    chartData.ySeries[j].name = tickers[j];
                }
                //Распределение котировок
                for(var tmstmp in x) {
                    chartData.xSeries.push(+(tmstmp) + getTimeOffsetServer(tzOffsetMoscow));

                    for (var j = 0; j < tickers.length; j++) {
                        if(typeof x[tmstmp][tickers[j]] == "undefined") {
                            chartData.ySeries[j].points.push([null, null, null, null]);
                        } else {
                            chartData.ySeries[j].points.push(x[tmstmp][tickers[j]]);
                        }
                    }
                }
            }
        }
        return chartData;
    };

})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartOptions = function ()
    {
        this.backgroundColor = '#ffffff';
        this.axisColor =  '#999999';
        this.labelColor =  '#595959';
        this.labelFontColor =  '#ffffff';
        this.labelFont =  "10px Arial";
        this.showLabels =  true;
        this.gridColor =  '#cccccc';
        /**
         *
         * @type {'dashed'|'solid'}
         * @private
         */
        this._gridStyle =  'dashed';
        this.watermarkShow =  true;
        this.watermarkColor =  'rgba(238,238,238,1)';
        this.watermarkFont =  'bold 40px Verdana';
        this.watermarkSubFont =  'bold 25px Verdana';
        this.watermarkText =  '';
        this.watermarkSubText =  '';
        this.candleUp =  '#66B85C';
        this.candleDown =  '#C75757';
        this.candleBorderUp =  '#66B85C';
        this.candleBorderDown =  '#C75757';
        this.candleWick =  true;
        this.candleWickStyle =  '#595959';
        this.stockUp =  '#66B85C';
        this.stockDown =  '#C75757';
        this.stockWidth =  1;
        this.lineColor =  '#595959';
        this.lineWidth =  1;
        this.areaColor =  '#eff6fb';
        this.areaLineColor =  '#cccccc';
        this.volumeStyle =  'rgba(119, 119, 119, 0.3)';
        this.scrollerOverlayColor =  'rgba(0,0,0, 0.1)';
        this.scrollerHandlerColor =  'rgba(255,255,255, 1)';
        this.areaPaddingBottom   =  30;
        this.areaPaddingLeft     =  0;
        this.areaPaddingRight    =  60;
        this.areaPaddingTop      =  0;
        this.paddingBottom       =  0;
        this.candleBorder        =  0;
        this.tooltipPosition     =  'bottom';
        this.showAxes = 0;
        this.shadowColor =  '#999999';
        this.indicatorColors =  [
                ["#3D96AE", "#80699B", "#DB843D", "#B5CA92"],
                ["#A47D7C", "#B5CA92", "#e0400a", "#617db4"],
                ["#ff8c00", "#617db4", "#999999", "#80699B"],
                ["#3D96AE", "#80699B", "#DB843D", "#B5CA92"],
                ["#A47D7C", "#B5CA92", "#e0400a", "#617db4"],
                ["#ff8c00", "#617db4", "#999999", "#80699B"],
                ["#3D96AE", "#80699B", "#DB843D", "#B5CA92"],
                ["#A47D7C", "#B5CA92", "#e0400a", "#617db4"],
                ["#ff8c00", "#617db4", "#999999", "#80699B"],
                ["#3D96AE", "#80699B", "#DB843D", "#B5CA92"],
                ["#A47D7C", "#B5CA92", "#e0400a", "#617db4"],
                ["#ff8c00", "#617db4", "#999999", "#80699B"]
            ];
        this.minAreaHeight =  100;
        this.minHeight =  0;
        this.seriesColors =  ["#4BA1B8", "#FF8C00", "#A47D7C", "#3D96AE", "#80699B", "#DB843D", "#80699B"];
        this.mousewheelZoom =  true;
        this.maxZoom =  20;
        this.panStep =  0.3;
        this.primaryAreaHeight =  350;
        this.primaryAreaAxisYpaddingTop =  30;
        this.primaryAreaAxisYpaddingBottom =  30;
        this.primaryToSecondaryAreaHeightRatio =  2;
        this.scrollerHeight =  80;
        this.updateInterval =  true;
        this.showCurrentLabel =  true;
        this.yLabelsOutside =  true;
        this.percentMode =  false;
        this.futureAmount =  100;
        this.crosshairEnable =  true;
        /**
         *
         * @type {'Candlestick'|'Stock'|'Line','Area'}
         * @private
         */
        this._chartType =  'Candlestick';
        /**
         *
         * @type {'inside'|'outside'|'hidden'}
         * @private
         */
        this._showVolume =  'hidden';
        this.showVolumeByPrice =  false;
        this.floatingLegend =  false;
        this.floatingLegendFontSize =  12;
        this.floatingLegendTextColor =  '#444444';
        this.floatingLegendBorderColor =  'rgba(82,175,201,1)';
        this.floatingLegendBackground =  'rgba(82,175,201,.6)';
        this.legendAlign = 'top';

        this.elementStyle = {
            'Arrow': {
                fillStyle: 'rgba(255,0,0,.2)',
                strokeStyle: 'rgba(255,0,0,1)',
                lineWidth: 3
            },
            'Text': {
                fontColor: '#777777',
                fontSize: '28'
            }
        };

        this.uiTools = {
            top: false,
        };

        this.inertialScrolling = true
    };

    iChart.Charting.ChartOptions.themesParams = [
        'backgroundColor',
        'axisColor',
        'showAxes',
        'labelColor',
        'labelFontColor',
        'gridColor',
        'gridStyle',
        'watermarkColor',
        'watermarkFont',
        'watermarkSubFont',
        'candleUp',
        'candleDown',
        'candleBorder',
        'candleBorderUp',
        'candleBorderDown',
        'candleWick',
        'candleWickStyle',
        'stockUp',
        'stockDown',
        'stockWidth',
        'lineColor',
        'lineWidth',
        'areaColor',
        'areaLineColor',
        'volumeStyle',
        'scrollerOverlayColor',
        'scrollerHandlerColor',
        'shadowColor',
        'chartType'
    ];


    iChart.Charting.ChartOptions.getThemeOptions = function (chartOptions) {
        var result = {};
        if(chartOptions) {
            $.each(this.themesParams, function (i, key) {
                if (typeof chartOptions[key] == "object") {
                    if ($.isArray(chartOptions[key])) {
                        result[key] = $.extend(true, [], chartOptions[key]);
                    } else {
                        result[key] = $.extend(true, {}, chartOptions[key]);
                    }
                } else if(chartOptions[key]) {
                    result[key] = chartOptions[key];
                }
            });
        }
        return result;
    };

    Object.defineProperty(iChart.Charting.ChartOptions.prototype, 'chartType', {
        get: function() {
            return this['_chartType'];
        },
        set: function(data) {
            var values = ['Candlestick','Stock','Line', 'Area'];
            if(values.indexOf(data) >= 0) {
                this['_chartType'] = data;
            } else {
                this['_chartType'] = 'Candlestick';
                console.warn("ChartOptions: Invalid value chartType:'%s'. Set to default: 'Candlestick'", data);
            }
        }
    });

    Object.defineProperty(iChart.Charting.ChartOptions.prototype, 'showVolume', {
        get: function() {
            return this['_showVolume'];
        },
        set: function(data) {
            var values = ['inside','outside','hidden'];
            if(values.indexOf(data) >= 0) {
                this['_showVolume'] = data;
            } else {
                this['_showVolume'] = 'hidden';
                console.warn("ChartOptions: Invalid value showVolume. Set to default: 'hidden'");
            }
        }
    });

    Object.defineProperty(iChart.Charting.ChartOptions.prototype, 'gridStyle', {
        get: function() {
            return this['_gridStyle'];
        },
        set: function(data) {
            var values = ['dashed', 'solid'];
            if(values.indexOf(data) >= 0) {
                this['_gridStyle'] = data;
            } else {
                this['_gridStyle'] = 'dashed';
                console.warn("ChartOptions: Invalid value gridStyle. Set to default: 'dashed'");
            }
        }
    });

})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    var id = 0;

    iChart.Charting.Chart = function (settings)
    {
        /// <summary>
        /// Initializes a new instance of the Chart class with the specified parameters.
        /// </summary>
        /// <param name="settings">Chart settings.</param>
        /// <field name="_chartType" type="String">Current chart type.</field>
        /// <field name="_dataEnd" type="Date">Data end date/time (empty means that the absolute end of the data has been reached).</field>
        /// <field name="_dataLoading" type="Boolean">A value indicating whether a data request is in progress.</field>
        /// <field name="_dataSettings" type="Object">Data settings for the AJAX data requests.</field>
        /// <field name="_dataStart" type="Date">Data start date/time (empty means that the absolute start of the data has been reached).</field>
        /// <field name="_id" type="Number">Unique numeric identifier.</field>
        /// <field name="axisColor" type="String">Chart axis color.</field>
        /// <field name="backgroundColor" type="String">Chart background color (default is white).</field>
        /// <field name="canvas" type="HTMLCanvasElement">Output canvas.</field>
        /// <field name="container" type="HTMLElement">A HTML element that serves as a container for the chart canvas.</field>
        /// <field name="dataCallback" type="Function">Called when the chart requests new data.</field>
        /// <field name="dataCountMin" type="Number">Minimum number of additional points to load (default is 500).</field>
        /// <field name="downStyle" type="String">Down candle (close price less than open price) style (default is #617db4).</field>
        /// <field name="gridColor" type="String">Grid color.</field>
        /// <field name="gridStyle" type="String">Grid style (dashed/solid).</field>
        /// <field name="historyEnd" type="Date">End date/time of the market data history.</field>
        /// <field name="indicatorColors" type="Array">Indicator color palette.</field>
        /// <field name="labelColor" type="String">Axis label color.</field>
        /// <field name="labelFont" type="String">Axis label font (the syntax is the same as for the CSS 'font' property).</field>
        /// <field name="labelPrecision" type="Number">Axis label numeric precision (default is 5).</field>
        /// <field name="minAreaHeight" type="Integer">Minimum allowed chart area height in pixels (default is 100). Does not include scroller (see 'scrollerHeight').</field>
        /// <field name="mousewheelZoom" type="Boolean">A value indicating whether the mousewheel zooms the chart.</field>
        /// <field name="onCreateAreas" type="Function">Called after the default areas are created. You can add new or modify existing areas here.</field>
        /// <field name="onIntervalChange" type="Function">Called when date/time interval of the visible viewport changes. It receives start and end date/time as the arguments (end can be empty). Fired before onPreRender.</field>
        /// <field name="onPositionAreas" type="Function">Called after the default area dimensions are calculated and before the canvas is initialized. You can change area positions and inner/outer dimensions here.</field>
        /// <field name="onPostRender" type="Function">Called after rendering to the canvas. It receives the same arguments as the render method itself, 'this' refers to the chart object.</field>
        /// <field name="onPreRender" type="Function">Called before rendering to the canvas. It receives the same arguments as the render method itself, 'this' refers to the chart object.</field>
        /// <field name="panStep" type="Number">A number from 0 to 1 indicating how far the viewport should shift during panning (default is 0.3, i.e. 30%).</field>
        /// <field name="primaryAreaHeight" type="Integer">Primary (containing HLOC series) area height in pixels (default is 450). Ignored if minHeight is specified.</field>
        /// <field name="primaryToSecondaryAreaHeightRatio" type="Number">Primary to secondary area height ratio (default is 3). Used both when minHeight is and is not specified.</field>
        /// <field name="renderer" type="iChart.Charting.ChartRenderer">Renderer for this chart.</field>
        /// <field name="scrollerHeight" type="Integer">Scroller height in pixels (default is 100). Set to 0 to hide the scroller.</field>
        /// <field name="seriesAreaColor" type="String">Area chart type secondary (background) color.</field>
        /// <field name="seriesColors" type="Array">Series color palette.</field>
        /// <field name="selection" type="iChart.Charting.ChartSelection">Current mouse selection.</field>
        /// <field name="showVolume" type="String">A value indicating how a volume series should be displayed if present. Possible values are hidden, inside and outside (default is inside).</field>
        /// <field name="updateInterval" type="Number">Chart update interval (in milliseconds).</field>
        /// <field name="upStyle" type="String">Up candle (close price greater than open price) style (default is #617db4).</field>
        /// <field name="volumeStyle" type="String">Volume series color, default is rgba(97, 125, 180, 0.3).</field>
        /// <field name="watermarkColor" type="String">Watermark color.</field>
        /// <field name="watermarkFont" type="String">Watermark font.</field>
        /// <field name="watermarkSubFont" type="String">Watermark sub font.</field>
        /// <field name="watermarkText" type="String">Watermark text (empty = no watermark).</field>
        /// <field name="watermarkSubText" type="String">Watermark sub text (empty = no watermark).</field>

        this.env = settings.env;
        this._id = id++;


        this.chartOptions = new iChart.Charting.ChartOptions();

        this.dataCountMin = 50;
        this.historyEnd = settings.historyEnd;
        this.labelPrecision = 5;

        this.dataCallback = settings.dataCallback;
        this.onCreateAreas = settings.onCreateAreas || $.noop;
        this.onDataSettingsChange = settings.onDataSettingsChange || $.noop;
        this.onIntervalChange = settings.onIntervalChange || $.noop;
        this.onPositionAreas = settings.onPositionAreas || $.noop;
        this.onPostRender = settings.onPostRender || $.noop;
        this.onPreRender = settings.onPreRender || $.noop;
        this.contextmenuCallback = settings.contextmenuCallback || $.noop;

        // Initial values.
        this._dataLoading = false;
        this.areas = null;
        this.canvas = null;
        this.isComparison = false;
        this.viewport = {
            x: {min: null, max: null},
            y: {min: null, max: null}
        };


        // Complex properties.
        this.container = settings.container;
        $(this.container).unbind("selectstart");
        $(this.container).attr("unselectable", "on").css("user-select", "none").on("selectstart", false);

        this.overlay = new iChart.Charting.ChartDrawingLayer(this);
        this.widgetLay = new iChart.Charting.ChartWidgetLayer(this, settings.widget);
        this.renderer = new iChart.Charting.ChartRenderer(this);

        this.selection = new iChart.Charting.ChartSelection(this.container);
        this.selection.movestart = $.proxy(this._selectionMoveStartCallback, this);
        this.selection.move = $.proxy(this._selectionMoveCallback, this);
        this.selection.moveend = $.proxy(this._selectionMoveEndCallback, this);

        this.setSelectionMode("pan");

        var _this = this;

        $(this.container).on('mousewheel', function(event){
            $.proxy(_this._mousewheelCallback(event), _this);
        });

        this.touches = new iChart.Charting.ChartTouches(this);

        $(this.container).off('contextmenu').on('contextmenu', function(event){
            $.proxy(_this.contextmenuCallback(event), _this);
            _this.env.wrapper.trigger('iguanaChartEvents', ['contextmenuCallback', event]);
        });

        if(!$(this.env.container).height()) {
            var height = this.calculateHeight();
            $(this.env.container).height(height.height);
        }

        this.chartOptions = $.extend(true, this.chartOptions, settings);

        this.crosshair = false;
        this._resized = true;
        this._containerSize = {};

        //this.setDataSettings(this.env.dataSource.dataSettings);
    };

    iChart.Charting.Chart.prototype.clearIndicators = function (area)
    {
        /// <summary>
        /// Removes all TA indicators and areas from the chart.
        /// </summary>
        /// <param name="area">(Optional) Chart area to remove the indicators from.</param>
        for (var i = 0; i < this.areas.length; ++i)
        {
            var a = this.areas[i];
            if (area && a !== area)
            {
                continue;
            }
            var indicatorIndex = [];
            for (var j = 0; j < a.ySeries.length; ++j)
            {
                if (a.ySeries[j].kind === "TechnicalAnalysis" || a.ySeries[j].kind === "TA_LIB")
                {
                    indicatorIndex.push(a.ySeries[j].indicatorIndex);
                    a.ySeries.splice(j, 1);
                    --j;
                }
            }
            if (indicatorIndex.length)
            {
                for (var key in this._dataSettings)
                {
                    for (var j = 0; j < indicatorIndex.length; j++)
                    {
                        if (this._dataSettings.hasOwnProperty(key) && key.match(new RegExp("^i" + indicatorIndex[j], "i")))
                        {
                            delete this._dataSettings[key];
                        }
                    }
                }

                if (a.ySeries.length === 0)
                {
                    if(typeof a.overlay != "undefined") {
                        $(a.overlay.canvas).remove();
                    }
                    var removed = this.areas.splice(i, 1);
                    removed[0].dispose();
                    --i;
                }
            }
        }
        this.onDataSettingsChange.call(this);
        this.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
        this.env.wrapper.trigger('iguanaChartEvents', ['clearIndicators']);
    };

    iChart.Charting.Chart.prototype.findAreaAtPosition = function (x, y)
    {
        /// <summary>
        /// Finds the chart area at the specified pixel position (counted from the top left corner of the chart). Note that area corners are excluded from search.
        /// </summary>
        /// <param name="x" type="Number">X pixel position.</param>
        /// <param name="y" type="Number">Y pixel position.</param>
        /// <returns type="Object" />

        var result = {};
        for (var i = 0; i < this.areas.length; ++i)
        {
            result.area = this.areas[i];
            if (!result.area.enabled)
            {
                continue;
            }

            if (x >= result.area.offset.left && x <= result.area.offset.left + result.area.outerWidth && y >= result.area.offset.top && y <= result.area.offset.top + result.area.outerHeight)
            {
                result.insideX = x >= result.area.innerOffset.left && x <= result.area.innerOffset.left + result.area.innerWidth;
                result.insideY = y >= result.area.innerOffset.top && y <= result.area.innerOffset.top + result.area.innerHeight;
                if (!result.insideX && !result.insideY)
                {
                    return null;
                }

                return result;
            }
        }

        return null;
    };

    iChart.Charting.Chart.prototype.getSeriesCollection = function ()
    {
        /// <summary>
        /// Gets an ordered list of all series contained in the chart.
        /// </summary>

        var results = [];
        for (var i = 0; i < this.areas.length; ++i)
        {
            var areaSeries = this.areas[i].ySeries;
            for (var j = 0; j < areaSeries.length; ++j)
            {
                if(areaSeries[j].kind == "TA_LIB") {
                    continue;
                }

                if (results.indexOf(areaSeries[j]) === -1)
                {
                    results.push(areaSeries[j]);
                }
            }
        }

        return results;
    };

    iChart.Charting.Chart.prototype.loadMissingData = function ()
    {
        /// <summary>
        /// Tries to load data points missing in the current viewport. Does nothing if data request is in progress or if there is no missing data.
        /// </summary>
        var area = this.areas[0];
        if (this._dataStart)
        {
            var before = Math.round(area.xSeries.min - this.viewport.x.min);
            if (before > 0)
            {
                var params = $.extend(true, {}, this._dataSettings);
                params.count = -Math.max(this.dataCountAdapt(before), before);//-this.seriesCountAdapt();
                params.intervalMode = "OpenRay";
                params.start = iChart.formatDateTime(this._dataStart);
                delete params.end;

                /*
                var viewMin = area.xSeries.min;
                var viewMax = Math.floor(this.viewport.x.max);
                var dt = Math.round((area.xSeries[viewMax] - area.xSeries[viewMin]) / 2);
                var startTimeStmp = iChart.parseDateTime(params.start).getTime() - dt * 1000;
                var date_from = new Date(startTimeStmp);
                */

                var date_from = iChart.parseDateTime(params.start);
                var date_to = iChart.parseDateTime(params.start);

                date_from.setHours(0);
                date_from.setMinutes(0);
                date_from.setSeconds(0);

                date_to.setHours(0);
                date_to.setMinutes(0);
                date_to.setSeconds(0);

                if(params.timeframe == 1440) {
                    date_from.setMonth(0);
                    date_from.setDate(0);
                    date_to.setFullYear(date_to.getFullYear()+1,0,0);
                    params.count = -1;
                } else if(params.timeframe == 60) {
                    date_from.setMonth(date_from.getMonth()-1);
                    date_from.setDate(0);
                    date_to.setMonth(date_to.getMonth()+1);
                    date_to.setDate(0);
                    params.count = -1;
                } else if(params.timeframe == 15) {
                    date_from.setMonth(date_from.getMonth()-1);
                    date_from.setDate(0);
                    date_to.setMonth(date_to.getMonth()+1);
                    date_to.setDate(0);
                    params.count = -1;
                } else if(params.timeframe == 5) {
                    date_to.setDate(date_to.getDate() + (7 - (date_to.getDay() == 0 ? 7 : date_to.getDay())));
                    date_from.setDate(date_from.getDate() - (date_from.getDay() == 0 ? 7 : date_from.getDay()));
                    params.count = -1;
                } else if(params.timeframe == 1) {
                    date_to.setDate(date_to.getDate() + 1);
                    date_from.setDate(date_from.getDate() - 1);
                    params.count = -100;
                }

                params.date_from = iChart.formatDateTime(date_from, "dd.MM.yyyy HH:mm");
                params.date_to = iChart.formatDateTime(date_to, "dd.MM.yyyy HH:mm");
                params.start = params.date_to;

                this.requestData(params, false, false);
                return;
            }
        }

        if (this._dataEnd)
        {
            var after = Math.round(this.viewport.x.max - area.xSeries.max);
            if (after > 0)
            {
                var params = $.extend(true, {}, this._dataSettings);
                params.count = Math.max(this.dataCountAdapt(after), after) + this.chartOptions.futureAmount;
                params.intervalMode = "OpenRay";
                params.start = iChart.formatDateTime(this._dataEnd);
                params.date_to = iChart.formatDateTime(this._dataEnd, "dd.MM.yyyy HH:mm");
                delete params.end;
                this.requestData(params, false, false);
            }
        }
    };


    iChart.Charting.Chart.prototype.dataCountAdapt = function (countC)
    {
        var k = 50;
        switch (this._dataSettings.timeframe) {
            case 1:
                k = 500;
                break;
            case 5:
                k = 300;
                break;
            case 15:
                k = 200;
                break;
            case 30:
                k = 150;
                break;
            case 60:
                k = 120;
                break;
            case 1440:
                k = 100;
                break;
        }
        return k+countC;
    }

    iChart.Charting.Chart.prototype.pan = function (direction)
    {
        /// <summary>
        /// Pans the chart in the specified direction for the predefined distance.
        /// </summary>
        /// <param name="direction" type="String">Pan direction (top, left, bottom, or right).</param>

        var area;
        for (var i = 0; i < this.areas.length; ++i)
        {
            area = this.areas[i];
            if (area.name === this.viewport.areaName)
            {
                break;
            }

            area = null;
        }

        if (area === null)
        {
            area = this.areas[0];
        }

        this.viewport.areaName = area.name;

        if (direction === "left" || direction === "right")
        {
            if (this.viewport.x.min === null)
            {
                this.viewport.x.min = area.viewport.x.bounded.min;
            }

            if (this.viewport.x.max === null)
            {
                this.viewport.x.max = area.viewport.x.bounded.max;
            }

            var delta = Math.max(1, this.chartOptions.panStep * (this.viewport.x.max - this.viewport.x.min));
            if (direction === "left")
            {
                delta *= -1;
            }

            this.viewport.x.min += delta;
            this.viewport.x.max += delta;
        }
        else if (direction === "top" || direction === "bottom")
        {
            if (this.viewport.y.min === null)
            {
                this.viewport.y.min = area.viewport.y.min;
            }

            if (this.viewport.y.max === null)
            {
                this.viewport.y.max = area.viewport.x.max;
            }

            var delta = this.chartOptions.panStep * (this.viewport.y.max - this.viewport.y.min);
            if (direction === "bottom")
            {
                delta *= -1;
            }

            this.viewport.y.min += delta;
            this.viewport.y.max += delta;
        }
        else
        {
            return;
        }

        this._fixViewportBounds();
        this.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": true });
        this.loadMissingData();
    };

    iChart.Charting.Chart.prototype.parseDataSettings = function (settings)
    {
        /// <summary>
        /// Parses chart data settings, converting them to the standard format.
        /// </summary>
        /// <param name="settings" type="Object">Chart data settings.</param>
        /// <returns type="Object" />

        var result = $.extend(true, {}, settings);
        result.start = iChart.parseDateTime(result.start);
        result.end = iChart.parseDateTime(result.end);
        result.timeframe = parseInt(result.timeframe, 10);

        if (isNaN(Date.parse(result.date_from))) {
            result.date_from = new Date();
        }

        if (isNaN(Date.parse(result.date_to))) {
            result.date_to = new Date();
        }


        return result;
    };

    iChart.Charting.Chart.prototype.render = function (params, bySchedule)
    {
        /// <summary>
        /// Renders the chart to the current canvas context. Does nothing if no chart areas were created.
        /// </summary>
        /// <param name="params" type="Object">
        ///     Settings map:
        ///     &#10;   context - a canvas context to which the chart should be rendered (optional, created automatically if not specified);
        ///     &#10;   forceRecalc - a boolean value indicating whether the chart elements positions should be recalculated such as when panning, resizing or zooming;
        ///     &#10;   resetViewport - a boolean value indicating whether the chart viewport should be reset to default bounds;
        ///     &#10;   testForIntervalChange - a boolean value indicating whether the viewport interval change should be tested for.
        /// </param>


        if (!this.areas)
        {
            console.log('No ares to render. Abort');
            return false;
        }

        if (params.context && params.forceRecalc)
        {
            throw new Error("Parameters 'forceRecalc' and 'context' parameters cannot be specified at the same time.");
        }

        if (params.resetViewport)
        {
            this.viewport.x.min = null;
            this.viewport.x.max = null;
            this.viewport.y.min = null;
            this.viewport.y.max = null;
        }

        var area;
        var areaViewport;
        var context = params.context;
        if (params.forceRecalc)
        {
            this._positionAreas();

            if (!this.canvas)
            {
                console.log('No canvas to render. Abort');
                return false;
            }

            context = iChart.getContext(this.canvas);

            areaViewport = {};
            areaViewport.x = {};
            areaViewport.x.min = this.viewport.x.min;
            areaViewport.x.max = this.viewport.x.max;
            areaViewport.y = {};
            for (var i = 0; i < this.areas.length; ++i)
            {
                area = this.areas[i];
                if (area.name === this.viewport.areaName)
                {
                    areaViewport.y.min = this.viewport.y.min;
                    areaViewport.y.max = this.viewport.y.max;
                }
                else
                {
                    areaViewport.y.min = null;
                    areaViewport.y.max = null;
                }

                area.calculateInnerDimensions(areaViewport);
            }
        }

        this.onPreRender.call(this, params, context);
        this.renderer.renderChart(context);
        this.onPostRender.call(this, params, context);

        if (params.forceRecalc)
        {
            if (this.widgetLay)
            {
                this.widgetLay.update();
            }

            if (this.overlay)
            {
                this.overlay.update();
            }
        }

        if (typeof FlashCanvas !== "undefined")
        {
            // Flush and execute commands.
            context.e();
        }


        if (params.testForIntervalChange)
        {
            this._testForIntervalChange(bySchedule);
        }

        return true;
        //GTi: доработка убирающая запрос при рисовании после масштабиромания
        //this._dataSettings.start = iChart.parseDateTime(iChart.formatDateTime(new Date(this.areas[0].xSeries[this.areas[0].viewport.x.bounded.min] * 1000), "dd.MM.yyyy"));
        //this._dataSettings.end = iChart.parseDateTime(iChart.formatDateTime(new Date(this.areas[0].xSeries[this.areas[0].viewport.x.bounded.max] * 1000), "dd.MM.yyyy 23:59"));
    };

    iChart.Charting.Chart.prototype.requestData = function (params, resetData, resetViewport, bySchedule)
    {
        /// <summary>
        /// Requests chart data with the specified parameters.
        /// </summary>
        /// <param name="params" type="Object">Data request parameters.</params>
        /// <param name="resetData" type="Boolean">A value indicating whether the existing data should be overwritten by the requested data.</params>
        /// <param name="resetViewport" type="Boolean">A value indicating whether the current viewport should be reset to its default bounds.</params>
        var indicatorKey = new RegExp("^i[0-9]+$", "i");
        for (var key in params)
        {
            if (indicatorKey.test(key) && params[key]) {
                if(this.env.viewData.indicators[params[key]] && this.env.viewData.indicators[params[key]]['type'] == 'TA_LIB') {
                    params[key] = '';
                }
            }
        }

        if (this._dataLoading)
        {
            return;
        }
        this._dataLoading = true;
        this.touches.disabled = true;
        var self = this;
        var amountUpdated = 0;
        var callback = function (data)
        {
            self.setWarnings(data.warnings);
            if (data.success)
            {
                amountUpdated = self.updateData(data, params, resetData);
                self.render({ "forceRecalc": true, "resetViewport": resetViewport, "testForIntervalChange": true }, bySchedule);
            }

            setTimeout(function() {self.scheduleUpdate();}, 2000);
            self._dataLoading = false;

            if(self && self.areas && amountUpdated) {
                if (self.areas[0].xSeries.min > self.viewport.x.min) {
                    self.loadMissingData();
                }
            }
            self.indicatorsApply();
        };
        //this.dataCallback.call(this, params, callback, bySchedule);
        this.env.dataSource.onRequest(callback, params)
    };

    iChart.Charting.Chart.prototype.indicatorsApply = function () {

        if(typeof this.env.TA != "undefined") {

            var updatedIndicators = {};
            if (this.areas) {

                for (var i = 0; i < this.areas.length; ++i) {
                    var a = this.areas[i];
                    for (var j = 0; j < a.ySeries.length; ++j) {
                        if (a.ySeries[j].kind === "TA_LIB") {
                            var index = a.ySeries[j].indicatorIndex,
                                indicator = a.ySeries[j].name,
                                params = $.extend(true, {}, a.ySeries[j].params);

                            if (this.env.TA[indicator] && !updatedIndicators[indicator + "/" + index]) {
                                this.env.TA[indicator](0, index);
                                this.env.TA[indicator](1, index, params);
                                updatedIndicators[indicator + "/" + index] = true;
                            }
                        }
                    }
                }
            }

            var _this = this;
            var indicators = iChart.parseQueryString(this.env.dataSource.dataSettings.graphicIndicators);
            $.each(indicators, function (n, i) {
                if(i && n.match(/^i[0-9]+$/) && _this.env.viewData.indicators[i] && _this.env.viewData.indicators[i].type == "TA_LIB") {
                    var index = n.match(/^i([0-9]+)$/)[1];
                    if(!updatedIndicators[i + "/" + index]) {
                        var params = {};
                        for (var p = 0; p < _this.env.viewData.indicators[i].parameters.length; p++) {
                            var iParam = _this.env.viewData.indicators[i].parameters[p];
                            var paramCode = _this.env.TA.mapParam(iParam.Code);
                            if ((indicators[n + "_" + paramCode])) {
                                params[iParam.Code] = +(indicators[n + "_" + paramCode]);
                            } else {
                                params[iParam.Code] = +(indicators[n + "_" + iParam.Code]) || iParam.Value;
                            }
                        }
                        _this.env.TA[i](0, index);
                        _this.env.TA[i](1, index, params);
                    }
                }
            });
        }

    };

    iChart.Charting.Chart.prototype.resetZoom = function ()
    {
        /// <summary>
        /// Resets chart zoom to the default values.
        /// </summary>

        this.render({ "forceRecalc": true, "resetViewport": true, "testForIntervalChange": true });
    };

    iChart.Charting.Chart.prototype.resize = function ()
    {
        /// <summary>
        /// Resizes the chart to the container's width.
        /// </summary>

        this._resized = true;
        this.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
        this.selection.recalculateContainerPosition();
    };

    iChart.Charting.Chart.prototype.scheduleUpdate = function ()
    {
        /// <summary>
        /// Schedules next chart update at the currently selected update interval.
        /// </summary>

        clearTimeout(this.env.timers.scheduleUpdate);
        if (this.chartOptions.updateInterval && this._dataSettings.id == this.env.viewData.chart._dataSettings.id)
        {
            if($(this.env.container).length) {
                this.env.timers.scheduleUpdate = setTimeout($.proxy(this.update, this, true), this.env.viewData.chart._dataSettings.timeframe * 20000); // 1/3 от периода в милисекундах
            }
        }
    };

    iChart.Charting.Chart.prototype.setChartType = function (chartType)
    {
        /// <summary>
        /// Redraws the chart using the specified chart type.
        /// </summary>
        /// <param name="chartType" type="String">New chart type (Candlestick, Line, Stock).</param>

        if (this.chartOptions.chartType === chartType || this.isComparison)
        {
            return;
        }

        this.chartOptions.chartType = chartType;
        this.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
    };

    iChart.Charting.Chart.prototype.setDataSettings = function (settings, force)
    {
        /// <summary>
        /// Sets specified data settings. Returns a value indicating whether any of the settings changed (chart is updated in that case).
        /// </summary>
        /// <param name="settings" type="Object">New chart data settings.</param>
        /// <returns type="Boolean" />
        var oldSettings = this._dataSettings;
        this._dataSettings = this.parseDataSettings(settings);
        var request = $.extend(true, {}, this._dataSettings);

        if(typeof oldSettings != "undefined") {
            var changes = {};
            if(oldSettings.interval != this._dataSettings.interval) {
                changes.interval = this._dataSettings.interval;
                this.env.wrapper.trigger('iguanaChartEvents', ['intervalChange', this._dataSettings.interval]);
            }
            if(oldSettings.id != this._dataSettings.id) {
                changes.id = this._dataSettings.id;
            }
            if(oldSettings.type != this._dataSettings.type) {
                changes.type = this._dataSettings.type;
            }
            if(Object.keys(changes).length) {
                this.env.wrapper.trigger('iguanaChartEvents', ['settingsChange', changes]);
            }
        }

        var min = new Date(1800, 0, 1);
        var max = this.historyEnd || new Date();
        var start = (request.start || min).getTime();
        var end = (request.end || max).getTime();
        //console.log('setDataSettings:',JSON.parse(JSON.stringify(request)));
        //console.log('setDataSettings:', min, max, start, end, oldSettings && oldSettings.id === request.id && oldSettings.timeframe === request.timeframe && !force);
        if (oldSettings && oldSettings.id === request.id && oldSettings.timeframe === request.timeframe && !force)
        {
            var equal = true;
            var indicatorKey = new RegExp("^i[0-9]+(_.*)?$", "i");
            for (var key in oldSettings)
            {
                if (oldSettings.hasOwnProperty(key) && indicatorKey.test(key))
                {
                    if (!request.hasOwnProperty(key) || oldSettings[key] !== request[key])
                    {
                        equal = false;
                        break;
                    }
                }
            }

            if (equal)
            {
                for (var key in request)
                {
                    if (request.hasOwnProperty(key) && indicatorKey.test(key))
                    {
                        if (!oldSettings.hasOwnProperty(key) || oldSettings[key] !== request[key])
                        {
                            equal = false;
                            break;
                        }
                    }
                }
            }

            if (equal)
            {
                var oldStart = (oldSettings.start || min).getTime();
                var oldEnd = (oldSettings.end || max).getTime();
                if (oldStart == start && oldEnd === end)
                {
                    return false;
                }

                oldStart = (this._dataStart || min).getTime();
                oldEnd = (this._dataEnd || max).getTime();
                if (oldStart <= start && end <= oldEnd)
                {
                    this.env.wrapper.trigger('iguanaChartEvents', ['clearLoader']);
                    this.render({ "forceRecalc": true, "resetViewport": true, "testForIntervalChange": true });
                    return true;
                }

                if (start < oldStart && oldEnd === end)
                {
                    request.intervalMode = "OpenRay";
                    request.count = -Math.max(this.dataCountMin, Math.round((oldStart - start) / (request.timeframe * 60000)) + 50);
                    request.start = new Date(oldStart);
                }
                else if (oldStart == start && oldEnd < end)
                {
                    request.intervalMode = "OpenRay";
                    request.count = Math.max(this.dataCountMin, Math.round((end - oldEnd) / (request.timeframe * 60000)) + 50);
                    request.start = new Date(oldEnd);
                }
            }
        }

        var resetData = !request.intervalMode;
        if (resetData)
        {
            request.intervalMode = "ClosedRay";
            request.count = -Math.max(this.dataCountMin, Math.round((end - start) / (request.timeframe * 60000) / 2));
            request.start = request.end;

            var date_to = iChart.parseDateTime(request.date_to);
            var date_from = iChart.parseDateTime(request.date_from);

            if(request.timeframe == 1440) {
                date_to.setFullYear(date_to.getFullYear() - 5);
                date_from = new Date(Math.max(date_from.getTime(), date_to.getTime()));
                date_from.setMonth(0);
                date_from.setDate(0);
                request.count = -1;
            } else if(request.timeframe == 60) {
                date_to.setMonth(date_to.getMonth() - 3);
                date_from = new Date(Math.max(date_from.getTime(), date_to.getTime()));
                date_from.setMonth(date_from.getMonth() - 1);
                date_from.setDate(0);
                request.count = -10;
            } else if(request.timeframe == 15) {
                date_to.setMonth(date_to.getMonth() - 1);
                date_from = new Date(Math.max(date_from.getTime(), date_to.getTime()));
                date_from.setDate(0);
                request.count = -10;
            } else if(request.timeframe == 5) {
                date_to.setDate(date_to.getDate() - 14);
                date_from = new Date(Math.max(date_from.getTime(), date_to.getTime()));
                date_from.setHours(0);
                date_from.setMinutes(0);
                date_from.setSeconds(0);
                date_from.setDate(date_from.getDate() - date_from.getDay());
                request.count = -100;
            } else if(request.timeframe == 1) {
                date_to.setDate(date_to.getDate() - 5);
                date_from = new Date(Math.max(date_from.getTime(), date_to.getTime()));
                date_from.setHours(0);
                date_from.setMinutes(0);
                date_from.setSeconds(0);
                date_from.setDate(date_from.getDate() - 1);
                request.count = -200;
            }

            date_from.setHours(0);
            date_from.setMinutes(0);
            date_from.setSeconds(0);

            request.date_from = iChart.formatDateTime(date_from, "dd.MM.yyyy HH:mm");
        }

        delete request.end;
        request.start = iChart.formatDateTime(iChart.parseDateTime(request.start), "dd.MM.yyyy HH:mm");
        this.requestData(request, resetData, true);
        return true;
    };

    iChart.Charting.Chart.prototype.setSelectionMode = function (mode)
    {
        /// <summary>
        /// Sets selection mode to the specified value.
        /// </summary>
        /// <param name="mode" type="String">New selection mode (pan or zoom).</param>

        if (!this.container) return;

        switch (mode)
        {
            case "pan":
                this.container.style.cursor = this.overlay.defaultCursor
                        = MOBILE_BROWSER_DETECTED ? "move" : "url('" + this.env.lib_path + "/styles/cursors/grab.cur'), move";
                break;
            case "zoom":
                this.container.style.cursor = this.overlay.defaultCursor = "crosshair";
                break;
            case "wait":
                this.container.style.cursor = this.overlay.defaultCursor = "wait";
                break;
            default:
                throw new Error("Selection mode '" + mode + "' is invalid.");
        }

        this.selection.mode = mode;
    };

    iChart.Charting.Chart.prototype.setWarnings = function (warnings)
    {
        /// <summary>
        /// Shows the specified warnings on the chart. Previous warnings are removed.
        /// </summary>
        /// <param name="warnings" type="Array" elementType="String">A list of warnings to display.</param>

        var $warnings = $(".m-chart-warnings", this.container);
        if (!warnings || !warnings.length)
        {
            $warnings.hide();
            return;
        }

        if ($warnings.length === 0)
        {
            $warnings = $("<div/>", { "class": "m-chart-warnings" }).appendTo(this.container);
        }
        else
        {
            $warnings.show();
        }

        $warnings.text(warnings.join("\r\n"));
    };

    iChart.Charting.Chart.prototype.showTime = function ()
    {
        /// <summary>
        /// Gets a value indicating whether the time should be shown based on the current chart timeframe.
        /// </summary>
        /// <returns type="Boolean" />

        return parseInt(this._dataSettings.timeframe, 10) % 1440 !== 0;
    };

    iChart.Charting.Chart.prototype.toBase64 = function (mimeType)
    {
        var data = this.toBase64withSize(mimeType);
        return data.string;
    };
    iChart.Charting.Chart.prototype.toBase64withSize = function (mimeType)
    {
        /// <summary>
        /// Generates chart image with the specified MIME type encoded as a Base64 string.
        /// </summary>
        /// <param name="mimeType" type="String">Image MIME type. Valid values are 'image/jpeg' and 'image/png'.</param>
        /// <returns type="String">Chart image encoded as a Base64 string.</return>

        var canvas = document.createElement("canvas");
        canvas.id = "iChart-chart";
        canvas.style.left = 0;
        canvas.style.position = "absolute";
        canvas.style.top = -getElementSize(this.canvas).height;
        document.body.appendChild(canvas);
        if (typeof canvas.getContext === "undefined")
        {
            if (typeof FlashCanvas === "undefined")
            {
                alert(_t("87550", "Ваш браузер не поддерживается."));
                return;
            }

            FlashCanvas.initElement(canvas);
        }

        canvas.width = this.canvas.width;
        canvas.height = this.canvas.height;
        var context = iChart.getContext(canvas);
        this.render({'context': context, 'forceRecalc': false, 'resetViewport': false, 'testForIntervalChange': false});
        this.overlay.render(context);
        this.renderer.renderLegends(context);
        var data = canvas.toDataURL(mimeType);
        $(canvas).remove();
        var marker = ';base64,';
        return {
            'string': data.substring(data.indexOf(marker) + marker.length),
            'height': canvas.height,
            'width': canvas.width
        };
    };

    iChart.Charting.Chart.prototype.update = function (bySchedule)
    {
        /// <summary>
        /// Used for periodic chart updates. Fetches new data if date/time interval is right-open.
        /// </summary>
//        console.log(this._dataEnd);
//        if (this._dataEnd)
//        {
//            return;
//        }

        var params = $.extend(true, {}, this._dataSettings);
        params.intervalMode = "ClosedRay";
        if(bySchedule) {
            params.intervalMode = "OpenRay";
        }
        params.count = this.dataCountMin;

        var series = this.areas[0].xSeries;
        if (series.length !== 0)
        {
            params.date_from = iChart.formatDateTime(new Date(1000 * series[series.length - this.chartOptions.futureAmount - 1]), "dd.MM.yyyy HH:mm");
            params.date_to = params.date_from;
            params.start = params.date_from;
        }

        delete params.end;
        this.requestData(params, false, false, bySchedule);
    };

    iChart.Charting.Chart.prototype.updateData = function (data, params, resetData)
    {
        /// <summary>
        /// Updates chart data set with the specified data.
        /// </summary>
        /// <param name="data" type="Object">Chart data.</param>
        /// <param name="params" type="Object">Data request parameters.</param>
        /// <param name="resetData" type="Boolean">A value indicating whether the existing data should be overwritten by the requested data.</params>

        if (params.intervalMode !== "ClosedRay" && params.intervalMode !== "OpenRay")
        {
            throw new Error("Interval mode '" + params.intervalMode + "' is invalid.");
        }

        if (params.count < 0)
        {
            if (data.xSeries.length < -params.count)
            {
                this._dataStart = null;
            }
            else
            {
                this._dataStart = new Date(1000 * data.xSeries[0]);
            }

            if (resetData)
            {
                this._dataEnd = iChart.parseDateTime(params.start);
            }
        }
        else
        {
            if (resetData)
            {
                this._dataStart = iChart.parseDateTime(params.start);
            }

            if (data.xSeries.length < params.count)
            {
                this._dataEnd = null;
            }
            else
            {
                this._dataEnd = new Date(1000 * data.xSeries[data.xSeries.length - 1]);
            }
        }

        if (data.xSeries.length !== 0)
        {
            var end = new Date(1000 * data.xSeries[data.xSeries.length - 1]);
            if (!this.historyEnd || end.getTime() > this.historyEnd.getTime())
            {
                this.historyEnd = end;
            }
        }

        if (resetData)
        {
            return this._setData(data, params);
        }
        else if (data.xSeries.length !== 0)
        {
            var amount = this._mergeData(data, params);

            if (params.count < 0 && !amount)
            {
                this._dataStart = null;
            } else if (params.count > 0 && !amount) {
                this._dataEnd = null;
            }
            return amount;
        }
    };

    iChart.Charting.Chart.prototype.zoom = function (level)
    {
        /// <summary>
        /// Zooms the chart for the specified amount.
        /// </summary>
        /// <param name="level" type="Number">Zoom level. Positive values are for zooming in, negative values are for zooming out.</param>

        this._zoomInternal(null, level);
    };

    /**
     * Добавление пустышек для расширения оси
     */
    iChart.Charting.Chart.prototype.addFuture = function () {

        var xSeries = this.areas[0].xSeries;
        var params = this._dataSettings;
        if(this.chartOptions.futureAmount) {
            var step = params.timeframe * 60;
            for(var i=0;i<this.chartOptions.futureAmount;i++) {
                xSeries.push(xSeries[xSeries.length-1]+step);
            }
        }

        var ySeriesCollection = $.grep(this.getSeriesCollection(), function (x) { return x.enableMerge; });

        for (var i = 0; i < ySeriesCollection.length; ++i)
        {
            var series = ySeriesCollection[i];

            if(this.chartOptions.futureAmount) {
                if(series.valuesPerPoint==1) {
                    for(var j=0;j<this.chartOptions.futureAmount;j++) {
                        series.points.push([null]);
                    }
                } else {
                    for(var j=0;j<this.chartOptions.futureAmount;j++) {
                        series.points.push([null,null,null,null]);
                    }
                }
            }
        }

        for (var i = 0; i < this.areas.length; ++i)
        {
            this.areas[i].setMinMax();
        }

        this._setXLabelFormat();
    }

    /**
     * Удаление пустышек
     */
    iChart.Charting.Chart.prototype.removeFuture = function () {
        var xSeries = this.areas[0].xSeries;

        if(this.chartOptions.futureAmount) {
            xSeries.splice(-this.chartOptions.futureAmount,this.chartOptions.futureAmount);
        }

        var ySeriesCollection = $.grep(this.getSeriesCollection(), function (x) { return x.enableMerge; });
        if(this.chartOptions.futureAmount) {
            for (var i = 0; i < ySeriesCollection.length; i++)
            {
                ySeriesCollection[i].points.splice(-this.chartOptions.futureAmount,this.chartOptions.futureAmount);
            }
        }

        for (var i = 0; i < this.areas.length; ++i)
        {
            this.areas[i].setMinMax();
        }

        this._setXLabelFormat();

    }

    iChart.Charting.Chart.prototype._fixViewportBounds = function ()
    {
        /// <summary>
        /// Limits viewport bounds to prevent zooming and panning too far.
        /// </summary>

        var area = null;
        for (var i = 0; i < this.areas.length; ++i)
        {
            if (this.areas[i].name === this.viewport.areaName)
            {
                area = this.areas[i];
            }
        }

        if (area === null)
        {
            return;
        }

        var epsilon;
        var delta;

        if (this.viewport.x.min !== null && this.viewport.x.max !== null)
        {
            epsilon = 0.7 * (this.viewport.x.max - this.viewport.x.min);
            delta = this.viewport.x.max - (area.xSeries.max - area.chart.chartOptions.futureAmount) - epsilon;

            if (delta > 0)
            {
                this.viewport.x.min -= delta;
                this.viewport.x.max -= delta;
            }
            else
            {
                delta = area.xSeries.min - this.viewport.x.min - epsilon;
                if (delta > 0)
                {
                    this.viewport.x.min += delta;
                    this.viewport.x.max += delta;
                }
            }
        }

        if (this.viewport.y.min !== null && this.viewport.y.max !== null)
        {
            epsilon = 0.7 * (this.viewport.y.max - this.viewport.y.min);
            delta = this.viewport.y.max - area.ySeries.bounds.max - epsilon;
            if (delta > 0)
            {
                this.viewport.y.min -= delta;
                this.viewport.y.max -= delta;
            }
            else
            {
                delta = area.ySeries.bounds.min - this.viewport.y.min - epsilon;
                if (delta > 0)
                {
                    this.viewport.y.min += delta;
                    this.viewport.y.max += delta;
                }
            }
        }
    };

    iChart.Charting.Chart.prototype._mergeData = function (data, params)
    {
        /// <summary>
        /// Updates chart data with the specified data set.
        /// </summary>
        /// <param name="data" type="Object">Data to merge into the existing data set.</param>
        /// <param name="params" type="Object">Data request parameters.</param>

        var includesEndpoint = false;
        var xSeries = this.areas[0].xSeries;
        var xSeriesOldCount = xSeries.length;


        if(this.chartOptions.futureAmount) {
            xSeries.splice(-this.chartOptions.futureAmount,this.chartOptions.futureAmount);
        }

        var ySeriesCollection = $.grep(this.getSeriesCollection(), function (x) { return x.enableMerge; });
        if(this.chartOptions.futureAmount) {
            for (var i = 0; i < ySeriesCollection.length; i++)
            {
                ySeriesCollection[i].points.splice(-this.chartOptions.futureAmount,this.chartOptions.futureAmount);
            }
        }

        if (params.count < 0)
        {

            var i = data.xSeries.length - 1;
            var indexTop = i;

            while(data.xSeries[i] > xSeries[0] && i >0) {
                i--;
            }
            var indexTopCut = i;
            data.xSeries.splice(indexTopCut, indexTop-indexTopCut+1);

            for (var j = data.ySeries.length - 1; j >= 0; --j)
            {
                data.ySeries[j].points.splice(indexTopCut, indexTop-indexTopCut+1);
            }

            var shift = data.xSeries.length;
            if (data.xSeries[data.xSeries.length - 1] === xSeries[0])
            {
                xSeries.splice(0, 1);
                --shift;
                includesEndpoint = true;
            }

            if (this.viewport.x.min !== null)
            {
                this.viewport.x.min += shift;
            }

            if (this.viewport.x.max !== null)
            {
                this.viewport.x.max += shift;
            }

            if (this.selection)
            {
                this.selection.shiftAnchor(shift);
            }

            for (var j = data.xSeries.length - 1; j >= 0; --j)
            {
                xSeries.splice(0, 0, data.xSeries[j]);
            }

        }
        else
        {
            var iXLength = xSeries.length;
            var iX = iXLength;
            var count = 0;
            while(xSeries[iX-1] >= data.xSeries[0]) {
                iX--;
            }

            if(xSeries[iX] != data.xSeries[0] && iX != iXLength) {
                count = 1;
            }

            iX = iX-count;

            xSeries.splice(iX, data.xSeries.length);

            for (var j = 0; j < data.xSeries.length; ++j)
            {
                xSeries.splice(iX + j, 0, data.xSeries[j])
            }

            for(var i =0; i < ySeriesCollection.length; i++)
            {
                ySeriesCollection[i].points.splice(iX, data.xSeries.length);
            }

        }

        if(this.chartOptions.futureAmount) {
            var timeframe = params.timeframe || this.env.dataSource.dataSettings.timeframe;
            var step = timeframe * 60;
            for(var i=0;i<this.chartOptions.futureAmount;i++) {
                xSeries.push(xSeries[xSeries.length-1]+step);
            }
        }

        var hlocAreaSeries = [];
        var volumeAreaSeries = [];
        var indicatorAreaSeries = {};
        for (var i = 0; i < data.ySeries.length; ++i)
        {
            var series = data.ySeries[i];
            switch (series.kind)
            {
                case "HLOC":
                    hlocAreaSeries.push(series);
                    break;
                case "TechnicalAnalysis":
                    if (series.overlay)
                    {
                        hlocAreaSeries.push(series);
                    }
                    else
                    {
                        if (typeof indicatorAreaSeries[series.indicatorIndex] === "undefined")
                        {
                            indicatorAreaSeries[series.indicatorIndex] = [series];
                        }
                        else
                        {
                            indicatorAreaSeries[series.indicatorIndex].push(series);
                        }
                    }

                    break;
                case "Volume":
                        volumeAreaSeries.push(series);
                    break;
                default:
                    continue;
            }
        }

        var ySeriesCollectionNew = [];
        for (var i = 0; i < hlocAreaSeries.length; ++i)
        {
            ySeriesCollectionNew.push(hlocAreaSeries[i]);
        }

        if(!this.isComparison) {
            for (var i = 0; i < volumeAreaSeries.length; ++i)
            {
                ySeriesCollectionNew.push(volumeAreaSeries[i]);
            }
        }

        for (var key in indicatorAreaSeries)
        {
            if (indicatorAreaSeries.hasOwnProperty(key))
            {
                for (var i = 0; i < indicatorAreaSeries[key].length; ++i)
                {
                    ySeriesCollectionNew.push(indicatorAreaSeries[key][i]);
                }
            }
        }

        if (ySeriesCollection.length > ySeriesCollectionNew.length)
        {
            throw new Error("Y series count mismatch while merging chart data, expected " + ySeriesCollection.length + ", got " + ySeriesCollectionNew.length + ".");
        }

        for (var i = 0; i < ySeriesCollection.length; ++i)
        {
            var series = ySeriesCollection[i];
            var seriesNew = ySeriesCollectionNew[i];
            if (series.kind !== seriesNew.kind)
            {
                //throw new Error("Y series kind mismatch while merging chart data.");
                continue;
            }

            if (params.count < 0)
            {
                if (includesEndpoint)
                {
                    series.points.splice(0, 1);
                }

                for (var j = seriesNew.points.length - 1; j >= 0; --j)
                {
                    series.points.splice(0, 0, seriesNew.points[j]);
                }
            }
            else
            {
                if (includesEndpoint)
                {
                    series.points.pop();
                }

                for (var j = 0; j < seriesNew.points.length; ++j)
                {
                    series.points.splice(iX + j, 0, seriesNew.points[j]);
                }
            }

            if(this.chartOptions.futureAmount) {
                if(series.valuesPerPoint==1) {
                    for(var j=0;j<this.chartOptions.futureAmount;j++) {
                        series.points.push([null]);
                    }
                } else {
                    for(var j=0;j<this.chartOptions.futureAmount;j++) {
                        series.points.push([null,null,null,null]);
                    }
                }
            }

        }

        for (var i = 0; i < this.areas.length; ++i)
        {
            this.areas[i].setMinMax();
        }

        this._setXLabelFormat();

        return xSeries.length - xSeriesOldCount;
    };

    iChart.Charting.Chart.prototype._mousewheelCallback = function (event)
    {
        /// <summary>
        /// Called when the mousewheel event occurs.
        /// </summary>
        /// <param name="event">Mousewheel event object.</param>
        /// <param name="delta" type="Number">Normalized mousewheel rotation.</param>

        if (!this.chartOptions.mousewheelZoom) {
            return;
        }

        var offset = $(this.container).offset();
        var x = event.pageX - offset.left;
        var y = event.pageY - offset.top;
        var position = this.findAreaAtPosition(x, y);
        var delta = event.deltaY;
        var deltaFactor = event.deltaFactor;
        if (position !== null) {
            this._zoomInternal(
                position.area,
                0.2 * delta * deltaFactor / 53,
                //position.insideX && position.insideY ? "xy" : position.insideX ? "x" : "y",
                "x",
                position.area.getXIndex(x - position.area.innerOffset.left),
                position.area.getYValue(y - position.area.innerOffset.top)
            );

            event.preventDefault();
        }
    };

    iChart.Charting.Chart.prototype.calculateHeight = function ()
    {
        var areas = this.areas ? $.grep(this.areas, function (x) { return x.enabled; }) : [];
        var primaryHeight;
        var secondaryHeight;
        var height = 0;
        var width = 0;

        if(this.chartOptions.uiTools.top) {
            var uiTopHeigth = this.env.ui.$topToolBarContainer.height();
        } else {
            var uiTopHeigth = 0;
        }

        if (this.chartOptions.minHeight && this.areas)
        {
            var heightWithoutScroller = this.chartOptions.minHeight - this.chartOptions.scrollerHeight - uiTopHeigth;
            var areaCount = $.grep(areas, function (x) { return !x.isLayer; }).length;
            secondaryHeight = Math.max(this.chartOptions.minAreaHeight, Math.floor(heightWithoutScroller / (areaCount + (this.chartOptions.scrollerHeight === 0 ? 0 : -1) + this.chartOptions.primaryToSecondaryAreaHeightRatio - 1)));
            primaryHeight = Math.floor(this.chartOptions.primaryToSecondaryAreaHeightRatio * secondaryHeight);
        }
        else
        {
            secondaryHeight = Math.round(this.chartOptions.primaryAreaHeight / this.chartOptions.primaryToSecondaryAreaHeightRatio);
            primaryHeight = this.chartOptions.primaryAreaHeight;
        }

        height += uiTopHeigth;

        if(this.areas) {
            for (var i = 0; i < areas.length; ++i)
            {
                var area = areas[i];
                if (area.isLayer)
                {
                    area.offset.left = 0;
                    area.outerWidth = width;
                    area.outerHeight = secondaryHeight;
                    area.offset.top = primaryHeight - area.outerHeight;
                }
                else
                {
                    area.offset.top = height;
                    area.offset.left = 0;
                    area.outerWidth = width;
                    area.outerHeight = area.name === "Scroller" ? this.chartOptions.scrollerHeight : area.name === "ChartArea1" ? primaryHeight : secondaryHeight;
                    area.updateCloseButton();
                    height += area.outerHeight + area.margin.bottom;
                }
            }
        } else {
            height += primaryHeight = primaryHeight + this.chartOptions.scrollerHeight;
        }
        return {height: height, primaryHeight: primaryHeight};
    };

    iChart.Charting.Chart.prototype._positionAreas = function ()
    {
        /// <summary>
        /// Positions chart areas vertically.
        /// </summary>

        if (!this.container) return;

        var $container = $(this.container);
        if($container.length && (this._resized || !this._containerSize.height || !this._containerSize.width)) {
            this._containerSize.height = $container.height();
            this._containerSize.width = $container.width();
            this._containerSize.offset = $container.offset();
            this._resized = false;
        }

        var containerHeight = this._containerSize.height;
        var containerWidth = this._containerSize.width;
        var areas = $.grep(this.areas, function (x) { return x.enabled; });
        var height = 0;
        var width = containerWidth;

        // Set outer dimensions.
        var primaryHeight;
        var secondaryHeight;

        if(this.chartOptions.uiTools.top) {
            var uiTopHeigth = this.env.ui.$topToolBarContainer.height();
        } else {
            var uiTopHeigth = 0;
        }

        if (this.chartOptions.minHeight)
        {
            var heightWithoutScroller = this.chartOptions.minHeight - this.chartOptions.scrollerHeight - uiTopHeigth;
            var areaCount = $.grep(areas, function (x) { return !x.isLayer; }).length;
            secondaryHeight = Math.max(this.chartOptions.minAreaHeight, Math.floor(heightWithoutScroller / (areaCount + (this.chartOptions.scrollerHeight === 0 ? 0 : -1) + this.chartOptions.primaryToSecondaryAreaHeightRatio - 1)));
            primaryHeight = Math.floor(this.chartOptions.primaryToSecondaryAreaHeightRatio * secondaryHeight);
        }
        else
        {
            secondaryHeight = Math.round(this.chartOptions.primaryAreaHeight / this.chartOptions.primaryToSecondaryAreaHeightRatio);
            primaryHeight = this.chartOptions.primaryAreaHeight;
        }

        for (var i = 0; i < areas.length; ++i)
        {
            var area = areas[i];
            if (area.isLayer)
            {
                area.offset.left = 0;
                area.outerWidth = width;
                area.outerHeight = secondaryHeight;
                area.offset.top = primaryHeight - area.outerHeight;
            }
            else
            {
                area.offset.top = height;
                area.offset.left = 0;
                area.outerWidth = width;
                area.outerHeight = area.name === "Scroller" ? this.chartOptions.scrollerHeight : area.name === "ChartArea1" ? primaryHeight : secondaryHeight;
                area.updateCloseButton();
                height += area.outerHeight + area.margin.bottom;
            }
        }

        // Set inner dimensions.
        var primaryArea = this.areas[0];
        primaryArea.axisX.paddingLeft = 10;
        primaryArea.axisX.paddingRight = 10;
        primaryArea.axisY.paddingTop = this.chartOptions.primaryAreaAxisYpaddingTop;
        primaryArea.axisY.paddingBottom = this.chartOptions.primaryAreaAxisYpaddingBottom;

        primaryArea.padding.bottom = this.chartOptions.areaPaddingBottom;
        primaryArea.padding.left = this.chartOptions.areaPaddingLeft;
        primaryArea.padding.right = this.chartOptions.yLabelsOutside ? this.chartOptions.areaPaddingRight : 0;
        primaryArea.padding.top = this.chartOptions.areaPaddingTop;

        for (var i = 1; i < this.areas.length; ++i)
        {
            var area = this.areas[i];
            switch (area.name)
            {
                case "ChartArea1":
                    break;
                case "ChartArea2":
                    area.axisX.paddingLeft = primaryArea.axisX.paddingLeft;
                    area.axisX.paddingRight = primaryArea.axisX.paddingRight;
                    area.axisY.paddingTop = 0;
                    area.axisY.paddingBottom = 0;
                    if (area.isLayer)
                    {
                        area.padding.bottom = primaryArea.padding.bottom;
                        area.padding.top = primaryArea.padding.top;
                    }
                    else
                    {
                        area.padding.bottom = 8;
                        area.padding.top = 18;
                    }

                    area.padding.left = primaryArea.padding.left;
                    area.padding.right = primaryArea.padding.right;
                    break;
                case "Scroller":
                    area.axisX.paddingLeft = primaryArea.axisX.paddingLeft;
                    area.axisX.paddingRight = primaryArea.axisX.paddingRight;
                    area.axisY.paddingTop = 10;
                    area.axisY.paddingBottom = 10;
                    area.padding.bottom = 32;
                    area.padding.left = primaryArea.padding.left;
                    area.padding.right = primaryArea.padding.right;
                    break;
                default:
                    area.axisX.paddingLeft = primaryArea.axisX.paddingLeft;
                    area.axisX.paddingRight = primaryArea.axisX.paddingRight;
                    area.axisY.paddingTop = 10;
                    area.axisY.paddingBottom = 10;
                    if (area.isLayer)
                    {
                        area.padding.bottom = primaryArea.padding.bottom;
                        area.padding.top = primaryArea.padding.top;
                    }
                    else
                    {
                        area.padding.bottom = 32;
                        area.padding.top = 0;
                    }

                    area.padding.left = primaryArea.padding.left;
                    area.padding.right = primaryArea.padding.right;
                    break;
            }
        }

        this.positionVolumeByPriceArea();

        var dimensions = this.onPositionAreas.call(this);
        if (dimensions)
        {
            width = dimensions.width || width;
            height = dimensions.height || height;
        }

        containerHeight = height;
        height += uiTopHeigth;

        this.canvas = iChart.Charting.initCanvas(this.container, this.canvas, containerWidth, containerHeight);

        $container.height(containerHeight);
    };

    iChart.Charting.Chart.prototype._selectionMouseDownCallback = function (selection)
    {
    };

    iChart.Charting.Chart.prototype._selectionMoveStartCallback = function (selection)
    {
        /// <summary>
        /// Called when the mouse selection starts.
        /// </summary>
        /// <param name="selection" type="iChart.Charting.ChartSelection">Selection container.</param>
        selection.moved = false;
        switch (selection.mode)
        {
            case "pan":
                selection.position1 = this.findAreaAtPosition(selection.x1, selection.y1);
                if (selection.position1 === null)
                {
                    break;
                }

                var area = selection.position1.area;
                if (selection.position1.insideX && selection.position1.insideY)
                {
                    selection.resizeScrollerL = area.isScroller && area.$scrollerOverlayCenterL.data("iChart-hover");
                    selection.resizeScrollerR = area.isScroller && !selection.resizeScrollerL && area.$scrollerOverlayCenterR.data("iChart-hover");

                    var areaViewport = area.isScroller ? area.scrollerViewport : area.viewport;
                    if (selection.resizeScrollerR)
                    {
                        selection.setAnchor(
                            this.viewport.x.max === null || this.viewport.areaName !== area.name ? areaViewport.x.max : this.viewport.x.max,
                            this.viewport.y.min === null || this.viewport.areaName !== area.name ? areaViewport.y.min : this.viewport.y.min);
                    }
                    else
                    {
                        selection.setAnchor(
                            this.viewport.x.min === null || this.viewport.areaName !== area.name ? areaViewport.x.min : this.viewport.x.min,
                            this.viewport.y.min === null || this.viewport.areaName !== area.name ? areaViewport.y.min : this.viewport.y.min);
                    }
                }
                else
                {
                    if (area.isScroller)
                    {
                        selection.position1 = null;
                        break;
                    }

                    if (selection.position1.insideX)
                    {
                        selection.setAnchor(area.getXIndex(selection.x1 - area.innerOffset.left), null);
                    }
                    else if (selection.position1.insideY)
                    {
                        selection.setAnchor(null, area.getYValue(selection.y1 - area.innerOffset.top));
                    }

                    selection.resizeScrollerL = false;
                    selection.resizeScrollerR = false;
                }

                if (selection.resizeScrollerL || selection.resizeScrollerR)
                {
                    this.container.style.cursor = this.overlay.defaultCursor = "ew-resize";
                }
                else
                {
                    this.container.style.cursor = this.overlay.defaultCursor
                        = MOBILE_BROWSER_DETECTED ? "move" : "url('" + this.env.lib_path + "/styles/cursors/grabbing.cur'), move";
                }

                break;
            case "zoom":
                selection.setAnchor(null, null);
                this.container.style.cursor = this.overlay.defaultCursor = "crosshair";
                break;
            case "wait":
                break;
            default:
                throw new Error("Selection mode '" + selection.mode + "' is invalid.");
        }
    };

    iChart.Charting.Chart.prototype._selectionMouseMoveCallback = function (selection)
    {
    };

    iChart.Charting.Chart.prototype._selectionMoveCallback = function (selection)
    {
        /// <summary>
        /// Called when the mouse selection moves.
        /// </summary>
        /// <returns type="Boolean">A value indicating whether the selection should be shown.</returns>

        selection.moved = true;
        switch (selection.mode)
        {
            case "pan":
                if (selection.position1 === null)
                {
                    break;
                }

                selection.position2 = this.findAreaAtPosition(selection.x2, selection.y2);
                if (selection.position2 === null)
                {
                    break;
                }

                if (selection.position2.area !== selection.position1.area || selection.position2.insideX !== selection.position1.insideX || selection.position2.insideY !== selection.position1.insideY)
                {
                    break;
                }

                var area = selection.position1.area;

                if (selection.position1.insideX && selection.position1.insideY)
                {
                    var areaViewport = area.isScroller ? area.scrollerViewport : area.viewport;
                    var deltaX = (area.isScroller ? -1 : 1) * (area.getXIndex(selection.x2 - area.innerOffset.left) - area.getXIndex(selection.x1 - area.innerOffset.left));
                    if (selection.resizeScrollerR)
                    {
                        deltaX += (this.viewport.x.max === null || this.viewport.areaName !== area.name ? areaViewport.x.max : this.viewport.x.max) - selection.anchorX;
                    }
                    else
                    {
                        deltaX += (this.viewport.x.min === null || this.viewport.areaName !== area.name ? areaViewport.x.min : this.viewport.x.min) - selection.anchorX;
                    }

                    var deltaY = area.isScroller ? 0 : area.getYValue(selection.y2 - area.innerOffset.top) - area.getYValue(selection.y1 - area.innerOffset.top) + ((this.viewport.y.min === null || this.viewport.areaName !== area.name ? areaViewport.y.min : this.viewport.y.min) - selection.anchorY);

                    if (!selection.resizeScrollerR)
                    {
                        this.viewport.x.max = (this.viewport.x.max === null || this.viewport.areaName !== area.name ? areaViewport.x.max : this.viewport.x.max);
                        if(this.viewport.x.max - ((this.viewport.x.min === null || this.viewport.areaName !== area.name ? areaViewport.x.min : this.viewport.x.min) - deltaX) > 1) {
                            this.viewport.x.min = (this.viewport.x.min === null || this.viewport.areaName !== area.name ? areaViewport.x.min : this.viewport.x.min) - deltaX;
                        }
                    }

                    if (!selection.resizeScrollerL)
                    {
                        this.viewport.x.min = (this.viewport.x.min === null || this.viewport.areaName !== area.name ? areaViewport.x.min : this.viewport.x.min);
                        if(((this.viewport.x.max === null || this.viewport.areaName !== area.name ? areaViewport.x.max : this.viewport.x.max) - deltaX) - this.viewport.x.min > 1) {
                            this.viewport.x.max = (this.viewport.x.max === null || this.viewport.areaName !== area.name ? areaViewport.x.max : this.viewport.x.max) - deltaX;
                        }
                    }

                    if (deltaY !== 0 && this.viewport.y.min !== null && this.viewport.y.max !== null)
                    {
                        // Pan vertically only when zoomed.
                        this.viewport.y.min = (this.viewport.areaName === area.name ? this.viewport.y.min : areaViewport.y.min) - deltaY;
                        this.viewport.y.max = (this.viewport.areaName === area.name ? this.viewport.y.max : areaViewport.y.max) - deltaY;
                    }

                    this.viewport.areaName = area.name;
                }
                else
                {
                    if (selection.position1.insideX)
                    {
                        this._zoomInternal(area, 3 * (selection.x2 - selection.x1) / area.innerWidth, "x", selection.anchorX, null);
                    }
                    else if (selection.position1.insideY)
                    {
                        this._zoomInternal(area, 3 * (selection.y2 - selection.y1) / area.innerHeight, "y", null, selection.anchorY);
                    }

                    selection.x1 = selection.x2;
                    selection.y1 = selection.y2;
                }

                this._fixViewportBounds();
                this.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": true });
                this.loadMissingData();
                return false;
            case "zoom":
            case "wait":
                return true;
            default:
                throw new Error("Selection mode '" + selection.mode + "' is invalid.");
        }
    };

    iChart.Charting.Chart.prototype._selectionMouseUpCallback = function (selection)
    {
    };

    iChart.Charting.Chart.prototype._selectionMoveEndCallback = function (selection)
    {
        /// <summary>
        /// Called when the mouse selection is complete.
        /// </summary>

        if (selection.mode === "pan")
        {
            this.container.style.cursor = this.overlay.defaultCursor
                = MOBILE_BROWSER_DETECTED ? "move" : "url('" + this.env.lib_path + "/styles/cursors/grab.cur'), move";
        }
        else
        {
            this.container.style.cursor = this.overlay.defaultCursor = "crosshair";
        }

        if(!selection.moved && !selection.position1.insideX && selection.position1.insideY) {
            this.chartOptions.showCurrentLabel = !this.chartOptions.showCurrentLabel;
            this.env.wrapper.trigger('iguanaChartEvents', ['chartOptionsChanged', {showCurrentLabel: this.chartOptions.showCurrentLabel}]);
            this.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": true });
            return;
        }

        var threshold = selection.mode === "pan" ? 1 : 20;
        if (Math.abs(selection.x2 - selection.x1) < threshold && Math.abs(selection.y2 - selection.y1) < threshold)
        {
            return;
        }

        if (selection.position1 === null)
        {
            return;
        }

        selection.position2 = this.findAreaAtPosition(selection.x2, selection.y2);
        if (selection.position2 === null)
        {
            return;
        }

        if (selection.position2.area !== selection.position1.area || selection.position2.insideX !== selection.position1.insideX || selection.position2.insideY !== selection.position1.insideY)
        {
            return;
        }

        var area = selection.position1.area;
        switch (selection.mode)
        {
            case "pan":
                if (selection.position1.insideX && selection.position1.insideY)
                {
                    var areaViewport = area.isScroller ? area.scrollerViewport : area.viewport;
                    var deltaX = (area.isScroller ? -1 : 1) * (area.getXIndex(selection.x2 - area.innerOffset.left) - area.getXIndex(selection.x1 - area.innerOffset.left));
                    if (selection.resizeScrollerR)
                    {
                        deltaX += (this.viewport.x.max === null || this.viewport.areaName !== area.name ? areaViewport.x.max : this.viewport.x.max) - selection.anchorX;
                    }
                    else
                    {
                        deltaX += (this.viewport.x.min === null || this.viewport.areaName !== area.name ? areaViewport.x.min : this.viewport.x.min) - selection.anchorX;
                    }

                    var deltaY = area.isScroller ? 0 : area.getYValue(selection.y2 - area.innerOffset.top) - area.getYValue(selection.y1 - area.innerOffset.top) + ((this.viewport.y.min === null || this.viewport.areaName !== area.name ? areaViewport.y.min : this.viewport.y.min) - selection.anchorY);
                    if (!selection.resizeScrollerR)
                    {
                        this.viewport.x.max = (this.viewport.x.max === null || this.viewport.areaName !== area.name ? areaViewport.x.max : this.viewport.x.max);
                        if(this.viewport.x.max - ((this.viewport.x.min === null || this.viewport.areaName !== area.name ? areaViewport.x.min : this.viewport.x.min) - deltaX) > 1) {
                            this.viewport.x.min = (this.viewport.x.min === null || this.viewport.areaName !== area.name ? areaViewport.x.min : this.viewport.x.min) - deltaX;
                        }
                    }

                    if (!selection.resizeScrollerL)
                    {
                        this.viewport.x.min = (this.viewport.x.min === null || this.viewport.areaName !== area.name ? areaViewport.x.min : this.viewport.x.min);
                        if(((this.viewport.x.max === null || this.viewport.areaName !== area.name ? areaViewport.x.max : this.viewport.x.max) - deltaX) - this.viewport.x.min > 1) {
                            this.viewport.x.max = (this.viewport.x.max === null || this.viewport.areaName !== area.name ? areaViewport.x.max : this.viewport.x.max) - deltaX;
                        }
                    }

                    if ((selection.resizeScrollerL || selection.resizeScrollerR) && this.viewport.x.min !== null && this.viewport.x.max !== null && this.viewport.x.min > this.viewport.x.max)
                    {
                        var min = this.viewport.x.min;
                        this.viewport.x.min = this.viewport.x.max;
                        this.viewport.x.max = min;
                    }

                    if (deltaY !== 0 && this.viewport.y.min !== null && this.viewport.y.max !== null)
                    {
                        this.viewport.y.min = (this.viewport.areaName === area.name ? this.viewport.y.min : areaViewport.y.min) - deltaY;
                        this.viewport.y.max = (this.viewport.areaName === area.name ? this.viewport.y.max : areaViewport.y.max) - deltaY;
                    }
                }
                else
                {
                    if (selection.position1.insideX)
                    {
                        this._zoomInternal(area, (selection.x2 - selection.x1) / area.innerWidth, "x", selection.anchorX, null);
                    }
                    else if (selection.position1.insideY)
                    {
                        this._zoomInternal(area, (selection.y2 - selection.y1) / area.innerHeight, "y", null, selection.anchorY);
                    }
                }

                this._fixViewportBounds();
                break;
            case "zoom":
                var xmin = area.getXIndex((selection.x1 < selection.x2 ? selection.x1 : selection.x2) - area.innerOffset.left);
                var xmax = area.getXIndex((selection.x1 < selection.x2 ? selection.x2 : selection.x1) - area.innerOffset.left);
                this.viewport.x.min = Math.max(area.xSeries.min, Math.min(xmin, area.xSeries.max));
                this.viewport.x.max = Math.min(area.xSeries.max, xmax);
                this.viewport.y.min = area.getYValue((selection.y1 > selection.y2 ? selection.y1 : selection.y2) - area.innerOffset.top);
                this.viewport.y.max = area.getYValue((selection.y1 > selection.y2 ? selection.y2 : selection.y1) - area.innerOffset.top);
                break;
            case "wait":
                break;
            default:
                throw new Error("Selection mode '" + selection.mode + "' is invalid.");
        }

        this.viewport.areaName = area.name;
        this.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": true });
        this.loadMissingData();

        if (selection.mode == 'pan' && !area.isScroller && this.chartOptions.inertialScrolling) {
            this.env.scrollTo(selection);
        }
    };

    iChart.Charting.Chart.prototype._setData = function (data, params)
    {
        /// <summary>
        /// Creates chart areas and series according to the specified chart data.
        /// </summary>
        /// <param name="data" type="Object">Chart data.</param>
        /// <param name="params" type="Object">Data request parameters.</param>

        if (this.areas)
        {
            for (var i = 0; i < this.areas.length; ++i)
            {
                this.areas[i].dispose();
            }
        }

        this.areas = [];

        var hlocArea = new iChart.Charting.ChartArea({ "chart": this, "name": "ChartArea1", showLabels: this.showLabels});
        var scrollerArea = new iChart.Charting.ChartArea({ "chart": this, "isScroller": true, "name": "Scroller", "showLegend": false });
        var volumeArea = new iChart.Charting.ChartArea({
            "chart": this,
            "name": "ChartArea2",
            "parentName": this.chartOptions.showVolume === "outside" ? undefined : hlocArea.name,
            "showAxes": this.chartOptions.showVolume == "outside",
            "showLabels": this.chartOptions.showVolume == "outside",
            "showLegend": this.chartOptions.showVolume == "outside",
            "showWatermark": this.chartOptions.showVolume == "outside"
        });

        var hlocAreaSeries = [];
        var scrollerAreaSeries = [];
        var volumeAreaSeries = [];
        var indicatorAreaSeries = {};

//-------------------------------------------------------------------------------------------
        if(this.chartOptions.futureAmount) {
            var step = params.timeframe * 60;
            for(var i=0;i<this.chartOptions.futureAmount;i++) {
                data.xSeries.push(data.xSeries[data.xSeries.length-1]+step);
            }

            for(var i=0;i<data.ySeries.length;i++) {
                if(data.ySeries[i].valuesPerPoint==1) {
                    for(var j=0;j<this.chartOptions.futureAmount;j++) {
                        data.ySeries[i].points.push([null]);
                    }
                } else {
                    for(var j=0;j<this.chartOptions.futureAmount;j++) {
                        data.ySeries[i].points.push([null,null,null,null]);
                    }
                }
            }
        }
//-------------------------------------------------------------------------------------------
        var seriesIndex = 0;
        var ij = 0;
        for (var i = 0; i < data.ySeries.length; ++i)
        {
            var series = data.ySeries[i];
            series.isStartedFromZero = false;
            switch (series.kind)
            {
                case "HLOC":
                    series.chartArea = hlocArea.name;
                    var colors = $.extend([], this.chartOptions.seriesColors);
                    colors.splice(0,0,this.chartOptions.lineColor);
                    series.color = colors[hlocAreaSeries.length % colors.length];

                    hlocAreaSeries.push(series);
                    scrollerAreaSeries.push(series);
                    break;
                case "TechnicalAnalysis":

                    var iName = series.name.replace(/\s.*$/,'');
                    for(var j = ij; j < 3; j++) {
                        ij++;
                        if(params["i" + j] == iName) {
                            var colorIndex = j;
                            break;
                        }
                    }

                    var indicatorColors = this.chartOptions.indicatorColors[colorIndex];
                    //series.color = indicatorColors[series.indicatorIndex2 % indicatorColors.length];
                    var userIndicatorsColor = this.env.userSettings.chartSettings.indicatorsColor;
                    if(userIndicatorsColor[iName] && typeof userIndicatorsColor[iName][colorIndex] != "undefined") {
                        var iColor = userIndicatorsColor[iName][colorIndex][series.indicatorIndex2 % userIndicatorsColor[iName][colorIndex].length];
                        series.color = iColor || indicatorColors[series.indicatorIndex2 % indicatorColors.length];
                    } else {
                        series.color = indicatorColors[series.indicatorIndex2 % indicatorColors.length];
                    }

                    var userIndicatorsWidth = this.env.userSettings.chartSettings.indicatorsWidth;
                    if(userIndicatorsWidth[iName] && typeof userIndicatorsWidth[iName][colorIndex][series.indicatorIndex2 % userIndicatorsWidth[iName][colorIndex].length] != "undefined") {
                        series.width = userIndicatorsWidth[iName][colorIndex][series.indicatorIndex2 % userIndicatorsWidth[iName][colorIndex].length] || 2;
                    } else {
                        series.width = 2;
                    }

                    if (series.overlay)
                    {
                        series.chartArea = hlocArea.name;
                        hlocAreaSeries.push(series);
                    }
                    else
                    {
                        series.chartArea = "ChartAreaI" + series.indicatorIndex;
                        if (typeof indicatorAreaSeries[series.indicatorIndex] === "undefined")
                        {
                            indicatorAreaSeries[series.indicatorIndex] = [series];
                        }
                        else
                        {
                            indicatorAreaSeries[series.indicatorIndex].push(series);
                        }
                    }

                    break;
                case "Volume":
                    series.chartType = "Column";
                    series.color = this.chartOptions.volumeStyle;
                    series.isStartedFromZero = true;
                    series.chartArea = hlocArea.name;
                    series.chartArea = volumeArea.name;
                    volumeAreaSeries.push(series);

                    break;
                default:
                    continue;
            }

            series.enableMerge = true;
            series.index = seriesIndex++;

            if (series.valuesPerPoint === 4)
            {
                series.closeValueIndex = 3;
                series.lowValueIndex = 1;
            }
            else
            {
                series.closeValueIndex = 0;
                series.lowValueIndex = 0;
            }

            series.highValueIndex = 0;
        }

        this.isComparison = scrollerAreaSeries.length > 1 || this.chartOptions.percentMode;

        for (var i = 0; i < data.ySeries.length; ++i)
        {
            var series = data.ySeries[i];
            var color = series.color ? series.color.replace(/rgba\((.+),[^,]+\)/, "rgb($1)") : '';
            var $label = $("<span/>", { "class": "m-chart-legend-color" }).css({ "background-color": color }).html("&nbsp;");
            $label = $label.add($("<span/>", { "class": "m-chart-legend-name" }).css({ "color": color }).text(series.name));
            var labelText = series.name;
            var labelHtml = $("<div/>").append($label).html();
            if (series.valuesPerPoint === 4)
            {
                series.dotIndex = 3;
                if (this.isComparison)
                {
                    series.labels = [[3, labelHtml]];
                }
                else
                {
                    series.labels = [[2, labelHtml + "O:"], [0, "H:"], [1, "L:"], [3, "C:"]];
                }
            }
            else if (series.valuesPerPoint == 2)
            {
                series.labels = [[1, labelHtml + _t('2589', "Мин:")], [0, _t('2590', "Макс:")]];
            }
            else
            {
                series.labels = [[0, labelHtml, labelText]];
            }
        }

        hlocArea.axisX.showLabels = true;
        hlocArea.enabled = true;
        hlocArea.xSeries = data.xSeries;
        hlocArea.ySeries = hlocAreaSeries;
        this.areas.push(hlocArea);

        scrollerArea.axisX.showLabels = true;
        scrollerArea.enabled = this.chartOptions.scrollerHeight !== 0;
        scrollerArea.xSeries = data.xSeries;
        scrollerArea.ySeries = scrollerAreaSeries;

        if (scrollerArea.enabled) {
            this.areas.push(scrollerArea);
        }

        if (!this.isComparison)
        {
            //volumeArea.enabled = this.showVolume === "inside" || this.showVolume === "outside";
            //данные нам нужны всегда
            volumeArea.enabled = true;
            if (volumeArea.enabled)
            {
                volumeArea.enabled = false;
                for (var i = 0; i < volumeAreaSeries.length; ++i)
                {
                    if (volumeAreaSeries[i].enabled)
                    {
                            volumeArea.enabled = true;
                        break;
                    }
                }
            }

            if (volumeArea.enabled)
            {
                volumeArea.axisX.showLabels = false;
                volumeArea.xSeries = hlocArea.xSeries;
                volumeArea.ySeries = volumeAreaSeries;
                this.areas.push(volumeArea);
            }
            //показ объемов в зависимости от конфигурации
            volumeArea.enabled = this.chartOptions.showVolume === "inside" || this.chartOptions.showVolume === "outside";
        }

        for (var key in indicatorAreaSeries)
        {
            if (!indicatorAreaSeries.hasOwnProperty(key))
            {
                continue;
            }

            var indicatorArea = new iChart.Charting.ChartArea({ "chart": this });
            indicatorArea.axisX.showLabels = false;
            indicatorArea.enabled = true;
            indicatorArea.xSeries = hlocArea.xSeries;
            indicatorArea.ySeries = indicatorAreaSeries[key];
            indicatorArea.name = indicatorArea.ySeries[0].chartArea;
            var chart = this;
            indicatorArea.onClose = function ()
            {
                chart.clearIndicators(this);
            };

            this.areas.push(indicatorArea);
        }

        this.createValueByPriceArea();
        this.onCreateAreas.call(this, data, params);

        for (var i = 0; i < this.areas.length; ++i)
        {
            this.areas[i].setMinMax();
        }

        this._setXLabelFormat();

        return data.xSeries.length;
    };

    iChart.Charting.Chart.prototype.createValueByPriceArea = function () {
        // Create layer for the volume by price data.
        var _this = this;
        var area = new iChart.Charting.ChartArea({
            "chart": this,
            "ignoreViewport": true,
            "name": "VolumeByPriceArea",
            "onCalculateViewport": function (viewport)
            {
                // Align X axis with HLOC area Y axis.
                var getIndex = function (series, value)
                {
                    return series.min + (series.max - series.min) * (series[series.min] - value) / (series[series.min] - series[series.max]);
                };
                var baseViewport = _this.areas[0].viewport;
                viewport.x.min = getIndex(this.xSeries, baseViewport.y.max);
                viewport.x.max = getIndex(this.xSeries, baseViewport.y.min);
                viewport.x.bounded.min = Math.max(this.xSeries.min, Math.floor(viewport.x.min));
                viewport.x.bounded.max = Math.min(this.xSeries.max, Math.ceil(viewport.x.max));
                return viewport;
            },
            "parentName": "ChartArea1",
            "showAxes": false,
            "showLabels": false,
            "showLegend": false,
            "showWatermark": false
        });

        area.axisX.showLabels = true;
        area.enabled = this.chartOptions.showVolumeByPrice;
        //area.enabled = true;
        area.rotate = true;
        area.ySeries = [{
            "chartType": "Column",
            "closeValueIndex": 0,
            "color": this.chartOptions.volumeStyle,
            "enabled": true,
            "enableMerge": false,
            "formatProvider": { "decimalPlaces": "2", "decimalPrecision": null },
            "highValueIndex": 0,
            "isStartedFromZero": true,
            "kind": "Other",
            "lowValueIndex": 0,
            "name": "V(Price)",
            "valuesPerPoint": 1
        }];

        area.xSeries = [];
        area.ySeries[0].points = [];

        if(this.chartOptions.showVolumeByPrice) {
            this.updateVolumeByPrice();
        }

        var valueArea = $.grep(this.areas, function (x) { return x.name === "VolumeByPriceArea"; })[0];
        if (valueArea && area.enabled)
        {
            valueArea.enabled = false;
        }

        this.areas.push(area);

    };

    iChart.Charting.Chart.prototype.updateVolumeByPrice = function ()
    {
        if(!this.chartOptions.showVolumeByPrice) {
            return;
        }

        var maxY = 0;
        var minY = this.areas[0].viewport.y.max;

        for(var i=Math.floor(this.areas[0].viewport.x.min); i<=Math.ceil(this.areas[0].viewport.x.max); i++) {
            if(this.areas[0] && this.areas[0].ySeries[0] && this.areas[0].ySeries[0].points[i]) {
                if(maxY < this.areas[0].ySeries[0].points[i][0]) {
                    maxY = this.areas[0].ySeries[0].points[i][0];
                }
                if(minY > this.areas[0].ySeries[0].points[i][1]) {
                    minY = this.areas[0].ySeries[0].points[i][1];
                }
            }
        }

        var step = (maxY-minY) / 50;

        var candleStepVl = {};

        for(var i=Math.floor(this.areas[0].viewport.x.min); i<=Math.ceil(this.areas[0].viewport.x.max); i++) {
            candleStepVl[i] = 0;

            if(typeof this.areas[2].ySeries != "undefined") {
                if (this.areas[2].ySeries[0].points[i] && this.areas[0].ySeries[0].points[i]
                    && (this.areas[0].ySeries[0].points[i][0] - this.areas[0].ySeries[0].points[i][1]) != 0) {
                    candleStepVl[i] = (this.areas[2].ySeries[0].points[i][0])
                        / (this.areas[0].ySeries[0].points[i][0] - this.areas[0].ySeries[0].points[i][1])
                        * step;

                } else if (this.areas[2].ySeries[0].points[i] && this.areas[0].ySeries[0].points[i]
                    && (this.areas[0].ySeries[0].points[i][0] - this.areas[0].ySeries[0].points[i][1]) == 0) {
                    candleStepVl[i] = this.areas[2].ySeries[0].points[i][0];
                }
            }
        }

        var xSeries = [];
        var ySeries = [];

        for(var level=maxY; level>minY; level-=step) {
            xSeries.push(level);

            var levelSum = 0;
            for(var i=Math.floor(this.areas[0].viewport.x.min); i<=Math.ceil(this.areas[0].viewport.x.max); i++) {
                if(this.areas[0].ySeries[0].points[i]) {
                    var max = this.areas[0].ySeries[0].points[i][0];
                    var min = this.areas[0].ySeries[0].points[i][1];

                    if( (level > max && level-step < max) || (level > min && level-step < min) || (level < max && level-step > min)) {
                        levelSum += candleStepVl[i];
                    }
                }
            }

            ySeries.push([levelSum]);
        }

        var area = $.grep(this.areas, function (x) { return x.name === "VolumeByPriceArea"; })[0];

        if(area) {
            area.enabled = true;

            // Array of prices.
            area.xSeries = xSeries;

            // Array of arrays of volumes.
            area.ySeries[0].points = ySeries;

            area.setMinMax();

            // Redraw the chart.
            this.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        }
    };

    iChart.Charting.Chart.prototype.positionVolumeByPriceArea = function ()
    {
        /// <summary>
        /// Called after the chart area inner/outer dimensions and offsets are calculated.
        /// </summary>

        var area = $.grep(this.areas, function (x) { return x.name === "VolumeByPriceArea"; })[0];
        if (area)
        {
            // Align with the HLOC area.
            var parentArea = this.areas[0];
            area.axisX.paddingLeft = parentArea.axisY.paddingTop;
            area.axisX.paddingRight = parentArea.axisY.paddingBottom;
            area.axisX.pointPadding = 0;
            area.axisY.paddingTop = 0;
            area.axisY.paddingBottom = 0;
            area.enabled = this.chartOptions.showVolumeByPrice;
            area.outerHeight = parentArea.outerHeight;
            area.outerWidth = Math.round(parentArea.outerWidth / 5);
            area.offset.top = parentArea.offset.top;
        }
    };

    iChart.Charting.Chart.prototype._setXLabelFormat = function ()
    {
        /// <summary>
        /// Sets default abscissa label format based on the selected timeframe and interval.
        /// </summary>

        var area = this.areas[0];
        if (area.xSeries.min > area.xSeries.max)
        {
            return;
        }

        var now = new Date();
        var start = new Date(1000 * area.xSeries[area.xSeries.min]);
        if (this.showTime())
        {
                this.dateFormat = "HH:mm\r\nd MMM";
        }
        else
        {
                this.dateFormat = "d MMM\r\nyyyy";
        }
    };

    iChart.Charting.Chart.prototype._testForIntervalChange = function (bySchedule)
    {
        /// <summary>
        /// Fires the interval change event if necessary.
        /// </summary>

        if (!this._dataSettings)
        {
            return;
        }

        var area = this.areas[0];
        var previousStart = this._dataSettings.start;
        var previousEnd = this._dataSettings.end;
        var start = area.xSeries[area.viewport.x.bounded.min];
        var end = area.xSeries[area.viewport.x.bounded.max];
        this._dataSettings.start = start && (area.viewport.x.bounded.min !== area.xSeries.min || this._dataStart) ? new Date(start * 1000) : null;
        this._dataSettings.end = end && (area.viewport.x.bounded.max !== area.xSeries.max || this._dataEnd) ? new Date(end * 1000) : null;

        if (typeof previousStart === "undefined")
        {
            return;
        }

        if (!this._dataSettings.start === !previousStart
            && !this._dataSettings.end === !previousEnd
            && (!this._dataSettings.start || this._dataSettings.start.getTime() === previousStart.getTime())
            && (!this._dataSettings.end || this._dataSettings.end.getTime() === previousEnd.getTime()))
        {
            return;
        }

        this.onDataSettingsChange.call(this, bySchedule);
        this.onIntervalChange.call(this, this._dataSettings.start, this._dataSettings.end);
    };

    iChart.Charting.Chart.prototype._zoomInternal = function (area, level, axis, x, y)
    {
        /// <summary>
        /// Zooms the chart for the specified amount.
        /// </summary>
        /// <param name="area" type="iChart.Charting.ChartArea">Chart area that should be scaled. Leave empty to scale the default area.</param>
        /// <param name="level" type="Number">Zoom level.</param>
        /// <param name="axis" type="String">Axes that should be scaled, valid values are &quot;x&quot;, &quot;y&quot; and &quot;xy&quot;. Leave empty to scale both axes.</param>
        /// <param name="x" type="Number">X coordinate of the point to which the area should be zoomed. Leave empty to zoom to the center.</param>
        /// <param name="y" type="Number">Y coordinate of the point to which the area should be zoomed. Leave empty to zoom to the middle.</param>

        if (!area)
        {
            for (var i = 0; i < this.areas.length; ++i)
            {
                if (this.areas[i].name === this.viewport.areaName)
                {
                    area = this.areas[i];
                }
            }

            if (!area)
            {
                area = this.areas[0];
            }
        }

        if(area.name !== "Scroller") {

        // If viewport area changed keep X scale but reset Y scale.
            if (this.viewport.areaName !== area.name)
            {
                this.viewport.y.min = null;
                this.viewport.y.max = null;
            }

            this.viewport.areaName = area.name;

            if (axis !== "y")
            {
                if (this.viewport.x.min === null)
                {
                    this.viewport.x.min = area.viewport.x.bounded.min;
                }

                if (this.viewport.x.max === null)
                {
                    this.viewport.x.max = area.viewport.x.bounded.max;
                }

                if (!$.isNumeric(x))
                {
                    x = (this.viewport.x.min + this.viewport.x.max) / 2;
                }

                if (area.xSeries.min < area.xSeries.max && this.viewport.x.min < this.viewport.x.max)
                {
                    if (level < 0)
                    {
                        level = Math.max(level, 1 - ((area.xSeries.max - area.xSeries.min) / (0.3 * (this.viewport.x.max - this.viewport.x.min))));
                    }
                    else if (level > 0)
                    {
                        level = Math.min(level, 1 - ((area.xSeries.max - area.xSeries.min) / (1e3 * (this.viewport.x.max - this.viewport.x.min))));
                    }
                }
            }

            if (axis !== "x")
            {
                if (this.viewport.y.min === null)
                {
                    this.viewport.y.min = area.viewport.y.min;
                }

                if (this.viewport.y.max === null)
                {
                    this.viewport.y.max = area.viewport.y.max;
                }

                if (!$.isNumeric(y))
                {
                    y = (this.viewport.y.min + this.viewport.y.max) / 2;
                }

                if (area.ySeries.bounds.min < area.ySeries.bounds.max)
                {
                    if (level < 0)
                    {
                        level = Math.max(level, 1 - ((area.ySeries.bounds.max - area.ySeries.bounds.min) / (0.3 * (this.viewport.y.max - this.viewport.y.min))));
                    }
                    else if (level > 0)
                    {
                        level = Math.min(level, 1 - ((area.ySeries.bounds.max - area.ySeries.bounds.min) / (1e3 * (this.viewport.y.max - this.viewport.y.min))));
                    }
                }
            }

            if (axis !== "y")
            {
                var limit = (this.viewport.x.max - (level * (this.viewport.x.max - x)))-(this.viewport.x.min + (level * (x - this.viewport.x.min)));

                if((this.chartOptions.maxZoom > 0 && limit >= this.chartOptions.maxZoom) || level < 0 || this.chartOptions.maxZoom == 0) {
                    this.viewport.x.min += level * (x - this.viewport.x.min);
                    //this.viewport.x.max -= level * (this.viewport.x.max - x);
                }
            }

            if (axis !== "x")
            {
                this.viewport.y.min += level * (y - this.viewport.y.min);
                this.viewport.y.max -= level * (this.viewport.y.max - y);
            }

        } else {

            if (this.viewport.areaName !== area.name)
            {
                this.viewport.y.min = null;
                this.viewport.y.max = null;
            }

            this.viewport.areaName = area.name;

            if (this.viewport.x.min === null)
            {
                this.viewport.x.min = area.scrollerViewport.x.bounded.min
            }

            if (this.viewport.x.max === null)
            {
                this.viewport.x.max = area.scrollerViewport.x.bounded.max
            }

            var deltaX = (this.viewport.x.max - this.viewport.x.min) / 10;
            var direction = (level > 0) ? 1 : -1;

            var limitRight = area.viewport.x.bounded.max-area.chart.chartOptions.futureAmount+(this.viewport.x.max-this.viewport.x.min)*5/10;
            var limittLeft = area.viewport.x.bounded.min-(this.viewport.x.max-this.viewport.x.min)*5/10;


            if((this.viewport.x.max < limitRight || direction == -1) && (this.viewport.x.min > limittLeft || direction == 1)) {
                this.viewport.x.min += direction * deltaX;
                this.viewport.x.max += direction * deltaX;
            }
        }

        this.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": true });
        this.loadMissingData();
    };
})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartArea = function (settings)
    {
        /// <summary>
        /// Initializes a new instance of the iChart.Charting.ChartArea class.
        /// </summary>
        /// <param name="settings" type="Object">Chart area parameters.</param>
        /// <field name="axisX">X axis settings and properties.</field>
        /// <field name="axisY">Y axis settings and properties.</field>
        /// <field name="chart" type="iChart.Charting.Chart">Chart containing the area.</field>
        /// <field name="ignoreViewport" type="Boolean">A value indicating whether the global viewport should be ignored when calculating the area viewport. If true, all data points will always be visible.</field>
        /// <field name="innerHeight" type="Number">Inner pixel height.</field>
        /// <field name="innerOffset">Pixel offset of the inner area.</field>
        /// <field name="innerWidth" type="Number">Inner pixel width.</field>
        /// <field name="isLayer" type="Boolean">A value indicating whether this area is a layer (overlay/underlay). Layers are positioned relative to the parent area.</field>
        /// <field name="isScroller" type="Boolean">A value indicating whether this area is a scroller.</field>
        /// <field name="margin">Pixel margin.</field>
        /// <field name="name" type="String">Area name.</field>
        /// <field name="offset">Pixel offset of the outer area.</field>
        /// <field name="outerHeight" type="Number">Outer pixel height.</field>
        /// <field name="outerWidth" type="Number">Outer pixel width.</field>
        /// <field name="padding">Pixel padding.</field>
        /// <field name="padding">Pixel padding.</field>
        /// <field name="parentName" type="String">Parent area name.</field>
        /// <field name="rotate" type="Boolean">A value indicating whether the area should be rotated 90 degrees clockwise (default is false).</field>
        /// <field name="showAxes" type="Boolean">A value indicating whether the axes should be visible.</field>
        /// <field name="showLabels" type="Boolean">A value indicating whether the axis labels and grid lines should be visible.</field>
        /// <field name="showLegend" type="Boolean">A value indicating whether the legend above the area (with the series names and current values) should be visible.</field>
        /// <field name="showWatermark" type="Boolean">A value indicating whether the watermark text should be visible.</field>
        /// <field name="viewport">Current viewport.</field>
        /// <field name="xSeries">X series (date/time/index).</field>
        /// <field name="ySeries">Y series collection.</field>

        this.axisX = {};
        this.axisX.paddingLeft = 0;
        this.axisX.paddingRight = 0;
        this.axisX.pointPadding = 0.5;
        this.axisY = {};
        this.axisY.PaddingTop = 0;
        this.axisY.PaddingBottom = 0;

        this.chart = settings.chart;
        this.ignoreViewport = !!settings.ignoreViewport;

        this.innerHeight = 0;
        this.innerWidth = 0;

        this.innerOffset = {};
        this.innerOffset.left = 0;
        this.innerOffset.top = 0;

        this.isLayer = !!settings.parentName;
        this.isScroller = !!settings.isScroller;

        this.margin = {};
        this.margin.bottom = 0;

        this.name = settings.name;

        this.offset = {};
        this.offset.left = 0;
        this.offset.top = 0;

        this.onCalculateViewport = settings.onCalculateViewport || $.noop;

        this.outerHeight = 0;
        this.outerWidth = 0;

        this.padding = {};
        this.padding.top = 0;
        this.padding.right = 0;
        this.padding.bottom = 0;
        this.padding.left = 0;

        this.parentName = settings.parentName;
        this.rotate = !!settings.rotate;

        this.scrollerViewport = null;

        this.showAxes = typeof settings.showAxes === "undefined" ? true : !!settings.showAxes;
        this.showLabels = typeof settings.showLabels === "undefined" ? true : !!settings.showLabels;
        this.showLegend = typeof settings.showLegend === "undefined" ? true : !!settings.showLegend;
        this.showWatermark = typeof settings.showWatermark === "undefined" ? true : !!settings.showWatermark;

        this.viewport = {};
        this.viewport.x = {};
        this.viewport.x.bounded = {};
        this.viewport.y = {};

        this.xSeries = null;
        this.ySeries = [];

        if (this.isScroller)
        {
            $(this.chart.container).find('div.m-chart-scrollerOverlay').remove();
            this.$scrollerOverlay = $("<div class='m-chart-scrollerOverlay'/>").css({"position": "absolute", "z-index": 1 }).appendTo(this.chart.container);
            this.$scrollerOverlayRight = $("<div class='js-scrollerOverlay m-chart-scrollerOverlayRight'/>").hide().css({}).appendTo(this.$scrollerOverlay);
            this.$scrollerOverlayCenter = $("<div/>").hide().css({ "position": "absolute", "z-index": 1 }).appendTo(this.$scrollerOverlay);
            this.$scrollerOverlayCenterR = $("<div/>", { "text": "|", class: 'js-scrollerHandler m-chart-scrollerOverlayHandle' }).hide().css({}).appendTo(this.$scrollerOverlay);
            this.$scrollerOverlayCenterR.hover(function () { $(this).data("iChart-hover", true); }, function () { $(this).removeData("iChart-hover"); }).attr("unselectable", "on").css("user-select", "none").on("selectstart", false);
            this.$scrollerOverlayCenterL = $("<div />", { "text": "|", class: 'js-scrollerHandler m-chart-scrollerOverlayHandle' }).hide().css({}).appendTo(this.$scrollerOverlay);
            this.$scrollerOverlayCenterL.hover(function () { $(this).data("iChart-hover", true); }, function () { $(this).removeData("iChart-hover"); }).attr("unselectable", "on").css("user-select", "none").on("selectstart", false);
            this.$scrollerOverlayLeft = $("<div class='js-scrollerOverlay m-chart-scrollerOverlayLeft'/>").hide().css({}).appendTo(this.$scrollerOverlay);
            $(this.chart.container).find('div.m-chart-scrollforward').remove();
            var $thisArea = this;
            this.$scrollForward = $("<div class='m-chart-scrollforward m-chart-btn' style='min-width: 40px; width:40px; background: #777777; transition: all 0ms'; ><span class='uk-icon-step-forward'></span></div>").hide().appendTo(this.$scrollerOverlay).click(function(){
                $thisArea.chart.env.scrollForward();
            });
        }
    };

    iChart.Charting.ChartArea.prototype.calculateInnerDimensions = function (viewport)
    {
        /// <summary>
        /// Calculates chart area and axis pixel dimensions.
        /// </summary>
        /// <param name="viewport">Inner area viewport (without padding).</param>

        if (this.isScroller)
        {
            this.scrollerViewport = this._calculateViewport(viewport);
            this.viewport = this._calculateViewport();
        }
        else
        {
            this.viewport = this._calculateViewport(viewport);
        }

        if (!this.viewport)
        {
            return;
        }

        this.innerOffset.left = this.offset.left + this.padding.left;
        this.innerOffset.top = this.offset.top + this.padding.top;

        this.innerWidth = this.outerWidth - this.padding.left - this.padding.right;
        this.innerHeight = this.outerHeight - this.padding.top - this.padding.bottom;

        if (this.rotate)
        {
            this.axisX.length = this.innerHeight;
            this.axisY.length = this.innerWidth;
            }
        else
        {
            this.axisX.length = this.innerWidth;
            this.axisY.length = this.innerHeight;
        }

        var paddingXLeft = this.axisX.paddingLeft * (this.viewport.x.max - this.viewport.x.min + (2 * this.axisX.pointPadding)) / (this.axisX.length - (2 * this.axisX.paddingLeft));
        var paddingXRight = this.axisX.paddingRight * (this.viewport.x.max - this.viewport.x.min + (2 * this.axisX.pointPadding)) / (this.axisX.length - (2 * this.axisX.paddingRight));
        this.axisX.min = this.viewport.x.min - this.axisX.pointPadding - paddingXLeft;
        this.axisX.max = this.viewport.x.max + this.axisX.pointPadding + paddingXRight;
        this.axisX.pointWidth = Math.min(Math.max(0, Math.floor((0.4 * this.axisX.length) / (this.viewport.x.max - this.viewport.x.min + 1))), 50);

        var paddingYTop = this.axisY.paddingTop * (this.viewport.y.max - this.viewport.y.min) / (this.axisY.length - (2 * this.axisY.paddingTop));
        var paddingYBottom = this.axisY.paddingBottom * (this.viewport.y.max - this.viewport.y.min) / (this.axisY.length - (2 * this.axisY.paddingBottom));

        this.axisY.min = this.viewport.y.min - paddingYBottom;
        this.axisY.max = this.viewport.y.max + paddingYTop;

        this.axisX.scale = this.axisX.length / (this.axisX.max - this.axisX.min);
        this.axisY.scale = this.axisY.min === this.axisY.max ? 0 : this.axisY.length / (this.axisY.max - this.axisY.min);
        this.axisY.zeroPosition = Math.round(this.getYPosition(0, false));

        if (this.isScroller)
        {
            var left = Math.round(this.getXPositionByIndex(this.scrollerViewport.x.bounded.min));
            var right = Math.round(this.getXPositionByIndex(this.scrollerViewport.x.bounded.max));
            this.$scrollerOverlayLeft.show().width(left).height(this.innerHeight).css({ "left": this.innerOffset.left + "px", "top": this.innerOffset.top + "px" });
            this.$scrollerOverlayCenter.show().width(right - left).height(this.innerHeight).css({ "left": (this.innerOffset.left + left) + "px", "top": this.innerOffset.top + "px" });
            this.$scrollerOverlayCenterL.show().css({ "left": (this.innerOffset.left + left - 5) + "px", "top": (this.innerOffset.top + this.innerHeight/2-11) + "px" });
            this.$scrollerOverlayCenterR.show().css({ "left": (this.innerOffset.left + right - 5) + "px", "top": (this.innerOffset.top + this.innerHeight/2-11) + "px" });
            this.$scrollerOverlayRight.show().width(this.innerWidth - right).height(this.innerHeight).css({ "left": (this.innerOffset.left + right) + "px", "top": this.innerOffset.top + "px" });

            if(this.scrollerViewport.x.bounded.max < this.xSeries.length - 1 - this.chart.chartOptions.futureAmount) {
                this.$scrollForward.width(this.innerHeight);
                this.$scrollForward.fadeIn().css({
                    "width": 40 + "px",
                    "min-width": 40 + "px",
                    "left": (this.innerWidth + this.innerOffset.left - this.$scrollForward.width() - 10) + "px",
                    "top": (this.innerOffset.top) + "px"
                });
            } else {
                this.$scrollForward.fadeOut();
            }

        }
    };

    iChart.Charting.ChartArea.prototype.dispose = function ()
    {
        if (this.isScroller)
        {
            this.$scrollerOverlayLeft.remove();
            delete this.$scrollerOverlayLeft;
            this.$scrollerOverlayCenter.remove();
            delete this.$scrollerOverlayCenter;
            this.$scrollerOverlayCenterL.remove();
            delete this.$scrollerOverlayCenterL;
            this.$scrollerOverlayCenterR.remove();
            delete this.$scrollerOverlayCenterR;
            this.$scrollerOverlayRight.remove();
            delete this.$scrollerOverlayRight;
        }

        if (this.$closeButton)
        {
            this.$closeButton.remove();
            delete this.$closeButton;
        }
    };

    iChart.Charting.ChartArea.prototype.getXIndex = function (xPosition)
    {
        /// <summary>
        /// Gets floating-point index of the point at the specified X pixel position.
        /// </summary>
        /// <param name="xPosition">X position of the point.</param>
        /// <returns type="Number" />

        return this.axisX.min + (xPosition / this.axisX.scale);
    };

    iChart.Charting.ChartArea.prototype.getXPositionByIndex = function (xIndex)
    {
        /// <summary>
        /// Gets floating-point X pixel position of the point with the specified floating-point index.
        /// </summary>
        /// <param name="xIndex" type="Number">Index of the point.</param>
        /// <returns type="Number" />

        return this.axisX.scale * (xIndex - this.axisX.min);
    };

    iChart.Charting.ChartArea.prototype.getXIndexByValue = function (xValue)
    {
        /// <summary>
        /// Gets index of the point with the specified value.
        /// </summary>
        /// <param name="xValue" type="Number">Value of the point.</param>
        /// <returns type="Number" />

        if (!$.isNumeric(xValue))
        {
            return NaN;
        }

        if (this.xSeries.min > this.xSeries.max)
        {
            return NaN;
        }

        if (xValue < this.xSeries[this.xSeries.min] || xValue > this.xSeries[this.xSeries.max])
        {
            if(xValue > this.xSeries[this.xSeries.max]) {
                return this.xSeries.max + (xValue - this.xSeries[this.xSeries.max]) / (this.xSeries[this.xSeries.max] - this.xSeries[this.xSeries.max -1]);
            } else {
                return NaN;
            }
        }

        var xIndex = iChart.Charting.indexOfFirstElementGreaterThanOrEqualTo(this.xSeries, xValue);
        if (xIndex === -1)
        {
            return NaN;
        }

        if (xIndex !== this.xSeries.min)
        {
            xIndex -= (this.xSeries[xIndex] - xValue) / (this.xSeries[xIndex] - this.xSeries[xIndex - 1]);
        }

        return xIndex;
    };

    iChart.Charting.ChartArea.prototype.getXIndexByValue2 = function (xValue)
    {
        /// <summary>
        /// Gets index of the point with the specified value.
        /// </summary>
        /// <param name="xValue" type="Number">Value of the point.</param>
        /// <returns type="Number" />

        if (!$.isNumeric(xValue))
        {
            return NaN;
        }

        if (this.xSeries.min > this.xSeries.max)
        {
            return NaN;
        }

        if (xValue < this.xSeries[this.xSeries.min]) {
            return this.xSeries.min;
        } else if (xValue > this.xSeries[this.xSeries.max]) {
            return this.xSeries.max;
        }

        var xIndex = iChart.Charting.indexOfFirstElementGreaterThanOrEqualTo(this.xSeries, xValue);
        if (xIndex === -1)
        {
            return NaN;
        }

        if (xIndex !== this.xSeries.min)
        {
            xIndex -= (this.xSeries[xIndex] - xValue) / (this.xSeries[xIndex] - this.xSeries[xIndex - 1]);
        }

        return xIndex;
    };


    iChart.Charting.ChartArea.prototype.getXPositionByValue = function (xValue)
    {
        /// <summary>
        /// Gets floating-point X pixel position of the point with the specified value.
        /// </summary>
        /// <param name="xValue" type="Number">Value of the point.</param>
        /// <returns type="Number" />

        var xIndex = this.getXIndexByValue(xValue);
        if (isNaN(xIndex))
        {
            return NaN;
        }

        return this.getXPositionByIndex(xIndex);
    };

    iChart.Charting.ChartArea.prototype.getXValue = function (xPosition)
    {
        /// <summary>
        /// Gets value of the point at the specified X pixel position.
        /// </summary>
        /// <returns type="Number" />

        var xIndex = this.getXIndex(xPosition);
        var xIndexLeft = Math.floor(xIndex);
        var xIndexRight = Math.ceil(xIndex);
        if (xIndexRight < this.xSeries.min)
        {
            return;
        }

        if (xIndexLeft < this.xSeries.min)
        {
            return this.xSeries[xIndexRight];
        }

        if (xIndexRight > this.xSeries.max)
        {
            return this.xSeries[this.xSeries.max] + (xIndex - this.xSeries.max) * (this.xSeries[this.xSeries.max] - this.xSeries[this.xSeries.max - 1]);
        }

        if (xIndexLeft === xIndexRight)
        {
            return this.xSeries[xIndexLeft];
        }

        return this.xSeries[xIndexLeft] + ((xIndex - xIndexLeft) * (this.xSeries[xIndexRight] - this.xSeries[xIndexLeft]));
    };

    iChart.Charting.ChartArea.prototype.getYMinMax = function (start, end)
    {
        /// <summary>
        /// Gets minimum and maximum Y values in the specified X index range.
        /// </summary>
        /// <param name="start" type="Number">Start index.</param>
        /// <param name="end" type="Number">End index.</param>
        /// <returns type="Object" />

        var result = {};
        result.isStartedFromZero = false;
        result.min = null;
        result.max = null;
        for (var i = 0; i < this.ySeries.length; ++i)
        {
            //if(this.ySeries[i].kind == "TA_LIB") { continue; }
            var series = this.ySeries[i];
            var points = series.points;
            result.isStartedFromZero = result.isStartedFromZero || series.isStartedFromZero;
            if (this.chart.isComparison && series.kind != "TA_LIB")
            {
                series.multiplier = 0;
                for (var j = start; j <= end; ++j)
                {
                    var point = points[j];
                    if (typeof point == "undefined" || point === null)
                    {
                        continue;
                    }
                    var value = point[series.closeValueIndex];
                    if (value === null)
                    {
                        continue;
                    }
                    if (series.multiplier)
                    {
                        value = (series.multiplier * value) - 100;
                    }
                    else
                    {
                        series.multiplier = 100 / value;
                        value = 0;
                    }

                    if (result.min === null)
                    {
                        result.min = value;
                    }
                    else
                    {
                        result.min = Math.min(result.min, value);
                    }

                    if (result.max === null)
                    {
                        result.max = value;
                    }
                    else
                    {
                        result.max = Math.max(result.max, value);
                    }
                }
            }
            else
            {
                for (var j = start; j <= end; ++j)
                {
                    var point = points[j];
                    if (point === null || typeof point == "undefined")
                    {
                        continue;
                    }

                    if (result.min === null)
                    {
                        result.min = point[series.lowValueIndex];
                    }
                    else if(point[series.lowValueIndex] !== null)
                    {
                        result.min = Math.min(result.min, point[series.lowValueIndex]);
                    }

                    if (result.max === null)
                    {
                        result.max = point[series.highValueIndex];
                    }
                    else
                    {
                        result.max = Math.max(result.max, point[series.highValueIndex]);
                    }
                }
            }
        }

        if(this.name == 'ChartArea1') {
            // учет построенных инструментов анализа, что бы тоже попадали в область видимости
            var exclude = [
                'HorizontalLine'
            ];
            var history = this.chart.overlay.history;
            for(var i=0;i<history.length;i++) {

                var element = history[i];

                if($.inArray(element.elementType, exclude) >= 0) {
                    continue;
                }

                var useElement = false;
                //Если инструмент попадает хотябы частично в область видимости, то учитываем его при масшабировании.
                for(var j=0;j<element.points.length;j++) {
                    if(element.points[j].x >= this.xSeries[start]*1000 && element.points[j].x <= this.xSeries[end]*1000 || element.positionAbsolute) {
                        useElement = true;
                    } else if (element.points[j].x < this.xSeries[0] || element.points[j].x > this.xSeries[this.xSeries.length - 1]) {
                        // если точка вне области графика, то не учитываем
                        useElement = false;
                        break;
                    }

                }
                if(useElement) {
                    for(var j=0;j<element.points.length;j++) {
                        if(element.points[j].y) {

                            if(this.chart.isComparison && series.kind != "TA_LIB" && this.ySeries[0].points.length) {
                                var y = ((element.points[j].y  /  this.ySeries[0].points[start][3]) - 1) * 100;
                            } else {
                                var y = element.points[j].y;
                            }
                            result.max = Math.max(result.max, y);
                            result.min = Math.min(result.min, y);
                        }
                    }
                }
            }
        }

        var checkZero = function (x)
        {
            if (x.isStartedFromZero)
            {
                if (x.min !== null && x.min > 0)
                {
                    x.min = 0;
                }
                else if (x.max !== null && x.max < 0)
                {
                    x.max = 0;
                }
            }
        };

        checkZero(result);
        return result;
    };

    iChart.Charting.ChartArea.prototype.getYPosition = function (value)
    {
        /// <summary>
        /// Gets floating-point Y pixel position of the point with the specified Y value.
        /// </summary>
        /// <param name="value" type="Number">Y value of the point.</param>
        /// <returns type="Number" />

        if (this.axisY.scale === 0)
        {
            return (0.5 * this.axisY.length);
        }

        return this.axisY.scale * (this.axisY.max - value);
    };

    iChart.Charting.ChartArea.prototype.getYValue = function (position)
    {
        /// <summary>
        /// Gets Y value at the specified Y pixel position.
        /// </summary>
        /// <param name="position" type="Number">Y pixel position.</param>
        /// <returns type="Number" />

        if (this.axisY.scale === 0)
        {
            return this.axisY.max;
        }

        return this.axisY.max - (position / this.axisY.scale);
    };

    iChart.Charting.ChartArea.prototype.setMinMax = function ()
    {
        /// <summary>
        /// Sets min/max x/y values for the area.
        /// </summary>

        this.xSeries.min = 0;
        this.xSeries.max = this.xSeries.length - 1;
        this.ySeries.bounds = this.getYMinMax(this.xSeries.min, this.xSeries.max);
    };

    iChart.Charting.ChartArea.prototype.updateCloseButton = function ()
    {
        /// <summary>
        /// Updates area close button position.
        /// </summary>

        if (!this.onClose)
        {
            return;
        }

        if (!this.$closeButton)
        {
            this.$closeButton = $("<button/>", { "class": "m-chart-area-close", "text": "×", "title": _t("5428", "Скрыть") }).appendTo(this.chart.container);
            this.$closeButton.on("click", $.proxy(this.onClose, this));
        }

        this.$closeButton.css({ "top": this.offset.top + "px" });
    };

    iChart.Charting.ChartArea.prototype._calculateViewport = function (viewport)
    {
        /// <summary>
        /// Calculates minimum and maximum values for this chart area X and Y axes.
        /// </summary>
        /// <param name="viewport">Inner area viewport (without padding). If not specified, main viewport is returned.</param>
        /// <returns type="Object" />

        if (this.xSeries.length === 0)
        {
            return null;
        }

        var areaViewport = {};
        areaViewport.x = {};
        areaViewport.x.bounded = {};
        areaViewport.y = {};

        if (this.ignoreViewport || !viewport)
        {
            areaViewport.x.min = this.xSeries.min;
            areaViewport.x.bounded.min = this.xSeries.min;
        }
        else if (viewport.x.min === null)
        {
            var start = this.chart._dataSettings.start;
            var startIndex = (start) ? iChart.Charting.indexOfFirstElementGreaterThanOrEqualTo(this.xSeries, Math.round(start.getTime() / 1000)) : 0;
            if (startIndex === -1)
            {
                console.warn("Start date/time '" + start.toString() + "' is outside the bounds of the data.");
                startIndex = 0;
            }

            areaViewport.x.min = startIndex;
            areaViewport.x.bounded.min = startIndex;
        }
        else
        {
            areaViewport.x.min = viewport.x.min;
            areaViewport.x.bounded.min = Math.max(this.xSeries.min, Math.floor(viewport.x.min));
        }

        if (this.ignoreViewport || !viewport)
        {
            areaViewport.x.max = this.xSeries.max;
            areaViewport.x.bounded.max = this.xSeries.max;
        }
        else if (viewport.x.max === null)
        {
            if (this.chart._dataSettings.end)
            {
                var end = this.chart._dataSettings.end;
                var endIndex = iChart.Charting.indexOfLastElementLessThanOrEqualTo(this.xSeries, Math.round(end.getTime() / 1000));
                if (endIndex === -1)
                {
                    console.error("End date/time '" + end.toString() + "' is outside the bounds of the data.");
                    endIndex = this.xSeries.length -1;
                }

                areaViewport.x.max = endIndex;
                areaViewport.x.bounded.max = endIndex;
            }
            else
            {
                areaViewport.x.max = this.xSeries.max;
                areaViewport.x.bounded.max = this.xSeries.max;
            }
        }
        else
        {
            areaViewport.x.max = viewport.x.max;
            areaViewport.x.bounded.max = Math.min(this.xSeries.max, Math.ceil(viewport.x.max));
        }

        if (this.ignoreViewport || !viewport)
        {
            areaViewport.y.min = this.ySeries.bounds.min;
            areaViewport.y.max = this.ySeries.bounds.max;
        }
        else
        {
            areaViewport.y.min = viewport.y.min;
            areaViewport.y.max = viewport.y.max;

            if (areaViewport.y.min === null || areaViewport.y.max === null)
            {
                if (areaViewport.x.bounded.min === this.xSeries.min && areaViewport.x.bounded.max === this.xSeries.max)
                {
                    if (viewport.y.min === null)
                    {
                        areaViewport.y.min = this.ySeries.bounds.min;
                    }

                    if (viewport.y.max === null)
                    {
                        areaViewport.y.max = this.ySeries.bounds.max;
                    }
                }
                else
                {
                    var bounds = this.getYMinMax(areaViewport.x.bounded.min, areaViewport.x.bounded.max);
                    if (viewport.y.min === null)
                    {
                        areaViewport.y.min = bounds.min;
                    }

                    if (viewport.y.max === null)
                    {
                        areaViewport.y.max = bounds.max;
                    }
                }
            }
        }

        if (this.ySeries.bounds.isStartedFromZero)
        {
            if (areaViewport.y.min !== null && areaViewport.y.min > 0)
            {
                if (viewport.y.min === null)
                {
                    areaViewport.y.min = 0;
                }
            }
            else if (areaViewport.y.max !== null && areaViewport.y.max < 0)
            {
                if (viewport.y.max === null)
                {
                    areaViewport.y.max = 0;
                }
            }
        }

        areaViewport = this.onCalculateViewport.call(this, areaViewport) || areaViewport;
        return areaViewport;
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartRenderer = function (chart)
    {
        /// <summary>
        /// Initializes a new instance of the ChartRenderer class with the specified chart.
        /// </summary>
        /// <param name="chart">Chart object to render.</param>

        this.chart = chart;
    };

    iChart.Charting.ChartRenderer.prototype.formatDateTime = function (value)
    {
        /// <summary>
        /// Formats the specified date/time value.
        /// </summary>
        /// <param name="value" type="Number">Ordinate value.</param>

        var date = new Date(1000 * value);
        return iChart.formatDateTime(date, this.chart.dateFormat);
    };

    iChart.Charting.ChartRenderer.prototype.formatNumber = function (value, formatProvider)
    {
        /// <summary>
        /// Formats the specified numeric value using the specified format provider.
        /// </summary>
        /// <param name="value" type="Number">Ordinate value.</param>
        /// <param name="formatProvider" type="Object">Numeric format provider.</param>

        var result = iChart.formatNumber(value, formatProvider);
        if (this.chart.isComparison)
        {
            if (value > 0)
            {
                result = "+" + result;
            }

            result += "%";
        }

        return result;
    };

    iChart.Charting.ChartRenderer.prototype.renderArea = function (area, context)
    {
        /// <summary>
        /// Renders the specified chart area to the current canvas context.
        /// </summary>
        /// <param name="area" type="iChart.Charting.ChartArea">Chart area to be rendered.</param>
        /// <param name="context" type="CanvasRenderingContext2D">Canvas context to render to.</param>

        if (!area.enabled)
        {
            return;
        }

        context.save();
        context.translate(area.innerOffset.left, area.innerOffset.top);
        if (area.rotate)
        {
            context.transform(0, 1, -1, 0, area.innerWidth, 0);
        }

        if (area.showAxes && this.chart.chartOptions.showAxes)
        {
            this.renderAxes(area, context);
        }

        if (area.name =="ChartArea1")
        {
            context.fillStyle = this.chart.chartOptions.watermarkColor;
            context.font = this.chart.chartOptions.watermarkFont;
            context.textAlign = "left";
            context.textBaseline = "bottom";

            if(this.chart.chartOptions.watermarkShow) {
                var textW = (area.innerWidth - context.measureText(this.chart.chartOptions.watermarkText).width) / 2;
                context.fillText(this.chart.chartOptions.watermarkText, textW, area.innerHeight / 2 - 5);

                context.font = this.chart.chartOptions.watermarkSubFont;
                textW = (area.innerWidth - context.measureText(this.chart.chartOptions.watermarkSubText).width) / 2;
                context.fillText(this.chart.chartOptions.watermarkSubText, textW, area.innerHeight / 2 + 45);
            }
        }

        if (area.title)
        {
            context.fillStyle = this.chart.chartOptions.watermarkColor;
            context.font = this.chart.chartOptions.watermarkFont;
            context.textAlign = "left";
            context.textBaseline = "bottom";

            if(this.chart.chartOptions.watermarkShow) {
                var textW = (area.innerWidth - context.measureText(area.title).width) / 2;
                context.fillText(area.title, textW, area.innerHeight / 2 - 5);
            }
        }

        if (area.xSeries.length !== 0 && area.ySeries.length !== 0)
        {
            if (area.showLabels)
            {
                this.renderXLabels(area, context);
                this.renderYLabels(area, context);
            }

            this.renderSeriesCollection(area, context);
            if(area.name == "ChartArea1" && area.chart.chartOptions.showCurrentLabel) {
                this.renderCurrentLabel(area, context);
            }
        }

        context.restore();
    };

    /**
     * Отображение последней цены на оси Y
     * @param area
     * @param context
     */
    iChart.Charting.ChartRenderer.prototype.renderCurrentLabel = function (area, context)
    {
        var x = area.innerWidth,
            value,
            point,
            bidY = false,
            offerY = false;

        if (this.chart.isComparison)
        {
            var index = iChart.Charting.getNearestNotNullIndex(area.ySeries[0].points, area.viewport.x.bounded.min);
            var index2 = iChart.Charting.getNearestNotNullIndex(area.ySeries[0].points, area.ySeries[0].points.length-area.chart.chartOptions.futureAmount-1);
            value = (area.ySeries[0].points[index2] && area.ySeries[0].points[index]) ? (((area.ySeries[0].points[index2][3] / area.ySeries[0].points[index][3]) - 1) * 100) : 0;
        } else {
            point = area.ySeries[0].points[area.ySeries[0].points.length-area.chart.chartOptions.futureAmount-1];
            value = (point && point[3]) ? point[3] : 0;

            if(point && point[4] && point[5]) {
                offerY = Math.round(area.getYPosition(point[4], false));
                bidY = Math.round(area.getYPosition(point[5], false));
            }
        }
        var y = Math.round(area.getYPosition(value, false));

        var label = this.formatNumber(value, { "decimalPrecision": this.chart.labelPrecision, "scale": 0 });

        var labelValue = parseFloat(label.replace(/ /g,''));

        if ( this.labelValue != null && labelValue < this.labelValue ) {
            var color = "#f44336";
            this.labelColor = "#f44336";
        } else if ( this.labelValue != null && labelValue > this.labelValue )  {
            var color = "#7cb342";
            this.labelColor = "#7cb342";
        } else if(this.chart.chartOptions.labelColor) {
            var color = this.chart.chartOptions.labelColor;
        } else {
            var color = "#333";
        }

        this.labelValue = labelValue;

        if(bidY && offerY) {
            this.drawLable(context, color, "#FFFFFF", x, y, label, {bidY: bidY, offerY: offerY});
        } else {
            this.drawLable(context, color, "#FFFFFF", x, y, label);
        }
    }

    iChart.Charting.ChartRenderer.prototype.drawLable = function (context, fillColor, textColor, x, y, text, addons)
    {
        fillColor = fillColor ? fillColor : "#333333";
        textColor = textColor ? textColor : "#FFFFFF";

        context.save();

        context.font = 'normal 11px Arial,Helvetica,sans-serif';
        context.textAlign = "left";
        context.textBaseline = "middle";

        context.fillStyle = fillColor;
        context.strokeStyle = fillColor;
        context.fillRect(x+8, y-8, context.measureText(text).width+10, 15);

        context.beginPath();
        context.moveTo(x+8, y-8);
        context.lineTo(x+8, y+7);
        context.lineTo(x, y);
        context.lineTo(x+8, y-8);
        context.lineTo(x+8, y+7);
        context.closePath();

        context.fill();

        context.fillStyle = textColor;
        context.fillText(text, x+8, y);

        context.translate(0.5, 0.5);
        context.beginPath();
        context.lineWidth = 1;
        context.moveTo(0, y);
        context.lineTo(x, y);
        context.stroke();
        context.closePath();

        if(addons) {
            context.beginPath();
            context.fillStyle = '#f44336';
            context.moveTo(x-4, addons.bidY-4);
            context.lineTo(x-4, addons.bidY+3);
            context.lineTo(x, addons.bidY);
            context.lineTo(x-4, addons.bidY-4);
            context.lineTo(x-4, addons.bidY+3);
            context.fill();
            context.closePath();

            context.beginPath();
            context.fillStyle = '#7cb342';
            context.moveTo(x-4, addons.offerY-4);
            context.lineTo(x-4, addons.offerY+3);
            context.lineTo(x, addons.offerY);
            context.lineTo(x-4, addons.offerY-4);
            context.lineTo(x-4, addons.offerY+3);
            context.fill();
            context.closePath();

        }

        context.restore();

    };

    iChart.Charting.ChartRenderer.prototype.renderAxes = function (area, context)
    {
        /// <summary>
        /// Renders chart area axes to the specified canvas context.
        /// </summary>
        /// <param name="area" type="iChart.Charting.ChartArea">Chart area to render axes for.</param>
        /// <param name="context" type="CanvasRenderingContext2D">Canvas context to render to.</param>

        context.save();
        context.translate(0.5, 0.5);

        context.strokeStyle = this.chart.chartOptions.axisColor;
        context.beginPath();
        context.moveTo(0, 0);
        context.lineTo(area.axisX.length, 0);
        context.lineTo(area.axisX.length, area.axisY.length);
        context.lineTo(0, area.axisY.length);
        context.closePath();
        context.stroke();

        context.restore();
    };

    iChart.Charting.ChartRenderer.prototype.renderChart = function (context)
    {
        /// <summary>
        /// Renders the specified chart to the specified canvas context.
        /// </summary>
        /// <param name="context" type="CanvasRenderingContext2D">Canvas context to render to.</param>

        var canvasSize = getElementSize(context.canvas);

        context.clearRect(0, 0, canvasSize.width, canvasSize.height);
        context.fillStyle = this.chart.chartOptions.backgroundColor;
        context.fillRect(0, 0, canvasSize.width, canvasSize.height);

        for (var i = 0; i < this.chart.areas.length; ++i)
        {
            //Дополним если есть юзерские настройки
            var area = this.chart.areas[i];
            //area = $.extend (true, this.chart.areas[i], userSettings[area.name]);
            //area = $.extend (true, this.chart.areas[i], this.chart.env.userSettings.chartSettings.areaSettings);
            this.renderArea(this.chart.areas[i], context);
            if(typeof this.chart.areas[i].overlay != "undefined") {
                this.chart.areas[i].overlay.update(this.chart.areas[i]);
            }
        }
    };

    iChart.Charting.ChartRenderer.prototype.renderLegends = function (context)
    {
        /// <summary>
        /// Renders chart legends to the specified canvas context. This method is only used for creating a chart image.
        /// Standard legends are HTML elements created using the Crosshair component.
        /// </summary>
        /// <param name="context" type="CanvasRenderingContext2D">Canvas context to render to.</param>

        for (var i = 0; i < this.chart.areas.length; ++i)
        {
            var area = this.chart.areas[i];
            if (!area.showLegend || area.rotate)
            {
                continue;
            }

            if (area.viewport.x.bounded.min > area.viewport.x.bounded.max)
            {
                continue;
            }

            context.save();
            context.translate(area.innerOffset.left, area.innerOffset.top - 3);

            context.fillStyle = "#000000";
            context.font = "11px Tahoma";
            context.textAlign = "left";
            context.textBaseline = "bottom";

            var dateTime = new Date(1000 * area.xSeries[area.viewport.x.bounded.max]);
            var dateTimeText = iChart.formatDateTime(dateTime, this.chart.showTime() ? "dd.MM.yyyy HH:mm" : "dd.MM.yyyy");
            context.fillText(dateTimeText, 0, 0);

            var spacing = 7;
            var textMetrics = context.measureText(dateTimeText);
            context.translate(textMetrics.width + spacing, 0);

            var seriesCollection = area.ySeries.slice(0);
            for (var j = 0; j < this.chart.areas.length; ++j)
            {
                if (this.chart.areas[j].parentName === area.name && !this.chart.areas[j].rotate)
                {
                    seriesCollection = seriesCollection.concat(this.chart.areas[j].ySeries);
                }
            }

            for (var j = 0; j < seriesCollection.length; ++j)
            {
                var series = seriesCollection[j];
                context.fillStyle = series.color.replace(/rgba\((.+),[^,]+\)/, "rgb($1)");
                context.beginPath();
                context.arc(6, -6, 6, 0, Math.PI * 2, true);
                context.closePath();
                context.fill();

                context.translate(12 + spacing, 0);

                context.font = "bold 11px Tahoma";
                context.fillText(series.name, 0, 0);

                textMetrics = context.measureText(series.name);
                context.translate(textMetrics.width + spacing, 0);

                var labels;
                if (series.valuesPerPoint === 4)
                {
                    labels = [[2, "O: "], [0, "H: "], [1, "L: "], [3, "C: "]];
                }
                else if (series.valuesPerPoint == 2)
                {
                    labels = [[1, _t("87553", "Мин: ")], [0, _t("87554", "Макс: ")]];
                }
                else
                {
                    labels = [[0, ""]];
                }

                context.fillStyle = "#000000";
                context.font = "11px Tahoma";
                for (var k = 0; k < labels.length; ++k)
                {
                    var labelIndex = labels[k][0];
                    var labelText = labels[k][1];
                    var values = series.points[area.viewport.x.bounded.max];
                    if (!values)
                    {
                        continue;
                    }

                    labelText += iChart.formatNumber(values[labelIndex], series.formatProvider);
                    context.fillText(labelText, 0, 0);

                    textMetrics = context.measureText(labelText);
                    context.translate(textMetrics.width + spacing, 0);
                }
            }

            context.restore();
        }
    };

    iChart.Charting.ChartRenderer.prototype.renderPoint = function (area, series, index, context, state)
    {
        /// <summary>
        /// Renders the specified series point to the current canvas context.
        /// </summary>
        /// <param name="area" type="iChart.Charting.ChartArea">Chart area in which the point is located.</param>
        /// <param name="series" type="Object">Time series the point belongs to.</param>
        /// <param name="index" type="Number">Index of the point in the series.</param>
        /// <param name="context" type="CanvasRenderingContext2D">Canvas context to render to.</param>
        /// <param name="state" type="Object">Point rendering state. It is used to pass information about previously rendered points.</param>

        var values = series.points[index];
        if (!values)
        {
            return;
        }

        switch (series.chartType)
        {
            case "Candlestick":
            case "Stock":
                if(!values[0] && !values[1] && !values[2] && !values[3]) {
                    return;
                }

                var x = Math.round(area.getXPositionByIndex(index));
                var high = Math.round(area.getYPosition(values[0], series.inline));
                var low = Math.round(area.getYPosition(values[1], series.inline));
                if (area.axisX.pointWidth === 0)
                {
                    context.moveTo(x, low);
                    context.lineTo(x, high);
                    break;
                }

                var open = Math.round(area.getYPosition(values[2], series.inline));
                var close = Math.round(area.getYPosition(values[3], series.inline));

                if (series.chartType === "Candlestick")
                {
                    context.save();
                    var candleBottom;
                    var candleTop;
                    if (values[2] < values[3])
                    {
                        candleBottom = open;
                        candleTop = close;

                        if (area.chart.chartOptions.candleUp)
                        {
                            context.fillStyle = area.chart.chartOptions.candleUp;
                        }

                        if(!area.chart.chartOptions.candleBorder) {
                            context.strokeStyle = context.fillStyle;
                        } else {
                            context.strokeStyle = area.chart.chartOptions.candleBorderUp;
                        }

                        context.fillRect(x - area.axisX.pointWidth, candleTop, 2 * area.axisX.pointWidth, candleBottom - candleTop);
                    }
                    else
                    {
                        candleBottom = close;
                        candleTop = open;

                        if (area.chart.chartOptions.candleDown)
                        {
                            context.fillStyle = area.chart.chartOptions.candleDown;
                            //context.fillRect(x - area.axisX.pointWidth, candleTop, 2 * area.axisX.pointWidth, candleBottom - candleTop);
                        }

                        context.fillRect(x - area.axisX.pointWidth, candleTop, 2 * area.axisX.pointWidth, candleBottom - candleTop);

                        if(!area.chart.chartOptions.candleBorder) {
                            context.strokeStyle = context.fillStyle;
                        } else {
                            context.strokeStyle = area.chart.chartOptions.candleBorderDown;
                        }
                    }

                    context.strokeRect(x - area.axisX.pointWidth, candleTop, 2 * area.axisX.pointWidth, candleBottom - candleTop);

                    context.restore();

                    if(area.chart.chartOptions.candleWick) {
                        context.strokeStyle = area.chart.chartOptions.candleWickStyle;
                        context.moveTo(x, high);
                        context.lineTo(x, candleTop);

                        context.moveTo(x, candleBottom);
                        context.lineTo(x, low);
                    }
                } else {

                    if (values[2] < values[3])
                    {
                        if (area.chart.chartOptions.stockUp) {
                            context.strokeStyle = area.chart.chartOptions.stockUp;
                        } else if (series.upStyle) {
                            context.strokeStyle = series.color;
                        }
                    } else {
                        if (area.chart.chartOptions.stockDown) {
                            context.strokeStyle = area.chart.chartOptions.stockDown;
                        } else if (series.upStyle) {
                            context.strokeStyle = series.color;
                        }
                    }

                    if (area.chart.chartOptions.stockWidth) {
                        context.lineWidth = area.chart.chartOptions.stockWidth;
                    }

                    context.beginPath();
                    context.moveTo(x, low);
                    context.lineTo(x, high);

                    context.moveTo(x, open);
                    context.lineTo(x - area.axisX.pointWidth, open);

                    context.moveTo(x, close);
                    context.lineTo(x + area.axisX.pointWidth, close);
                    context.stroke();

                }

                break;
            case "Column":
                if(values[series.closeValueIndex]) {
                    var x = Math.round(area.getXPositionByIndex(index));
                    var close = Math.round(area.getYPosition(values[series.closeValueIndex], series.inline));
                    if (area.axisX.pointWidth === 0) {
                        context.moveTo(x, area.axisY.zeroPosition);
                        context.lineTo(x, close);
                        break;
                    }

                    context.fillRect(x - area.axisX.pointWidth, Math.min(area.axisY.zeroPosition, close), 2 * area.axisX.pointWidth, Math.abs(close - area.axisY.zeroPosition));
                    context.strokeRect(x - area.axisX.pointWidth, Math.min(area.axisY.zeroPosition, close), 2 * area.axisX.pointWidth, Math.abs(close - area.axisY.zeroPosition));
                }
                break;
            case "Area":
                // The position is not rounded to smooth the line.
                var x = area.getXPositionByIndex(index);
                var value = values[series.closeValueIndex];

                if (area.chart.chartOptions.areaLineColor) {
                    context.strokeStyle = area.chart.chartOptions.areaLineColor;
                }
                if(value !== null) {
                    if (this.chart.isComparison && series.kind != "TA_LIB")
                    {
                        if (state.multiplier)
                        {
                            value = (value * state.multiplier) - 100;
                        }
                        else
                        {
                            state.multiplier = 100 / value;
                            value = 0;
                        }
                    }

                    var close = area.getYPosition(value, series.inline);
                    if (state.lineStarted)
                    {
                        context.lineTo(x, close);
                    }
                    else
                    {
                        state.lineStarted = true;
                        context.moveTo(x, close);
                    }
                }
                break;
            case "Line":
                // The position is not rounded to smooth the line.
                var x = area.getXPositionByIndex(index);
                var value = values[series.closeValueIndex];

                //if (area.chart.chartOptions.lineColor && series.kind == "HLOC") {
                //    context.strokeStyle = area.chart.chartOptions.lineColor;
                //}
                if(value !== null) {
                    if (this.chart.isComparison && series.kind != "TA_LIB")
                    {
                        if (state.multiplier)
                        {
                            value = (value * state.multiplier) - 100;
                        }
                        else
                        {
                            state.multiplier = 100 / value;
                            value = 0;
                        }
                    }

                    var close = area.getYPosition(value, series.inline);
                    if (state.lineStarted)
                    {
                        context.lineTo(x, close);
                    }
                    else
                    {
                        state.lineStarted = true;
                        context.moveTo(x, close);
                    }
                }
                break;
            case "Point":
                var x = Math.round(area.getXPositionByIndex(index));
                var close = Math.round(area.getYPosition(values[series.closeValueIndex], series.inline));
                context.beginPath();
                context.arc(x, close, 2.5, 0, Math.PI * 2, true);
                context.closePath();
                context.fill();
                break;
            default:
                throw new Error("Chart type '" + series.chartType + "' is invalid.");
        }
    };

    iChart.Charting.ChartRenderer.prototype.renderSeries = function (area, series, context, index)
    {
        /// <summary>
        /// Renders the specified series in the specified area to the current canvas context.
        /// </summary>
        /// <param name="area" type="iChart.Charting.ChartArea">Chart area containing the series.</param>
        /// <param name="series" type="Object">Series data.</param>
        /// <param name="context" type="CanvasRenderingContext2D">Canvas context to render to.</param>

        if (area.viewport.x.bounded.min > area.viewport.x.bounded.max)
        {
            return;
        }

        if (series.kind === "HLOC")
        {
            if (this.chart.isComparison)
            {
                series.chartType = "Line";
            }
            else if (area.isScroller)
            {
                series.chartType = "Area";
            }
            else
            {
                series.chartType = this.chart.chartOptions.chartType;
            }
        }

        context.fillStyle = series.color;
        context.strokeStyle = series.color;

        if (series.kind === "HLOC") {
            if (series.chartType === "Line") {
                context.lineWidth = this.chart.chartOptions.lineWidth;

                var colors = $.extend([], this.chart.chartOptions.seriesColors);
                colors.splice(0,0,this.chart.chartOptions.lineColor);
                context.fillStyle = context.strokeStyle = colors[index % colors.length];
            } else if(series.width) {
                context.lineWidth = series.width;
            } else {
                context.lineWidth = 1;
            }

            if (series.chartType === "Column") {
                context.fillStyle = area.chart.chartOptions.volumeStyle;
                context.strokeStyle = area.chart.chartOptions.volumeStyle;
            }

        } else if (series.kind === "Volume") {
            if (series.chartType === "Column") {
                context.fillStyle = area.chart.chartOptions.volumeStyle;
                context.strokeStyle = area.chart.chartOptions.volumeStyle;
            }
        } else {
            if(series.width && series.chartType !== "Column") {
                context.lineWidth = series.width;
            } else if (series.chartType === "Area" || series.chartType === "Line") {
                context.lineWidth = 2;
            } else {
                context.lineWidth = 1;
            }
        }


        var useSinglePath = series.chartType === "Area" || series.chartType === "Candlestick" || (series.chartType === "Column" && area.axisX.pointWidth === 0) || series.chartType === "Line" || series.chartType === "Stock"
        if (useSinglePath)
        {
            context.beginPath();
        }

        var state = {};
        for (var i = area.viewport.x.bounded.min; i <= area.viewport.x.bounded.max; ++i)
        {
            this.renderPoint(area, series, i, context, state);
        }

        if (useSinglePath)
        {
            context.stroke();
        }

        if (series.chartType === "Area")
        {
            var x = area.getXPositionByIndex(Math.min(series.points.length - this.chart.chartOptions.futureAmount -1, area.viewport.x.bounded.max));
            context.fillStyle = this.chart.chartOptions.areaColor;
            context.lineTo(x, Math.round(area.getYPosition(area.axisY.min)));
            context.lineTo(area.getXPositionByIndex(area.viewport.x.bounded.min), Math.round(area.getYPosition(area.axisY.min)));
            context.closePath();
            context.fill();
        }
    };

    iChart.Charting.ChartRenderer.prototype.renderSeriesCollection = function (area, context)
    {
        /// <summary>
        /// Renders all series in the specified area to the current canvas context.
        /// </summary>
        /// <param name="area" type="iChart.Charting.ChartArea">Chart area containing the series collection.</param>
        /// <param name="context" type="CanvasRenderingContext2D">Canvas context to render to.</param>

        context.save();

        context.translate(0.5, 0.5);
        context.beginPath();
        context.moveTo(1, 1);
        context.lineTo(1, area.axisY.length - 1);
        context.lineTo(area.axisX.length - 1, area.axisY.length - 1);
        context.lineTo(area.axisX.length - 1, 1);
        context.closePath();
        context.clip();

        for (var j = 0; j < area.ySeries.length; ++j)
        {
            this.renderSeries(area, area.ySeries[j], context, j);
        }

        context.restore();
    };

    iChart.Charting.ChartRenderer.prototype.renderXLabels = function (area, context)
    {
        /// <summary>
        /// Renders abscissa labels, tick marks and grid lines in the specified area to the current canvas context.
        /// </summary>
        /// <param name="area" type="iChart.Charting.ChartArea">Chart area to render labels for.</param>
        /// <param name="context" type="CanvasRenderingContext2D">Canvas context to render to.</param>

        context.save();
        context.translate(0.5, area.axisY.length);

        context.fillStyle = this.chart.chartOptions.labelColor;
        context.font = this.chart.chartOptions.labelFont;
        context.textAlign = "center";
        context.textBaseline = "bottom";

        var interval = Math.max(1, Math.floor((area.axisX.max - area.axisX.min + 1) / (area.axisX.length / 75)));
        var labelPrev;
        for (var i = area.xSeries.min + Math.ceil((area.axisX.min - area.xSeries.min) / interval) * interval; i <= Math.floor(area.axisX.max); i += interval)
        {
            var value = area.xSeries[i];
            if (typeof value === "undefined")
            {
                continue;
            }

            var xLabel = this.formatDateTime(value);
            var x = Math.round(area.getXPositionByIndex(i));
            if (/*area.axisX.showLabels*/ this.chart.chartOptions.showLabels)
            {
                if(this.chart.chartOptions.showAxes) {
                    context.strokeStyle = this.chart.chartOptions.axisColor;
                    context.beginPath();
                    context.moveTo(x, 0);
                    context.lineTo(x, 5);
                    context.stroke();
                }

                var xLabelLines = xLabel.split("\r\n");
                if (xLabelLines.length === 2)
                {
                    // Remove duplicate date parts.
                    if (xLabelLines[1] === labelPrev)
                    {
                        xLabelLines.length = 1;
                    }
                    else
                    {
                        labelPrev = xLabelLines[1];
                    }
                }

                for (var lineIndex = 0; lineIndex < xLabelLines.length; ++lineIndex)
                {
                    context.fillText(xLabelLines[lineIndex], x, 15 + (lineIndex * 11));
                }
            }

            context.strokeStyle = this.chart.chartOptions.gridColor;
            context.beginPath();
            if (this.chart.chartOptions.gridStyle === "dashed")
            {
                for (var y = -4; y >= -area.axisY.length; y -= 4)
                {
                    context.moveTo(x, y);
                    context.lineTo(x, y + 3);
                }
            }
            else if (this.chart.chartOptions.gridStyle === "solid")
            {
                context.moveTo(x, 0);
                context.lineTo(x, -area.axisY.length);
            }

            context.stroke();
        }

        context.restore();
    };

    iChart.Charting.ChartRenderer.prototype.renderYLabel = function (area, value, scale, context)
    {
        /// <summary>
        /// Renders the label for the specified ordinate value.
        /// </summary>
        /// <param name="area" type="iChart.Charting.ChartArea">Chart area containing the label.</param>
        /// <param name="value" type="Number">Ordinate value to render the label for.</param>
        /// <param name="scale" type="Number">Ordinate value scale.</param>
        /// <param name="context" type="CanvasRenderingContext2D">Canvas context to render to.</param>

        var label = this.formatNumber(value, { "decimalPrecision": this.chart.labelPrecision, "scale": scale });
        var y = Math.round(area.getYPosition(value, false));

        if(this.chart.chartOptions.showAxes) {
            context.strokeStyle = this.chart.chartOptions.axisColor;
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(5, y);
            context.stroke();
        }

        if(this.chart.chartOptions.showLabels) {
            context.fillStyle = this.chart.chartOptions.labelColor;
            if(this.chart.chartOptions.yLabelsOutside) {
                context.fillText(label, 8, y);
            } else {
                context.fillText(label, -Math.ceil(context.measureText(label).width / 10) * 10, y-5);
            }
        }

        context.beginPath();
        if (value === 0)
        {
            context.strokeStyle = this.chart.chartOptions.axisColor;
            context.moveTo(0, y);
            context.lineTo(-area.axisX.length, y);
        }
        else
        {
            context.strokeStyle = this.chart.chartOptions.gridColor;
            if (this.chart.chartOptions.gridStyle === "dashed")
            {
                for (var x = -4; x >= -area.axisX.length; x -= 4)
                {
                    context.moveTo(x, y);
                    context.lineTo(x + 3, y);
                }
            }
            else if (this.chart.chartOptions.gridStyle === "solid")
            {
                context.moveTo(0, y);
                context.lineTo(-area.axisX.length, y);
            }
        }

        context.stroke();
    };

    iChart.Charting.ChartRenderer.prototype.renderYLabels = function (area, context)
    {
        /// <summary>
        /// Renders ordinate labels, tick marks and grid lines in the specified area to the current canvas context.
        /// </summary>
        /// <param name="area" type="iChart.Charting.ChartArea">Chart area to render the labels for.</param>
        /// <param name="context" type="CanvasRenderingContext2D">Canvas context to render to.</param>

        context.save();
        context.translate(area.axisX.length, 0.5);

        context.font = this.chart.chartOptions.labelFont;
        context.textAlign = "left";
        context.textBaseline = "middle";

        if(this.chart.chartOptions.yLabelsOutside) {
            var interval = (area.axisY.max - area.axisY.min) / (area.axisY.length / 20);
        } else {
            var interval = (area.axisY.max - area.axisY.min) / (area.axisY.length / (area.axisY.length/4));
        }
        if (interval > 0)
        {
            var scale = 0;
            while (interval < 1)
            {
                --scale;
                interval *= 10;
            }

            while (interval >= 10)
            {
                ++scale;
                interval /= 10;
            }

            var scales = [1, 1.5, 2, 2.5, 3, 4, 5, 7.5];
            var j = 0;
            while (interval > scales[j] && j < scales.length)
            {
                ++j;
            }

            interval = (j === scales.length ? 10 : scales[j]) * Math.pow(10, scale);
        }

        var abbrScale = 0;
        var absMaximum = Math.max(Math.abs(area.axisY.min), Math.abs(area.axisY.max));
        if (absMaximum >= 10000000)
        {
            abbrScale = Math.floor(Math.log(absMaximum) / Math.log(1000));
        }

        var precision = interval / absMaximum;
        if (!$.isNumeric(precision) || precision < 1e-4)
        {
            interval = parseFloat((absMaximum / Math.pow(10, this.chart.labelPrecision - 1)).toPrecision(1));
        }

        var hasLabels = false;
        var value = Math.floor(area.axisY.max / interval) * interval;
        if ($.isNumeric(value))
        {
            while (value >= area.axisY.min)
            {
                this.renderYLabel(area, value, abbrScale, context);
                value -= interval;
                hasLabels = true;
            }
        }

        if (!hasLabels)
        {
            this.renderYLabel(area, (area.axisY.max + area.axisY.min) / 2, abbrScale, context);
        }

        context.restore();
    };
})();

/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartSelection = function (container)
    {
        /// <summary>
        /// Initializes a new instance of the iChart.Charting.ChartSelection class.
        /// </summary>
        /// <param name="container">Selection container.</param>
        /// <field name="$container" type="jQuery">jQuery chart container object.</field>
        /// <field name="$selection" type="jQuery">jQuery selection object.</field>

        this.$container = $(container);
        this.$selection = $("<div/>", { "class": "m-chart-selection" }).appendTo(this.$container);

        //$(document).bind('mousedown mouseup', function(e) {console.log(e.type, e)});
        //this.$container.bind('movestart move moveend', function(e) {console.log(e.type, e)});

        //this.$container.on('moveend', this, function(e) {
        this.$container.off('mouseup.selection').off('mousedown.selection').off('mousemove.selection');
        $(this.$container).on('mouseup.selection', this, function(e) {

            if (e.data.disabled)
            {
                return;
            }
            if (!e.data.selection)
            {
                return;
            }

            e.data.selection = false;
            e.data.$selection.hide();

            e.data.recalculateContainerPosition();
            e.data.x2 = e.pageX - e.data.containerOffset.left;
            e.data.y2 = e.pageY - e.data.containerOffset.top;

            if (e.data.x2 >= 0 && e.data.x2 <= e.data.containerWidth && e.data.y2 >= 0 && e.data.y2 <= e.data.containerHeight)
            {
                if (e.data.moveend)
                {
                    e.data.moveend(e.data);
                }
            }
        });

        this.$container.on('mousedown.selection', this, function(e) {

            if (e.data.disabled || e.which != 1)
            {
                return;
            }

            if(iChart.animateId) {
                cancelAnimationFrame(iChart.animateId);
            }

            e.data.selection = true;
            e.data.recalculateContainerPosition();
            e.data.x1 = e.pageX - e.data.containerOffset.left;
            e.data.y1 = e.pageY - e.data.containerOffset.top;

            e.data.timeStampLast = e.timeStamp;
            e.data.timeStamp = e.timeStamp;
            e.data.xPrev = e.data.x1;
            e.data.yPrev = e.data.y1;

            if (e.data.movestart)
            {
                e.data.movestart(e.data);
            }


        });

        this.$container.on('mousemove.selection', this, function(e) {
            if (e.data.disabled)
            {
                return;
            }

            if (!e.data.selection)
            {
                return;
            }

            var pageX = e.pageX;
            var pageY = e.pageY;
            if (typeof pageX === "undefined")
            {
                pageX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                pageY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
            }

            var x2 = Math.round(pageX - e.data.containerOffset.left);
            var y2 = Math.round(pageY - e.data.containerOffset.top);
            if (e.data.x2 === x2 && e.data.y2 === y2)
            {
                // Minor performance optimization: do not handle the same coordinates twice in a row.
                return;
            }

            e.data.xPrev = e.data.x2;
            e.data.yPrev = e.data.y2;

            e.data.x2 = x2;
            e.data.y2 = y2;

            e.data.timeStampLast = e.data.timeStamp;
            e.data.timeStamp = e.timeStamp;
            e.data.xSpeed = Math.abs(e.data.xPrev-x2) / (e.data.timeStamp - e.data.timeStampLast);

            if (e.data.x2 >= 0 && e.data.x2 <= e.data.containerWidth && e.data.y2 >= 0 && e.data.y2 <= e.data.containerHeight)
            {
                var showSelection = true;

                if (e.data.move)
                {
                    showSelection = e.data.move(e.data);
                }

                if (showSelection)
                {
                    e.data.$selection.css({
                        "display": "",
                        "left": (self.x1 < self.x2) ? self.x1 : self.x2,
                        "top": (self.y1 < self.y2) ? self.y1 : self.y2,
                        "width": (self.x1 < self.x2) ? self.x2 - self.x1 : self.x1 - self.x2,
                        "height": (self.y1 < self.y2) ? self.y2 - self.y1 : self.y1 - self.y2
                    });
                }
            }

        });
    };

    iChart.Charting.ChartSelection.prototype.disabled = false;
    iChart.Charting.ChartSelection.prototype.moved = false;
    iChart.Charting.ChartSelection.prototype.movestart = null;
    iChart.Charting.ChartSelection.prototype.move = null;
    iChart.Charting.ChartSelection.prototype.moveend = null;
//    iChart.Charting.ChartSelection.prototype.mousedown = null;
//    iChart.Charting.ChartSelection.prototype.mousemove = null;
//    iChart.Charting.ChartSelection.prototype.mouseup = null;
    iChart.Charting.ChartSelection.prototype.selection = false;

    iChart.Charting.ChartSelection.prototype.x1 = null;
    iChart.Charting.ChartSelection.prototype.y1 = null;
    iChart.Charting.ChartSelection.prototype.x2 = null;
    iChart.Charting.ChartSelection.prototype.y2 = null;

    iChart.Charting.ChartSelection.prototype.shiftAnchor = function (deltaX, deltaY)
    {
        /// <summary>
        /// Shifts selection anchor point.
        /// </summary>
        /// <param name="deltaX" type="">X shift.</param>
        /// <param name="deltaY" type="Number">Y shift.</param>

        if (this.anchorX !== null && deltaX)
        {
            this.anchorX += deltaX;
        }

        if (this.anchorY !== null && deltaY)
        {
            this.anchorY += deltaY;
        }
    };

    iChart.Charting.ChartSelection.prototype.setAnchor = function (x, y)
    {
        /// <summary>
        /// Sets selection anchor point.
        /// </summary>
        /// <param name="x" type="Number">X coordinate.</param>
        /// <param name="y" type="Number">Y coordinate.</param>

        this.anchorX = x;
        this.anchorY = y;
    };

    iChart.Charting.ChartSelection.prototype.disable = function ()
    {
        /// <summary>
        /// Disables the selection and resets it to the default state.
        /// </summary>

        this.disabled = true;
        this.selection = false;

        this.x1 = null;
        this.y1 = null;
        this.x2 = null;
        this.y2 = null;
    };

    iChart.Charting.ChartSelection.prototype.enable = function ()
    {
        /// <summary>
        /// Enables the selection and resets it to the default state.
        /// </summary>

        this.disabled = false;
        this.selection = false;

        this.x1 = null;
        this.y1 = null;
        this.x2 = null;
        this.y2 = null;
    };

    iChart.Charting.ChartSelection.prototype.recalculateContainerPosition = function ()
    {
        this.containerOffset = this.$container.offset();
        this.containerWidth = this.$container.width();
        this.containerHeight = this.$container.height();
    };
})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.ChartTouches = function (chart)
    {

        this.chart = chart;
        this.$container = $(chart.container);

        var _this = this;

        //this.$container.hammer().off("pinchstart pinchmove pinchend panstart panmove panend");
        this.$container.hammer({recognizers: [[Hammer.Pan],[Hammer.Pinch, { enable: true }]]}).on("pinchstart pinchmove pinchend panstart panmove panend", function(e) {
            //console.log(e);

            if(e.gesture.pointerType !== "touch") {
                return;
            }

            if(!_this.chart.areas) {
                return;
            }

            var area = _this.chart.areas[0],
                offset = _this.$container.offset();

            switch (e.type) {
                case "panstart":

                    var startPointX = e.gesture.pointers[0].pageX - e.gesture.deltaX - offset.left;
                    _this.startTouchIndexes.push(area.getXIndex(startPointX));
                    _this.lastGesture = e.gesture;

                    if(typeof _this.chart.selection.data == "undefined") {
                        _this.chart.selection.data = {};
                    }
                    _this.chart.selection.data.timeStampLast = e.timeStamp;
                    _this.chart.selection.data.timeStamp = e.timeStamp;
                    _this.chart.selection.data.x1 = startPointX;
                    _this.chart.selection.data.xPrev = startPointX;
                    _this.chart.selection.data.x = startPointX;

                    if(iChart.animateId) {
                        cancelAnimationFrame(iChart.animateId);
                    }

                    _this.chart.selection.setAnchor(
                        area.viewport.x.min,
                        area.viewport.y.min);


                    break;
                case "panend":
                    _this.startTouchIndexes = [];
                    _this.lastGesture = null;

                    if( _this.chart.chartOptions.inertialScrolling) {
                        _this.chart.env.scrollTo(_this.chart.selection.data);
                    }

                    break;
                case "panmove":

                    var x = e.gesture.pointers[0].pageX - offset.left;

                    if (_this.chart.viewport.x.min === null)
                    {
                        _this.chart.viewport.x.min = area.viewport.x.min;
                    }
                    if (_this.chart.viewport.x.max === null)
                    {
                        _this.chart.viewport.x.max = area.viewport.x.max;
                    }
                    _this.chart.viewport.areaName = area.name;

                    _this.chart.selection.data.xPrev = _this.chart.selection.data.x;
                    _this.chart.selection.data.x = x;
                    _this.chart.selection.data.x2 = x;
                    _this.chart.selection.data.timeStampLast = _this.chart.selection.data.timeStamp;
                    _this.chart.selection.data.timeStamp = e.timeStamp;
                    _this.chart.selection.data.xSpeed = Math.abs( _this.chart.selection.data.xPrev-x) / (_this.chart.selection.data.timeStamp - _this.chart.selection.data.timeStampLast);

                    var deltaX = e.gesture.deltaX - _this.lastGesture.deltaX;
                    deltaX = area.getXIndex(deltaX) - area.getXIndex(0);

                    if(((_this.chart.viewport.x.max - _this.chart.viewport.x.min) - deltaX) > 1) {
                        _this.chart.viewport.x.min += - deltaX;
                    }

                    if(((_this.chart.viewport.x.max) - deltaX) - _this.chart.viewport.x.min > 1) {
                        _this.chart.viewport.x.max += - deltaX;
                    }

                    _this.chart._fixViewportBounds();
                    _this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": true });
                    _this.chart.loadMissingData();

                    var deltaY = e.gesture.deltaY - _this.lastGesture.deltaY;
                    window.scroll(0, window.pageYOffset - deltaY);

                    _this.lastGesture = e.gesture;

                    break;
                case "pinchstart":

                    _this.disabled = false;

                    $.each(e.gesture.pointers, function(i, pointer) {
                        var startPointX = pointer.pageX - offset.left;
                        _this.startTouchIndexes.push(area.getXIndex(startPointX));
                    });

                    break;
                case "pinchend":
                    _this.startTouchIndexes = [];
                    break;
                case "pinchmove":

                    if(_this.disabled) {
                        return;
                    }

                    //console.log(e);

                    var minIdx = _this.startTouchIndexes.indexOf(Math.min.apply(null, _this.startTouchIndexes));
                    var maxIdx = _this.startTouchIndexes.indexOf(Math.max.apply(null, _this.startTouchIndexes));
                    var xMin = e.gesture.pointers[minIdx].pageX - offset.left;
                    var xMax = e.gesture.pointers[maxIdx].pageX - offset.left;

                    if (_this.chart.viewport.x.min === null)
                    {
                        _this.chart.viewport.x.min = area.viewport.x.bounded.min;
                    }
                    if (_this.chart.viewport.x.max === null)
                    {
                        _this.chart.viewport.x.max = area.viewport.x.bounded.max;
                    }

                    var newViewportXmin = _this.startTouchIndexes[minIdx] - xMin * (_this.startTouchIndexes[maxIdx] - _this.startTouchIndexes[minIdx]) / (xMax - xMin);
                    var newViewportXmax = _this.startTouchIndexes[maxIdx] + (area.innerWidth - xMax) * (_this.startTouchIndexes[maxIdx] - _this.startTouchIndexes[minIdx]) / (xMax - xMin);

                    var limit = newViewportXmax - newViewportXmin;

                    if(_this.chart.chartOptions.maxZoom > 0 && limit >= _this.chart.chartOptions.maxZoom) {
                        _this.chart.viewport.x.min = newViewportXmin;
                        _this.chart.viewport.x.max = newViewportXmax;

                        _this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": true });
                        _this.chart.loadMissingData();
                    }

                    break;
            }

        });
    };

    iChart.Charting.ChartTouches.prototype.disabled = false;
    iChart.Charting.ChartTouches.prototype.startTouchIndexes = [];
    iChart.Charting.ChartTouches.prototype.lastGesture = null;

})();
/**
 * @company  Tradernet
 * @package  iguanaChart
 */

(function ()
{
    "use strict";

    iChart.Charting.Prediction = function (data, chart)
    {
        this.data = data;
        this.chart = chart;

        this.style = {
            patternend: {strokeStyle: "rgb(153,153,153)", lineWidth: 1, lineDash: [7,2]},
            rectangle: {
                up: {strokeStyle: "rgb(0,137,0)", lineWidth: 1, lineDash: [5,2], fillStyle: "rgba(0,137,0,.3)"},
                down: {strokeStyle: "rgb(255,2,27)", lineWidth: 1, lineDash: [5,2], fillStyle: "rgba(255,2,27,.3)"}
            },
            polygon:  {strokeStyle: "rgb(102,178,139)", strokeStyle2: "rgb(72,118,177)", lineWidth: 3, fillStyle: "rgba(82,175,201,.2)"},
            fibonacci: {
                correction:     {strokeStyle: "rgb(119,119,119)"},
                arrow:          {strokeStyle: "rgb(251,0,251)", lineWidth: 1},
                line:           {strokeStyle: "rgb(204,204,204)", lineWidth: 1}
            },
            arrow: {
                down:   {strokeStyle: "rgb(219,132,61)", lineWidth: 3},
                up:     {strokeStyle: "rgb(15,156,0)", lineWidth: 3}
            },
            line: {
                simple:     {strokeStyle: "rgb(153,153,153)"},
                resistance: {strokeStyle: "rgb(102,178,139)", lineWidth: 2},
                support:    {strokeStyle: "rgb(72,118,177)", lineWidth: 2},
                patternend: {strokeStyle: "rgb(153,153,153)", lineWidth: 1, lineDash: [7,2]}
            },
            label: {
                size: 15
            }
        };

        return this;
    };

    iChart.Charting.Prediction.prototype.draw = function ()
    {
//console.log(this.data.clickthroughurl);
        switch (this.data.patterntype)
        {
            case "ChartPattern":
                this.ChartPattern();
                break;
            case "FibonacciPattern":
                this.FibonacciPattern();
                break;
            case "KeyLevelsPattern":
                this.KeyLevelsPattern();
                break;
            default:
                return undefined;
        }
        this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
    }

    iChart.Charting.Prediction.prototype.getTimeRange = function ()
    {
        switch (this.data.patterntype)
        {
            case "ChartPattern":
                var x0 = Math.min(this.data.resistancex0, this.data.supportx0);

                if(this.data.predictiontimefrom != undefined) {
                    var x1 = this.data.predictiontimeto;
                } else {
                    /*var x1 = this.chart.areas[0].xSeries[(Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))+7)];*/
                    var x1 = parseInt(this.data.patternendtime) + this.data.interval*60*7;
                }

                return [x0*1000, x1*1000];
            //--------------------------------------------------------------------------------------------------------------
            case "FibonacciPattern":
                var startTime = this.data.timeA;
                if(this.data.timeX > 0) {
                    startTime = Math.min(startTime, this.data.timeX);
                }

                var x0 = startTime;

                if(this.data.timeD > 0 && this.data.priceD > 0) {
                    var x1 = this.data.timeD;
                } else if (this.data.priceD > 0) {
                    var x1 = parseFloat(this.data.timeC) + parseFloat(this.data.interval) * 60 * parseInt(this.data.length);
                }

                if(this.data.target0 > 0 && this.data.target10 > 0) {
                    var endTime = parseInt(startTime) + this.data.interval * this.data.length * ((this.data.interval < 1440) ? 3 : 1);
                    x1 = endTime;
                }

                return [x0*1000, x1*1000];
            //--------------------------------------------------------------------------------------------------------------

            case "KeyLevelsPattern":
                var x0 = this.data.point1;

                /*
                if(this.data.predictionpricefrom) {
                    var predictiontimeto = parseFloat(this.data.predictiontimefrom) +  parseFloat(this.data.interval) * 60 * parseInt(this.data.predictiontimebars);
                    var x1 = this.chart.areas[0].getXValue(this.chart.areas[0].getXPositionByIndex(this.chart.areas[0].getXIndexByValue2(predictiontimeto)));

                } else {
                    var x1 = this.chart.areas[0].xSeries[(Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))+7)];
                }
                */
                if(this.data.predictionpricefrom) {
                    var predictiontimeto = parseFloat(this.data.predictiontimefrom) +  parseFloat(this.data.interval) * 60 * parseInt(this.data.predictiontimebars);
                    var x1 = predictiontimeto;

                } else {
                    var x1 = parseInt(this.data.patternendtime) + parseFloat(this.data.interval) * 60 * 7;
                }

                return [x0*1000, x1*1000];

            default:
                return false;
        }
    }

    /**
     *  Построение ChartPattern
     */
    iChart.Charting.Prediction.prototype.ChartPattern = function ()
    {
        var patternendtime  = this.chart.areas[0].getXPositionByValue(this.data.patternendtime);
        var resistancex0    = this.chart.areas[0].getXPositionByValue(this.data.resistancex0);
        var resistancex1    = this.chart.areas[0].getXPositionByValue(this.data.resistancex1);
        var supportx0       = this.chart.areas[0].getXPositionByValue(this.data.supportx0);
        var supportx1       = this.chart.areas[0].getXPositionByValue(this.data.supportx1);
        var resistancey0    = this.chart.areas[0].getYPosition(this.data.resistancey0);
        var resistancey1    = this.chart.areas[0].getYPosition(this.data.resistancey1);
        var supporty0       = this.chart.areas[0].getYPosition(this.data.supporty0);
        var supporty1       = this.chart.areas[0].getYPosition(this.data.supporty1);

        var shapeTimeX0     = Math.min(this.data.resistancex0, this.data.supportx0);
        var shapeTimeX1     = Math.max(this.data.resistancex1, this.data.supportx1);
        var shapeX0         = this.chart.areas[0].getXPositionByValue(shapeTimeX0);
        var shapeX1         = this.chart.areas[0].getXPositionByValue(shapeTimeX1);

/*        var ry0 = (((shapeX0-resistancex0)*(resistancey1-resistancey0))/(resistancex1-resistancex0))+parseFloat(resistancey0);
        var sy0 = (((shapeX0-supportx0)*(supporty1-supporty0))/(supportx1-supportx0))+parseFloat(supporty0);
        var ry1 = (((shapeX1-resistancex0)*(resistancey1-resistancey0))/(resistancex1-resistancex0))+parseFloat(resistancey0);
        var sy1 = (((shapeX1-supportx0)*(supporty1-supporty0))/(supportx1-supportx0))+parseFloat(supporty0);
*/
        var ry0 = (((shapeX0-resistancex0)*(resistancey1-resistancey0))/(resistancex1-resistancex0))+parseFloat(resistancey0);
        var sy0 = (((shapeX0-supportx0)*(supporty1-supporty0))/(supportx1-supportx0))+parseFloat(supporty0);
        var ry1 = (((patternendtime-resistancex0)*(resistancey1-resistancey0))/(resistancex1-resistancex0))+parseFloat(resistancey0);
        var sy1 = (((patternendtime-supportx0)*(supporty1-supporty0))/(supportx1-supportx0))+parseFloat(supporty0);

/*
        var element = this.chart.overlay.createElement("Line");
        element.points = [{'x':this.chart.areas[0].getXValue(x0)*1000, 'y':this.chart.areas[0].getYValue(ry0)},{'x':this.chart.areas[0].getXValue(patternendtime)*1000,'y':this.chart.areas[0].getYValue(ry1)}];
        element.hasSettings = true;
        element.settings = this.style.line.resistance;
        this.chart.overlay.history.push(element);

        var element = this.chart.overlay.createElement("Line");
        element.points = [{'x':this.chart.areas[0].getXValue(x0)*1000, 'y':this.chart.areas[0].getYValue(sy0)},{'x':this.chart.areas[0].getXValue(patternendtime)*1000,'y':this.chart.areas[0].getYValue(sy1)}];
        element.hasSettings = true;
        element.settings = this.style.line.support;
        this.chart.overlay.history.push(element);
*/

        var element = this.chart.overlay.createElement("Polygon");
/*        element.points = [{'x':this.chart.areas[0].getXValue(shapeX0)*1000, 'y':this.chart.areas[0].getYValue(ry0)},
                          {'x':this.chart.areas[0].getXValue(shapeX1)*1000,'y':this.chart.areas[0].getYValue(ry1)},
                          {'x':this.chart.areas[0].getXValue(shapeX1)*1000,'y':this.chart.areas[0].getYValue(sy1)},
                          {'x':this.chart.areas[0].getXValue(shapeX0)*1000, 'y':this.chart.areas[0].getYValue(sy0)}
                         ];
*/
        element.points = [{'x':this.chart.areas[0].getXValue(shapeX0)*1000, 'y':this.chart.areas[0].getYValue(ry0)},
                          {'x':this.chart.areas[0].getXValue(patternendtime)*1000,'y':this.chart.areas[0].getYValue(ry1)},
                          {'x':this.chart.areas[0].getXValue(patternendtime)*1000,'y':this.chart.areas[0].getYValue(sy1)},
                          {'x':this.chart.areas[0].getXValue(shapeX0)*1000, 'y':this.chart.areas[0].getYValue(sy0)}
                         ];
//        element.hasSettings = true;
        element.settings = this.style.polygon;
        this.chart.overlay.history.push(element);


        var element = this.chart.overlay.createElement("VerticalLine");
        element.hasSettings = true;
        element.settings = this.style.line.patternend;
        element.points = [{'x':this.chart.areas[0].getXValue(patternendtime)*1000, 'y':this.chart.areas[0].getYValue(sy0)}];
        this.chart.overlay.history.push(element);


        if(this.data.predictiontimefrom != undefined) {
//console.log(this.data.patternendtime);
//console.log(Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime)));
//console.log(this.chart.areas[0].ySeries[0].points[Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))]);

//            var prx = this.chart.areas[0].xSeries[(Math.round(this.chart.areas[0].getXIndexByValue2(shapeTimeX1)))+1];
//            var pry = this.chart.areas[0].ySeries[0].points[Math.round(this.chart.areas[0].getXIndexByValue2(shapeTimeX1))+1][3];
            var prx = this.chart.areas[0].xSeries[(Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime)))-1];

            var pryIndex = iChart.Charting.getNearestNotNullIndex(this.chart.areas[0].ySeries[0].points, Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))-1);
            var pry = this.chart.areas[0].ySeries[0].points[pryIndex][3];
            var prx2 = this.chart.areas[0].xSeries[(Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))+7)];

//console.log(prx2);
            var prx2 = Math.min(prx2, parseFloat(this.data.predictiontimefrom) + Math.round((this.data.predictiontimeto - this.data.predictiontimefrom) / 2));
//console.log(parseFloat(this.data.predictiontimefrom) + Math.round((this.data.predictiontimeto - this.data.predictiontimefrom) / 2));

            var element = this.chart.overlay.createElement("Arrow");
            element.hasSettings = true;
            if(this.data.direction == 1) {
                element.points = [{'x':prx*1000,'y':pry},{'x':prx2*1000, 'y':this.data.predictionpricefrom}];
                element.settings = this.style.arrow.up;
            } else {
                element.points = [{'x':prx*1000,'y':pry},{'x':prx2*1000, 'y':this.data.predictionpriceto}];
                element.settings = this.style.arrow.down;
            }
            this.chart.overlay.history.push(element);


            var element = this.chart.overlay.createElement("Rectangle");
            element.hasSettings = true;
            if(this.data.direction == 1) {
                element.settings = this.style.rectangle.up;
            } else {
                element.settings = this.style.rectangle.down;
            }
            var predictiontimeto = this.chart.areas[0].getXValue(this.chart.areas[0].getXPositionByIndex(this.chart.areas[0].getXIndexByValue2(this.data.predictiontimeto)));
            element.points = [{'x':this.data.patternendtime*1000,'y':this.data.predictionpricefrom},{'x':predictiontimeto*1000, 'y':this.data.predictionpriceto}];
//console.log(element.points);
            this.chart.overlay.history.push(element);
        } else {
//console.log((Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))-1));
            var prx = this.chart.areas[0].xSeries[(Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime)))-1];

            var pryIndex = iChart.Charting.getNearestNotNullIndex(this.chart.areas[0].ySeries[0].points, Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))-1);
            var pry = this.chart.areas[0].ySeries[0].points[pryIndex][3];
            var prx2 = this.chart.areas[0].xSeries[(Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))+7)];
            var prx2Pos = this.chart.areas[0].getXPositionByValue(prx2);

            var element = this.chart.overlay.createElement("Arrow");
            element.hasSettings = true;
            if(this.data.direction == 1) {
                var ry2Pos = (((prx2Pos-resistancex0)*(resistancey1-resistancey0))/(resistancex1-resistancex0))+parseFloat(resistancey0);
                element.settings = this.style.arrow.up;
            } else {
                var ry2Pos = (((prx2Pos-supportx0)*(supporty1-supporty0))/(supportx1-supportx0))+parseFloat(supporty0);
                element.settings = this.style.arrow.down;
            }
            element.points = [{'x':prx*1000,'y':pry},{'x':prx2*1000, 'y':this.chart.areas[0].getYValue(ry2Pos)}];
            this.chart.overlay.history.push(element);

        }

        this.chart.overlay.render();
        //iChart.setHashValues(this.chart.overlay.serialize());
        this.chart.overlay.syncHash();

//console.log(this.data);
    }

    /**
     * Построение FibonacciPattern
     */
    iChart.Charting.Prediction.prototype.FibonacciPattern = function ()
    {
//console.log(this.data);

        if(this.data.priceX > 0) {
            var element = this.chart.overlay.createElement("Line");
            element.hasSettings = true;
            element.settings = this.style.line.support;
            element.points = [{'x':this.data.timeX*1000, 'y':this.data.priceX},{'x':this.data.timeA*1000,'y':this.data.priceA}];
            this.chart.overlay.history.push(element);
        }

        if(this.data.priceA > 0) {
            var element = this.chart.overlay.createElement("Line");
            element.hasSettings = true;
            element.settings = this.style.line.support;
            element.points = [{'x':this.data.timeA*1000, 'y':this.data.priceA},{'x':this.data.timeB*1000,'y':this.data.priceB}];
            this.chart.overlay.history.push(element);
        }

        var element = this.chart.overlay.createElement("Line");
        element.hasSettings = true;
        element.settings = this.style.line.support;
        element.points = [{'x':this.data.timeB*1000, 'y':this.data.priceB},{'x':this.data.timeC*1000,'y':this.data.priceC}];
        this.chart.overlay.history.push(element);


        var startTime = this.data.timeA;
        if(this.data.timeX > 0) {
            startTime = Math.min(startTime, this.data.timeX);
        }
        var startIndex = this.chart.areas[0].getXIndexByValue2(startTime);
        var endIndex = startIndex + parseInt(this.data.interval/this.chart._dataSettings.timeframe * this.data.length*1.6);

        if(this.data.timeD > 0 && this.data.priceD > 0) {
            var element = this.chart.overlay.createElement("Line");
            element.hasSettings = true;
            element.settings = this.style.line.support;
            element.points = [{'x':this.data.timeC*1000, 'y':this.data.priceC},{'x':this.data.timeD*1000,'y':this.data.priceD}];
            this.chart.overlay.history.push(element);
        } else if (this.data.priceD > 0) {
            var element = this.chart.overlay.createElement("Arrow");
            element.hasSettings = true;
            element.settings = this.style.fibonacci.arrow;
            element.points = [{'x':this.data.timeC*1000, 'y':this.data.priceC},{'x':this.chart.areas[0].xSeries[endIndex]*1000 ,'y':this.data.priceD}];
            this.chart.overlay.history.push(element);

            if(this.data.priceX > 0) {
                var element = this.chart.overlay.createElement("Line");
                element.hasSettings = true;
                element.settings = this.style.fibonacci.line;
                element.points = [{'x':this.data.timeX*1000, 'y':this.data.priceX},{'x':this.chart.areas[0].xSeries[endIndex]*1000,'y':this.data.priceD}];
                this.chart.overlay.history.push(element);
            }
        }

        if(this.data.target0 > 0 && this.data.target10 > 0) {
            var element = this.chart.overlay.createElement("FibonacciCorrection");
            element.hasSettings = true;
            element.settings = this.style.fibonacci.correction;
            element.points = [{'x':this.chart.areas[0].xSeries[endIndex]*1000, 'y':this.data.target0},{'x':this.chart.areas[0].xSeries[endIndex]*1000,'y':this.data.target10}];
            this.chart.overlay.history.push(element);
        }

        if(this.data.target0 > 0 && this.data.target3 > 0) {
            var element = this.chart.overlay.createElement("Arrow");
            var prx2 = this.chart.areas[0].xSeries[endIndex+4];
            element.points = [{'x':this.chart.areas[0].xSeries[endIndex]*1000,'y':this.data.target0},{'x':prx2*1000, 'y':this.data.target3}];
            element.hasSettings = true;
            element.settings = this.style.fibonacci.correction;
            this.chart.overlay.history.push(element);
        }

        var element = this.chart.overlay.createElement("VerticalLine");
        element.points = [{'x':this.data.patternendtime*1000, 'y':this.data.price}];
        element.hasSettings = true;
        element.settings = this.style.line.simple;
        this.chart.overlay.history.push(element);


        if(this.data.timeX > 0) {
            var element = this.chart.overlay.createElement("Label");
            element.settings = {text: 'X', size: this.style.label.size};
            if(this.data.directionX == "down") {
                var price = this.chart.areas[0].getYPosition(this.data.priceX) + this.style.label.size;
                price = this.chart.areas[0].getYValue(price);
            } else {
                var price = this.data.priceX;
            }
            element.points = [{'x':this.data.timeX*1000, 'y':price}];
            this.chart.overlay.history.push(element);
        }

        if(this.data.timeA > 0) {
            var element = this.chart.overlay.createElement("Label");
            element.settings = {text: 'A', size: this.style.label.size};
            if(this.data.directionA == "down") {
                var price = this.chart.areas[0].getYPosition(this.data.priceA) + this.style.label.size;
                price = this.chart.areas[0].getYValue(price);
            } else {
                var price = this.data.priceA;
            }
            element.points = [{'x':this.data.timeA*1000, 'y':price}];
            this.chart.overlay.history.push(element);
        }

        if(this.data.timeB > 0) {
            var element = this.chart.overlay.createElement("Label");
            element.settings = {text: 'B', size: this.style.label.size};
            if(this.data.directionB == "down") {
                var price = this.chart.areas[0].getYPosition(this.data.priceB) + this.style.label.size;
                price = this.chart.areas[0].getYValue(price);
            } else {
                var price = this.data.priceB;
            }
            element.points = [{'x':this.data.timeB*1000, 'y':price}];
            this.chart.overlay.history.push(element);
        }

        if(this.data.timeC > 0) {
            var element = this.chart.overlay.createElement("Label");
            element.settings = {text: 'C', size: this.style.label.size};
            if(this.data.directionC == "down") {
                var price = this.chart.areas[0].getYPosition(this.data.priceC) + this.style.label.size;
                price = this.chart.areas[0].getYValue(price);
            } else {
                var price = this.data.priceC;
            }
            element.points = [{'x':this.data.timeC*1000, 'y':price}];
            this.chart.overlay.history.push(element);
        }

        if(this.data.timeD > 0) {
            var element = this.chart.overlay.createElement("Label");
            element.settings = {text: 'D', size: this.style.label.size};
            if(this.data.directionD == "down") {
                var price = this.chart.areas[0].getYPosition(this.data.priceD) + this.style.label.size;
                price = this.chart.areas[0].getYValue(price);
            } else {
                var price = this.data.priceD;
            }
            element.points = [{'x':this.data.timeD*1000, 'y':price}];
            this.chart.overlay.history.push(element);
        }

        this.chart.overlay.render();
        //iChart.setHashValues(this.chart.overlay.serialize());
        this.chart.overlay.syncHash();

    }

    /**
     * Построение KeyLevelsPattern
     */
    iChart.Charting.Prediction.prototype.KeyLevelsPattern = function ()
    {
//console.log(this.data);

        var element = this.chart.overlay.createElement("HorizontalLine");
        element.points = [{'x':this.data.patternendtime*1000, 'y':this.data.price}];
        element.hasSettings = true;
        element.settings = this.style.line.simple;
        this.chart.overlay.history.push(element);

        var element = this.chart.overlay.createElement("VerticalLine");
        element.points = [{'x':this.data.patternendtime*1000, 'y':this.data.price}];
        element.hasSettings = true;
        element.settings = this.style.line.simple;
        this.chart.overlay.history.push(element);

        var element = this.chart.overlay.createElement("Line");
        element.points = [{'x':this.data.point1*1000, 'y':this.data.price},{'x':this.data.patternendtime*1000,'y':this.data.price}];
        element.hasSettings = true;
        if(this.data.pattern == "Support") {
            element.settings = this.style.line.support;
        } else {
            element.settings = this.style.line.resistance;
        }
        this.chart.overlay.history.push(element);


        if(this.data.predictionpricefrom) {
            var prx = this.chart.areas[0].xSeries[(Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))-1)];
            var pryIndex = iChart.Charting.getNearestNotNullIndex(this.chart.areas[0].ySeries[0].points, Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))-1);
            var pry = this.chart.areas[0].ySeries[0].points[pryIndex][3];
            var prx2 = this.chart.areas[0].xSeries[(Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))+7)];

            var element = this.chart.overlay.createElement("Arrow");
            element.hasSettings = true;
            if(this.data.direction == 1) {
                var pry2 = this.data.predictionpricefrom;
                element.settings = this.style.arrow.up;
            } else {
                element.settings = this.style.arrow.down;
                var pry2 = this.data.predictionpriceto;
            }

            element.points = [{'x':prx*1000,'y':pry},{'x':prx2*1000,'y':pry2}];
            this.chart.overlay.history.push(element);


            var element = this.chart.overlay.createElement("Rectangle");
            element.hasSettings = true;
            if(this.data.direction == 1) {
                element.settings = this.style.rectangle.up;
            } else {
                element.settings = this.style.rectangle.down;
            }

            var predictiontimeto = parseFloat(this.data.predictiontimefrom) +  parseFloat(this.data.interval) * 60 * parseInt(this.data.predictiontimebars);
            predictiontimeto = this.chart.areas[0].getXValue(this.chart.areas[0].getXPositionByIndex(this.chart.areas[0].getXIndexByValue2(predictiontimeto)));
            element.points = [{'x':this.data.patternendtime*1000,'y':this.data.predictionpricefrom},{'x':predictiontimeto*1000, 'y':this.data.predictionpriceto}];
//console.log(element.points);
            this.chart.overlay.history.push(element);

        } else {
            var prx = this.chart.areas[0].xSeries[(Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))-1)];
            var pryIndex = iChart.Charting.getNearestNotNullIndex(this.chart.areas[0].ySeries[0].points, Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))-1);
            var pry = this.chart.areas[0].ySeries[0].points[pryIndex][3];
            var prx2 = this.chart.areas[0].xSeries[(Math.round(this.chart.areas[0].getXIndexByValue2(this.data.patternendtime))+7)];

            var element = this.chart.overlay.createElement("Arrow");
            element.points = [{'x':prx*1000,'y':pry},{'x':prx2*1000,'y':this.data.price}];
            element.hasSettings = true;
            if(this.data.direction == 1) {
                element.settings = this.style.arrow.up;
            } else {
                element.settings = this.style.arrow.down;
            }
            this.chart.overlay.history.push(element);
        }


        this.chart.overlay.render();
        //iChart.setHashValues(this.chart.overlay.serialize());
        this.chart.overlay.syncHash();

    }

    iChart.Charting.Prediction.prototype.getThirdPoint = function (point1, point2, x)
    {
        var y = (((parseFloat(x)-parseFloat(point1.x))*(parseFloat(point2.y)-parseFloat(point1.y)))/(parseFloat(point2.x)-parseFloat(point1.x)))+parseFloat(point1.y);
        return {x: parseFloat(x), y: y};
    }

    iChart.Charting.Prediction.prototype.getIntersection = function (p1, p2, p3, p4)
    {
        if(((p1.y-p2.y)*(p4.x-p3.x)-(p3.y-p4.y)*(p2.x-p1.x)) != 0 && (p4.x-p3.x) != 0) {
            var x=-((p1.x*p2.y-p2.x*p1.y)*(p4.x-p3.x)-(p3.x*p4.y-p4.x*p3.y)*(p2.x-p1.x))/((p1.y-p2.y)*(p4.x-p3.x)-(p3.y-p4.y)*(p2.x-p1.x));
            var y=((p3.y-p4.y)*(-x)-(p3.x*p4.y-p4.x*p3.y))/(p4.x-p3.x);
            return {x: x, y: y};
        } else {
            return false;
        }

    }

})();

/**
 * Created by gti on 28.06.16.
 */

$.views.settings.allowCode(true);

$.templates("iChart_mainTmpl", '' +
    '<div class="iChart-control-form" style="min-height: 200px">' +
        '<div class="js-chartContainerWrapper">' +
            '<div class="iChartToolsContainer"><div class="iChartToolsTop" style="display: none;">' +
            '</div></div>' +
            '<div id="{{:id}}" class="m-chart-container" style="height: 100%;">' +
            '</div>' +
        '</div>' +
        '<div data-uk-modal="{center:true}" class="uk-modal iChart-form-simple-v js-chartTADialog uk-padding-remove {{:name}}" id="iChart-tech-analysis-dialog" style="display: none;">' +
            '<div class="uk-modal-dialog">' +
                '<a class="uk-modal-close uk-close"></a>' +
                '<div class="uk-modal-header">' + _t('3101', "Индикаторы") + '</div>' +
                '<div class="js-chartTADialogContainer"></div>' +
                '<div class="uk-modal-footer">' +
                    '<div class="uk-flex uk-flex-middle uk-flex-space-between tm-pad-large">' +
                        '<div class="js-indicator-add md-btn md-btn-small md-btn-success">' +
                            _t('15460', 'Добавить индикатор') +
                        '</div>' +
                    '<div class="md-btn-group"><a class="md-btn md-btn-small md-btn-primary indicators-set" href="#">' + _t('532', 'Применить') + '</a>' +
                        '<a class="md-btn md-btn-small indicators-default" href="#">' + _t('15461', 'Для всех') + '</a>' +
                        '<a class="md-btn md-btn-small indicators-close" href="#">' + _t('1403', "Отмена") + '</a></div>' +
                    '</div>' +
                '</div>' +
            '</div>' +
        '</div>' +
        '<div class="chart-loader-wrapper" style="top: 0; width: 100%; height: 100%;"><div class="chart-loader"></div></div>' +
    '</div>'
);

$.templates("iChart_topToolBarTmpl", '' +

    '<div class="tm-tool-bar uk-flex uk-flex-space-between">' +
        '<div class="uk-flex uk-flex-left uk-position-relative">' +

            '<div data-uk-dropdown="" class="uk-position-relative">' +
                '<div class="tm-graph-button active uk-flex uk-flex-center uk-flex-middle" data-uk-tooltip="{pos:\'top\'}" title="">' +
                    '<i class="sprite sprite-icon-line js-chart-ui-control-state" data-property="chartType"></i>' +
                '</div>' +
                '<div class="uk-dropdown-blank" style="width: auto">' +
                    '<div class="uk-flex uk-flex-left tm-shadow">' +

                        '<div class="tm-graph-button uk-flex uk-flex-column uk-flex-center uk-flex-middle" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17371', 'Line chart') + '">' +
                            '<i class="sprite sprite-icon-line js-chart-ui-control" data-property="chartType" data-value="Line"></i>' +
                        '</div>' +

                        '<div class="tm-graph-button uk-flex uk-flex-column uk-flex-center uk-flex-middle" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17372', 'Candlestick chart') + '">' +
                            '<i class="sprite sprite-icon-candle js-chart-ui-control" data-property="chartType" data-value="Candlestick"></i>' +
                        '</div>' +

                        '<div class="tm-graph-button uk-flex uk-flex-column uk-flex-center uk-flex-middle" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17373', 'Bar chart') + '">' +
                            '<i class="sprite sprite-icon-bars js-chart-ui-control" data-property="chartType" data-value="Stock"></i>' +
                        '</div>' +

                    '</div>' +
                '</div>' +
            '</div>' +

            '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control js-chart-ui-control-state" data-property="showVolumeByPrice" data-value="false" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17374', 'Display volume horizontally') + '">' +
                '<i class="sprite sprite-icon-h-volume"></i>' +
            '</div>' +

            '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control js-chart-ui-control-state" data-property="showVolume" data-value="false" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17375', 'Display volume vertically') + '">' +
                '<i class="sprite sprite-icon-v-volume"></i>' +
            '</div>' +

            '<div class="tm-graph-button uk-flex uk-flex-column uk-flex-center uk-flex-middle js-chart-ui-control js-chart-ui-control-state" data-property="percentMode" data-value="false" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17376', 'Relative price') + '">' +
                '<i class="sprite sprite-icon-price"></i>' +
            '</div>' +

            '<i class="sprite sprite-icon-divider"></i>' +

            '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control js-chart-ui-control-state" data-property="themeConfig" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17377', 'Visual Settings') + '">' +
                '<i class="sprite sprite-icon-palette"></i>' +
            '</div>' +

            '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control js-chart-ui-control-state" data-property="instrumentText" data-value="Text" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17378', 'Add Text') + '">' +
                '<i class="sprite sprite-icon-font"></i>' +
            '</div>' +

            '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control js-chart-ui-control-state" data-property="instrumentText" data-value="Bubble" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17379', 'Add Tooltip') + '">' +
                '<i class="sprite sprite-icon-f-comment"></i>' +
            '</div>' +

            '<div data-uk-dropdown="" class="uk-position-relative">' +
                '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control-state" data-property="instrumentLine" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17380', 'Draw Line') + '">' +
                    '<i class="sprite sprite-icon-arrow-line"></i>' +
                '</div>' +
                '<div class="uk-dropdown-blank" style="width: auto">' +
                    '<div class="uk-flex uk-flex-left tm-shadow">' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentLine" data-value="Arrow" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17386', 'Arrow') + '">' +
                            '<i class="sprite sprite-icon-arrow-line"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentLine" data-value="Line" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17381', 'Free Line') + '">' +
                            '<i class="sprite sprite-icon-free-line"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentLine" data-value="HorizontalLine" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17382', 'Horizontal line') + '">' +
                            '<i class="sprite sprite-icon-h-line"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentLine" data-value="VerticalLine" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17383', 'Vertical line') + '">' +
                            '<i class="sprite sprite-icon-v-line"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentLine" data-value="Channel" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17384', 'Channel') + '">' +
                            '<i class="sprite sprite-icon-channel"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentLine" data-value="Trend" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17385', 'Corner Trend') + '">' +
                            '<i class="sprite sprite-icon-angle-trend"></i>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '</div>' +

            '<div data-uk-dropdown="" class="uk-position-relative">' +
                '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control-state" data-property="instrumentForm" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17387', 'Draw Form') + '">' +
                    '<i class="sprite sprite sprite-icon-f-square"></i>' +
                '</div>' +
                '<div class="uk-dropdown-blank" style="width: auto">' +
                    '<div class="uk-flex uk-flex-left tm-shadow">' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentForm" data-value="Polygon" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17388', 'Poligon') + '">' +
                            '<i class="sprite sprite-icon-f-poligon"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentForm" data-value="Rectangle" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17389', 'Rectangle') + '">' +
                            '<i class="sprite sprite-icon-f-square"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentForm" data-value="Triangle" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17390', 'Triangle') + '">' +
                            '<i class="sprite sprite-icon-f-triangle"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentForm" data-value="Ellipse" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17391', 'Ellipse') + '">' +
                            '<i class="sprite sprite-icon-f-ellipse"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentForm" data-value="FibonacciArc" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17392', 'Fibonacci Archs') + '">' +
                            '<i class="sprite sprite-icon-f-fibonacci-arcs"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentForm" data-value="FibonacciFan" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17393', 'Fibonacci Fan') + '">' +
                            '<i class="sprite sprite-icon-f-fibonacci-fan"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentForm" data-value="FibonacciCorrection" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17394', 'Fibonacci Retracement') + '">' +
                            '<i class="sprite sprite-icon-f-fibonacci-correction"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="instrumentForm" data-value="HorizontalRange" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17912', 'Горизонтальный диапазон') + '">' +
                            '<i class="sprite sprite-icon-h-line-double"></i>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '</div>' +

            '<div data-uk-dropdown="" class="uk-position-relative">' +
                '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle" data-uk-tooltip="{pos:\'top\'}" title="">' +
                    '<i class="sprite sprite-icon-1px js-chart-ui-control-state" data-property="lineWidthSelector"></i>' +
                '</div>' +
                '<div class="uk-dropdown-blank" style="width: auto">' +
                    '<div class="uk-flex uk-flex-left tm-shadow">' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="lineWidthSelector" data-value="1" data-uk-tooltip="{pos:\'top\'}" title="Line 1px">' +
                            '<i class="sprite sprite-icon-1px"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="lineWidthSelector" data-value="2" data-uk-tooltip="{pos:\'top\'}" title="Line 2px">' +
                            '<i class="sprite sprite-icon-2px"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="lineWidthSelector" data-value="3" data-uk-tooltip="{pos:\'top\'}" title="Line 3px">' +
                            '<i class="sprite sprite-icon-3px"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="lineWidthSelector" data-value="4" data-uk-tooltip="{pos:\'top\'}" title="Line 4px">' +
                            '<i class="sprite sprite-icon-4px"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="lineWidthSelector" data-value="5" data-uk-tooltip="{pos:\'top\'}" title="Line 5px">' +
                            '<i class="sprite sprite-icon-5px"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="lineWidthSelector" data-value="8" data-uk-tooltip="{pos:\'top\'}" title="Line 8px">' +
                            '<i class="sprite sprite-icon-8px"></i>' +
                        '</div>' +
                        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="lineWidthSelector" data-value="10" data-uk-tooltip="{pos:\'top\'}" title="Line 10px">' +
                            '<i class="sprite sprite-icon-10px"></i>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '</div>' +

            '<div data-uk-dropdown="" class="uk-position-relative js-chart-ui-control" data-property="fillStyle">' +
                '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle" data-uk-tooltip="{pos:\'top\'}" title="Fill Color">' +
                    '<div class="tm-fill-color js-chart-ui-control-state" data-property="fillStyle" style="background-color: rgba(82, 175, 201, 0.5);"></div>' +
                    '<i class="sprite sprite-icon-fill-color"></i>' +
                 '</div>' +
                '<div class="uk-dropdown-blank" style="width: auto">' +
                    '<div class="uk-flex uk-flex-left tm-shadow js-chart-ui-control-holder">' +
                        '<div class="js-colorPalette" data-option="fillStyle"></div>' +
                        '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="fillStyle" data-element="canvas" value="" size="10"/>' +
                    '</div>' +
                '</div>' +
            '</div>' +

            '<div data-uk-dropdown="" class="uk-position-relative js-chart-ui-control" data-property="strokeStyle">' +
                '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle" data-uk-tooltip="{pos:\'top\'}" title="Line Color">' +
                    '<div class="tm-line-color js-chart-ui-control-state" data-property="strokeStyle" style="background-color: rgb(82, 175, 201);"></div>' +
                    '<i class="sprite sprite-icon-line-color"></i>' +
                '</div>' +
                '<div class="uk-dropdown-blank" style="width: auto">' +
                    '<div class="uk-flex uk-flex-left tm-shadow js-chart-ui-control-holder">' +
                        '<div class="js-colorPalette" data-option="strokeStyle"></div>' +
                        '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="strokeStyle" data-element="canvas" value="" size="10"/>' +
                    '</div>' +
                '</div>' +
            '</div>' +

            '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="captureImage" data-value="" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17493', 'Screenshot') + '">' +
                '<i class="sprite sprite-icon-camera"></i>' +
            '</div>' +

            '<i class="sprite sprite-icon-divider"></i>' +

            '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="clearInstruments" data-value="" data-uk-tooltip="{pos:\'top\'}" title="' + _t('17395', 'Clear Chart') + '">' +
                '<i class="sprite sprite-icon-trash"></i>' +
            '</div>' +

        '</div>' +

        '<div class="uk-flex uk-flex-left">' +

        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="dataInterval" data-value="I1" data-uk-tooltip="{pos:\'top\'}" title="1 minute > day">' +
            '<i class="sprite sprite-icon-1m"></i>' +
        '</div>' +

        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="dataInterval" data-value="I5" data-uk-tooltip="{pos:\'top\'}" title="5 minutes > 3 days">' +
            '<i class="sprite sprite-icon-5m"></i>' +
        '</div>' +

        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="dataInterval" data-value="I15" data-uk-tooltip="{pos:\'top\'}" title="15 minutes > week">' +
            '<i class="sprite sprite-icon-15m"></i>' +
        '</div>' +

        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="dataInterval" data-value="H1" data-uk-tooltip="{pos:\'top\'}" title="Hour">' +
            '<i class="sprite sprite-icon-h"></i>' +
        '</div>' +

        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="dataInterval" data-value="D1" data-uk-tooltip="{pos:\'top\'}" title="Day">' +
            '<i class="sprite sprite-icon-d"></i>' +
        '</div>' +

        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle js-chart-ui-control" data-property="dataInterval" data-value="D7" data-uk-tooltip="{pos:\'top\'}" title="Week">' +
            '<i class="sprite sprite-icon-w"></i>' +
        '</div>' +

        '<i class="sprite sprite-icon-divider"></i>' +

        '<div class="js-chart-ui-indicators"></div>' +
    '</div>'
);


$.templates("indicatorsCurrentTmpl", '' +
    '{{for userData}}' +
    '<div>' +
        '<span>{{:name}}</span> ' +
        '<span>' +
            '{{if params}}' +
            '{{* window.i=0;}}' +
            '(' +
            '{{props params}}' +
                '{{* if (i>0) { }}, {{* } }}{{>prop}}' +
                '{{* i++;}}' +
            '{{/props}}' +
            ')' +
            '{{/if}}' +
        '</span>' +
        '<span>' +
            '<a href="javascript:void(0);" onclick="return false;" data-index="{{:#index}}" class="js-edit-indicator uk-icon-cog uk-margin-left"></a>' +
            '<a href="javascript:void(0);" onclick="return false;" data-index="{{:#index}}" class="js-remove-indicator uk-icon-close uk-margin-left"></a>' +
        '</span>' +
    '</div>' +
    '{{/for}}'
);

$.templates("indicatorsListTmpl", '' +
    '<ul class="uk-list uk-list-line">' +
        '{{for indicators}}' +
            '<li><a href="javascript:void(0);" onclick="return false;" class="js-add-indicator" data-value="{{:value}}">{{:value}}</a></li>' +
        '{{/for}}' +
    '</ul>'
);

$.templates("indicatorsDropdownTmpl",

    '<div class="js-iChartTools-indicators uk-button-dropdown" data-uk-dropdown="{mode:\'click\', pos:\'bottom-right\'}" class="uk-position-relative">' +
        '<div class="tm-graph-button uk-flex uk-flex-center uk-flex-middle" data-uk-tooltip="{pos:\'top\'}" title="Add Indicator" style="min-width: 100px">' +
            '<i class="sprite sprite-icon-text-indicators"></i>' +
        '</div>' +
        '<div class="uk-dropdown uk-dropdown-bottom uk-dropdown-scrollable" style="top: 30px; left: 0px;">' +
            '<div class="tm-shadow">' +
                '<div class="uk-panel js-iChartTools-indicators-current">' +
                    '{{include tmpl="indicatorsCurrentTmpl"/}}' +
                '</div>' +
                '<div class="js-iChartTools-indicators-list">' +
                    '{{include tmpl="indicatorsListTmpl"/}}' +
                '</div>' +
            '</div>' +
        '</div>' +
    '</div>'
);

$.templates("indicatorDialogTmpl", '' +
    '<div class="iChartDialog" style="display: none; width: 300px;">' +
        '<div> {{:name}} </div>' +
        '<div class="js-iChartTools-indicators-params">' +
            '{{for parameters}}' +
                '<div>{{:Name}} <input type="text" name="{{:Code}}" value="{{:Value}}" /></div>' +
            '{{/for}}' +
        '</div>' +
        '<div class="js-iChartTools-indicators-colorContainer"></div>' +
        '<div class="js-iChartTools-indicators-widthContainer"></div>' +
        '<div>' +
            '<a  href="javascript:void(0);" onclick="return false;" class="uk-button js-set-params-indicator">Ok</a>' +
            '<a  href="javascript:void(0);" onclick="$.modal.impl.close(); return false;" class="uk-button">Cancel</a>' +
        '</div>' +
    '</div>'
);

$.templates("captureDialogTmpl", '' +
    '<div class="iChartDialog " style="display: none;">' +
        '<img class="js-iChartTools-capture"/>' +
        '<div class="uk-flex uk-flex-right" style="max-width: 100%;">' +
        '<span class="uk-margin-left">' +
        '<a  href="javascript:void(0);" onclick="return false;" class="uk-button js-set-params-indicator">' + _t('1402', 'Сохранить') + '</a>' +
        '</span>' +
        '<span class="uk-margin-left">' +
        '<a  href="javascript:void(0);" onclick="$.modal.impl.close(); return false;" class="uk-button js-set-params-indicator">' + _t('534', 'Закрыть') + '</a>' +
        '</span>' +
        '</div>' +
    '</div>'
);

$.templates("themeConfigSelectorTmpl", '' +
    '<div class="uk-button-dropdown" data-uk-dropdown="{mode:\'click\'}" aria-haspopup="true" aria-expanded="false">' +
        '<button class="uk-button uk-button-success">' + _t('13663', 'Темы') + ' <i class="uk-icon-caret-down"></i></button>' +
        '<div class="uk-dropdown uk-dropdown-up uk-dropdown-small uk-dropdown-scrollable">' +
            '<ul class="uk-nav uk-nav-dropdown">' +
                '{{for themes}}' +
                '<li><a href="#" class="js-themeSelect" data-theme="{{: name }}">{{: name }}' +
                    '{{if custom}}' +
                    '<span class="js-themeDelete uk-icon-trash-o uk-margin-small-left uk-badge uk-badge-warning uk-panel-hover uk-float-right" data-name="{{: name }}" title="' + _t('4023', 'Удалить') + '"></span>' +
                    '{{/if}}' +
                    '</a>' +
                '</li>' +
                '{{/for}}' +
                '<li class="uk-nav-divider"></li>' +
                '<li><a href="#" class="js-themeSaveAs">' + _t('13664', 'Сохранить как') + '</a></li>' +
            '</ul>' +
        '</div>' +
    '</div>'
);

$.templates("themeConfigTmpl", '' +
    '<div class="js-themeConfig" style="display: none">' +
        '<div class="js-themeConfigOptions"></div>' +
        '<div class="uk-grid uk-grid-small">' +
            '<div class="uk-width-1-1">' +
                '<div class="js-themeConfigSelector"></div>' +
            '</div>' +
        '</div>' +
        '<hr class="uk-grid-divider" style="margin: 15px 0">' +
        '<div class="uk-grid uk-grid-small">' +
            '<div class="uk-width-7-10 js-themeAdditionButtons">' +
            '</div>' +
            '<div class="uk-width-3-10 uk-text-right">' +
                '<button class="uk-button js-chartOptions" data-value="cancel">' + _t('1403', 'Отмена') + '</button> ' +
                '<button class="uk-button  uk-button-primary js-chartOptions" data-value="ok">' + _t('3920', "OK") + '</button>' +
            '</div>' +
        '</div>' +
    '</div>'
);

$.templates("themeConfigOptionsTmpl", '' +
    '<div class="uk-grid">' +
        '<div class="uk-width-1-2">' +
            '<div class="uk-grid">' +
                '<div class="uk-width-3-4">' +
                    _t('13643', 'Фон') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="backgroundColor" style="background-color: {{: chartOptions.backgroundColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="backgroundColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="backgroundColor" data-element="canvas" value="{{: chartOptions.backgroundColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13644', 'Линии осей') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-checkbox" data-option="showAxes">' +
                        '<input type="checkbox" class="js-flag" data-option="showAxes" {{if chartOptions.showAxes}}checked="checked"{{/if}}/>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13645', 'Цвет осей') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="axisColor" style="background-color: {{: chartOptions.axisColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="axisColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="axisColor" data-element="canvas" value="{{: chartOptions.axisColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13646', 'Цвет меток') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="labelColor" style="background-color: {{: chartOptions.labelColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="labelColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="labelColor" data-element="canvas" value="{{: chartOptions.labelColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('87207', 'Цвет текста лейблов') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="labelFontColor" style="background-color: {{: chartOptions.labelFontColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="labelFontColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="labelFontColor" data-element="canvas" value="{{: chartOptions.labelFontColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13647', 'Цвет сетки') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="gridColor" style="background-color: {{: chartOptions.gridColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="gridColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="gridColor" data-element="canvas" value="{{: chartOptions.gridColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13648', 'Цвет текста подложки') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="watermarkColor" style="background-color: {{: chartOptions.watermarkColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="watermarkColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="watermarkColor" data-element="canvas" value="{{: chartOptions.watermarkColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13649', 'Цвет области') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="areaColor" style="background-color: {{: chartOptions.areaColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="areaColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="areaColor" data-element="canvas" value="{{: chartOptions.areaColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13650', 'Цвет границы области') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="areaLineColor" style="background-color: {{: chartOptions.areaLineColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="areaLineColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="areaLineColor" data-element="canvas" value="{{: chartOptions.areaLineColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13651', 'Цвет объемов') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="volumeStyle" style="background-color: {{: chartOptions.volumeStyle }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="volumeStyle"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="volumeStyle" data-element="canvas" value="{{: chartOptions.volumeStyle }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13652', 'Цвет фона скроллера') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="scrollerOverlayColor" style="background-color: {{: chartOptions.scrollerOverlayColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="scrollerOverlayColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="scrollerOverlayColor" data-element="canvas" value="{{: chartOptions.scrollerOverlayColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13653', 'Цвет скроллера') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="scrollerHandlerColor" style="background-color: {{: chartOptions.scrollerHandlerColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                        '<div class="js-colorPalette" data-option="scrollerHandlerColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="scrollerHandlerColor" data-element="canvas" value="{{: chartOptions.scrollerHandlerColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('15810', 'Цвет теней') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="shadowColor" style="background-color: {{: chartOptions.shadowColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="shadowColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="shadowColor" data-element="canvas" value="{{: chartOptions.shadowColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '</div>' +
        '</div>' +
        '<div class="uk-width-1-2">' +
            '<div class="uk-grid">' +
                '<div class="uk-width-3-4">' +
                    _t('3103', 'Свеча вверх') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="candleUp" style="background-color: {{: chartOptions.candleUp }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="candleUp"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="candleUp" data-element="canvas" value="{{: chartOptions.candleUp }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('3104', 'Свеча вниз') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="candleDown" style="background-color: {{: chartOptions.candleDown }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="candleDown"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="candleDown" data-element="canvas" value="{{: chartOptions.candleDown }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13654', 'Обводка свечи') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-checkbox" data-option="candleBorder">' +
                        '<input type="checkbox" class="js-flag" data-option="candleBorder" {{if chartOptions.candleBorder}}checked="checked"{{/if}}/>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13655', 'Обводка свечи вверх') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="candleBorderUp" style="background-color: {{: chartOptions.candleBorderUp }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="candleBorderUp"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="candleBorderUp" data-element="canvas" value="{{: chartOptions.candleBorderUp }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13656', 'Обводка свечи вниз') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="candleBorderDown" style="background-color: {{: chartOptions.candleBorderDown }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="candleBorderDown"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="candleBorderDown" data-element="canvas" value="{{: chartOptions.candleBorderDown }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13657', 'Тень свечи') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-checkbox" data-option="candleWick">' +
                        '<input type="checkbox" class="js-flag" data-option="candleWick" {{if chartOptions.candleWick}}checked="checked"{{/if}}/>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13658', 'Цвет тени свечи') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="candleWickStyle" style="background-color: {{: chartOptions.candleWickStyle }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="candleWickStyle"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="candleWickStyle" data-element="canvas" value="{{: chartOptions.candleWickStyle }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13659', 'Бар вверх') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="stockUp" style="background-color: {{: chartOptions.stockUp }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="stockUp"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="stockUp" data-element="canvas" value="{{: chartOptions.stockUp }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13660', 'Бар вниз') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="stockDown" style="background-color: {{: chartOptions.stockDown }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="stockDown"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="stockDown" data-element="canvas" value="{{: chartOptions.stockDown }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13661', 'Толщина бара') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-widthSlector" data-option="stockWidth">' +
                        '<div class="js-widthSlectorValue lineWidth" data-option="stockWidth" data-style="{{: chartOptions.stockWidth }}"></div>' +
                            '<div class="menuHolder" style="display: none; padding: 10px;">' +
                                '<div class="js-widthSlectorWrapper" data-option="stockWidth" value="{{: chartOptions.stockWidth }}">' +
                                    '<span class="lineWidth js-lineWidth" data-style="1"></span>' +
                                    '<span class="lineWidth js-lineWidth" data-style="2"></span>' +
                                    '<span class="lineWidth js-lineWidth" data-style="3"></span>' +
                                    '<span class="lineWidth js-lineWidth" data-style="4"></span>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('1365', 'Линия') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-colorSelector" data-option="lineColor" style="background-color: {{: chartOptions.lineColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="lineColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="lineColor" data-element="canvas" value="{{: chartOptions.lineColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="uk-width-3-4">' +
                    _t('13662', 'Толщина линии') +
                '</div>' +
                '<div class="uk-width-1-4">' +
                    '<div class="js-widthSlector" data-option="lineWidth">' +
                        '<div class="js-widthSlectorValue lineWidth" data-option="lineWidth" data-style="{{: chartOptions.lineWidth }}"></div>' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-widthSlectorWrapper" data-option="lineWidth" value="{{: chartOptions.lineWidth }}">' +
                                '<span class="lineWidth js-lineWidth" data-style="1"></span>' +
                                '<span class="lineWidth js-lineWidth" data-style="2"></span>' +
                                '<span class="lineWidth js-lineWidth" data-style="3"></span>' +
                                '<span class="lineWidth js-lineWidth" data-style="4"></span>' +
                                '<span class="lineWidth js-lineWidth" data-style="5"></span>' +
                                '<span class="lineWidth js-lineWidth" data-style="8"></span>' +
                                '<span class="lineWidth js-lineWidth" data-style="10"></span>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
            '</div>' +
        '</div>' +
    '</div>'
);

$.templates("iChart_intervalsTmpl", '' +
    '<div class="uk-margin-small-left js-iChartTools-intervals" style="display: inline-block">' +
        '{{for intervals}}' +
        '<a class="uk-button js-chart-interval" href="javascript:void(0);" onclick="return false;" data-value="{{:value}}">{{:name}}</a>' +
        '{{/for}}' +
    '</div>'
);

$.templates("iChart_textPopupSettingsTmpl", '' +
    '<div class="uk-margin-small-left js-iChartTools-textPopupSettings" style="display: none;">' +
        '<div style="">' +
            '<div class="uk-grid uk-grid-small">' +

                '<div class="uk-width-1-5">' +
                    '<div class="uk-form-select" data-uk-form-select>' +
                        '<span>' + _t('17600', 'Size') + '</span>' +
                        '<select name="fontSize">' +
                            '{{for options.sizes}}' +
                            '<option value="{{:value}}" {{if value == ~root.values.fontSize}} selected {{/if}}>{{:name}}</option>' +
                            '{{/for}}' +
                        '</select>' +
                    '</div>' +
                '</div>' +

                '<div class="uk-width-2-5">' +
                    '<div class="uk-form-select" data-uk-form-select>' +
                        '<span>' + _t('17601', 'Font') + '</span>' +
                        '<select name="fontFamaly">' +
                            '{{for options.fonts}}' +
                            '<option value="{{:value}}" {{if value == ~root.values.fontFamaly}} selected {{/if}}>{{:name}}</option>' +
                            '{{/for}}' +
                        '</select>' +
                    '</div>' +
                '</div>' +

                '<div class="uk-width-2-5">' +
                    '<div class="js-colorSelector" data-option="fontColor" style="background-color: {{: values.fontColor }}">' +
                        '<div class="menuHolder" style="display: none; padding: 10px;">' +
                            '<div class="js-colorPalette" data-option="backgroundColor"></div>' +
                            '<input type="hidden" class="js-colorPicker" data-opacity="1.0" data-option="fontColor" data-element="canvas" value="{{: values.fontColor }}" size="10"/>' +
                        '</div>' +
                    '</div>' +
                '</div>' +

                '<div class="uk-width-1-1">' +
                    '<textarea name="text" style="width: 100%; height: 150px;">{{:values.text}}</textarea>' +
                '</div>' +

                '<div class="uk-width-1-1 uk-text-right">' +
                    '<button class="uk-button  uk-button-primary js-textPopupSettings" data-value="ok">' + _t('3920', "OK") + '</button>' +
                    '<button class="uk-button js-textPopupSettings" data-value="cancel">' + _t('1403', 'Отмена') + '</button> ' +
                '</div>' +
            '</div>' +
        '</div>' +
    '</div>'
);


var iChartDataSource = {
    data: {},

    dataSettings: {
        useHash: false,
        date_from: formatDate(-90),
        date_to: formatDate(0),
        graphicIndicators: '',
        timeframe: 1440,
        hash: '',
        id: "AAPL.US",
        interval: "D1",

        compareIds: "",
        compareStocks: "",
        compareTickets: "",
        start: '',
        end: '',
    },

    host: "",
    url: "/api/get-hloc?",

    getUrl: function (params) {
        var cachedParams = {
            'id': params.id,
            'compareIds': params.compareIds,
            'compareStocks': params.compareStocks,
            'compareTickets': params.compareTickets,
            'count': params.count,
            'timeframe': iChart.getChartTimeframe(params.interval),
            'date_from': params.date_from,
            'date_to': params.date_to,
            'interval': params.interval,
            'intervalMode': params.intervalMode,
            'type': params.type,
            'demo': params.demo
        };

        //Спецальная метка для nginx по которой он будет пытаться взять hloc из файла а не с сервера
        cachedParams['hash'] = cachedParams.id.toString() + Date.parse(cachedParams.date_from).toString() + Date.parse(cachedParams.date_to).toString() + JSON.stringify(cachedParams).hashCode();

        return iChartDataSource.host + iChartDataSource.url + iChart.toQueryString(cachedParams);
    },

    onRequestCallback: function (callback, params) {
        if (!params.id) {
            return 0
        }
        params.demo = typeof jNTUserinfo !== "undefined" && jNTUserinfo.isDemo ? 1 : 0;
        var $params = params;
        var _this = this;
        var _chart = this.chart;
        this.chart.wrapper.trigger("iguanaChartEvents", ["chartDataRequest", iChartDataSource.getUrl(params)]);
        this.chart.ajaxDataRequest = $.ajax({
            dataType: "text json", error: function (xhr, textStatus, errorThrown) {
                clearTimeout(_chart.timers.loading);
                _chart.wrapper.trigger("iguanaChartEvents", ["clearLoader"]);
                _chart.viewData.chart.setSelectionMode("pan");
                console.log("Error: " + textStatus);
                callback({success: false})
            }, success: function (data, textStatus, xhr) {
                _chart.wrapper.trigger("iguanaChartEvents", ["chartDataReceived", data]);
                if (data.info && data.info[_chart.dataSource.dataSettings.id]) {
                    var stockInfo = data.info[_chart.dataSource.dataSettings.id];
                    _chart.userSettings.currentSecurity = {
                        id: stockInfo.nt_ticker,
                        short_name: stockInfo.short_name,
                        default_ticker: stockInfo.default_ticker,
                        nt_ticker: stockInfo.nt_ticker,
                        firstDate: stockInfo.firstDate,
                        currency: stockInfo.currency,
                        min_step: stockInfo.min_step
                    };
                    _chart.viewData.chart.chartOptions.watermarkText = stockInfo.nt_ticker;
                    _chart.viewData.chart.chartOptions.watermarkSubText = stockInfo.short_name;
                    data = _this.dataAdapter(data, $params);
                    clearTimeout(_chart.timers.loading);
                    _chart.wrapper.trigger("iguanaChartEvents", ["clearLoader"]);
                    _chart.viewData.chart.setSelectionMode("pan");
                    if (data.success == false) {
                        console.log("ERROR:", data.d.Message)
                    }
                    if (data) {
                        callback(data)
                    } else {
                        callback({warnings: [_t("2125", "Ошибка: пустой ответ.")], success: false})
                    }
                    _chart.response = data.d;
                    _chart.wrapper.trigger("iguanaChartEvents", ["chartDataReady", data]);
                    _chart.dataRequestCounter++;
                    _chart.fixViewport();
                    _chart.updateUnlocked = true
                } else {
                    data.hloc = {};
                    data = _this.dataAdapter(data, $params);
                    clearTimeout(_chart.timers.loading);
                    _chart.wrapper.trigger("iguanaChartEvents", ["clearLoader"]);
                    _chart.viewData.chart.setSelectionMode("pan");
                    if (data.success == false) {
                        console.log("ERROR:", data.d.Message)
                    }
                    if (data) {
                        callback(data)
                    } else {
                        callback({warnings: [_t("2125", "Ошибка: пустой ответ.")], success: false})
                    }
                    _chart.response = data.d;
                    _chart.dataRequestCounter++;

                    _chart.userSettings.currentSecurity.firstDate = _chart.getDefaultDateFrom(_chart.viewData.chart._dataSettings.interval, false);
                    _chart.viewData.chart._dataSettings.date_from = _chart.getDefaultDateFrom(_chart.viewData.chart._dataSettings.interval, true);

                    _chart.setDatePeriod(_chart.viewData.chart._dataSettings.interval,
                        _chart.viewData.chart._dataSettings.date_from,
                        _chart.viewData.chart._dataSettings.date_to);

                    _chart.checkPeriodInterval(_chart.viewData.chart._dataSettings.interval);
                    _chart.checkDateInterval(_chart.viewData.chart._dataSettings.date_from, _chart.viewData.chart._dataSettings.date_to);
                    _chart.updateUnlocked = true
                    _chart.fixViewport();
                    _chart.errorMessages();

                }
            }, url: iChartDataSource.getUrl(params)
        })
    },
    preInitCallback: function(initReadyCallback, params) {
        var _this = this;
        if(typeof params === "undefined") {
            params = {};
        }
        params.ticker = params.ticker || this.chart.dataSource.dataSettings.id  || 'SBER';
        params.f_history = typeof params.f_history === "undefined" ? 0 : params.f_history;

        this.chart.userSettings = $.extend(true, {}, $iguanaChart.defaultSettings, params.userSettings);


        if(params.hash) {
            this.chart.dataSource.dataSettings.hash = params.hash;
            var hash = iChart.parseQueryString(params.hash.substr(1));
            for (var key in this.chart.dataSource.dataSettings) {
                if (hash[key]) {
                    this.chart.dataSource.dataSettings[key] = hash[key];
                }
            }
            var graphicIndicators = [];
            for (var paramKey in hash)
            {
                if (paramKey.match(new RegExp("^i[0-9]", "i")))
                {
                    var name = paramKey.charAt(0) + paramKey.substr(1);
                    graphicIndicators[name] = hash[paramKey];
                }
            }

            if(graphicIndicators.length) {
                this.chart.dataSource.dataSettings.graphicIndicators = iChart.toQueryString(graphicIndicators);
            }

            params.ticker = hash.id;
            params.interval = hash.interval;
        }

        _this.chart.userSettings.currentSecurity = {
            id: params.ticker,
            short_name: params.ticker,
            default_ticker: params.ticker,
            nt_ticker: params.ticker,
            firstDate: '',
            currency: '',
            min_step: ''
        };
        _this.chart.dataSource.dataSettings.useHash = false;
        _this.chart.dataSource.dataSettings.id = params.ticker;
        _this.chart.dataSource.dataSettings.intervalRestriction = "";

        params.chartOptions.watermarkText = params.ticker;
        params.chartOptions.watermarkSubText = params.ticker;

        if(typeof params.type != "undefined") {
            params.chartOptions.chartType = params.type;
        }

        initReadyCallback(params.chartOptions);

    }
};

IguanaChart = function (options) {

    "use strict";

    var _this = this;

    this.name = options.name || 'chart';

    this.container = options.container || '#iChart-chart-container';

    this.wrapper = options.wrapper;

    this.lib_path = options.lib_path || "/iguanachart/";

    this.toQueryString = function (params)
    {
        ///	<summary>
        ///	Converts the specified associative array to HTTP query string (starting '?' is omitted).
        ///	</summary>
        ///	<returns type="String" />

        var paramStrings = [];
        for (var key in params)
        {
            var value = params[key];
            if (typeof value === "undefined" || value === "")
            {
                continue;
            }

            if ($.isArray(value))
            {
                for (var i = 0; i < value.length; ++i)
                {
                    paramStrings.push(encodeURIComponent(key) + "=" + encodeURIComponent(value[i]));
                }
            }
            else
            {
                paramStrings.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
            }
        }

        return paramStrings.join("&");
    };

    this.dataSource = new iChart.Charting.ChartDataSource(this, options.dataSource);

    this.userSettings = {
        chartSettings: {
            contextSettings: {
                fillStyle: 'rgba(82,175,201,.2)',
                strokeStyle: 'rgba(82,175,201,1)',
                lineWidth: 1,
                fontFamaly: 'Arial,Helvetica,sans-serif',
                fontColor: '#444444',
                fontSize: '14'
            },
            indicatorsColor: {},
            indicatorsWidth: {},

            showTransactionsMode: 0,
            tradingToolsEnable: 1,
            autochartistEnable: 0,
            showVolume: "inside",
            showVolumeByPrice: false,
            defaultTheme: 1
        },
        currentSecurity: {
            id: '',
            short_name: '',
            default_ticker: '',
            nt_ticker: '',
            firstDate: '',
            currency: '',
            min_step: ''
        }
    };

    this.viewData = {};
    this.viewData.indicators = iChart.indicators;

    this.timers = {};
    this.ajaxDataRequest = null;
    this.orders = {};
    this.userTransactionAmount = -1;
    this.updateUnlocked = true;

    this.initChart = function (settings)
    {
        /// <summary>
        /// Initializes the chart.
        /// </summary>

        this.uiGraphIndicatorsWindow2 = {element : $(this.wrapper).find(".js-chartTADialog." + this.name)};

        this.loadHash();

        if(typeof settings != "object") {
            settings = {};
        }

        this.settings = {};
        this.settings.paddingBottom      = typeof settings.paddingBottom != "undefined" ? settings.paddingBottom : 50;

        if(typeof this.viewData.chart == "undefined") {

            var chartOptions = {

                onPostRender: function () {
                    _this.checkDateInterval(new Date(this.areas[0].xSeries[this.areas[0].viewport.x.bounded.min] * 1000), new Date(this.areas[0].xSeries[this.areas[0].viewport.x.bounded.max] * 1000));
                    $('#chartLoading').remove();
                    _this.wrapper.trigger('iguanaChartEvents', ['RenderChartSuccess']);
                },
                onCreateAreas: this.chart_onCreateAreas,
                onDataSettingsChange: this.chart_onDataSettingsChange,
                onIntervalChange: this.chart_onIntervalChange,
                contextmenuCallback: settings.contextmenuCallback,

                "container": $(this.container).get(0),

                "dataSettings": this.getChartDataUserSettings(),

                "widget": settings.widget,
                "env": this
            };

            chartOptions = $.extend(true, chartOptions, settings);

            this.viewData.chart = new iChart.Charting.Chart(chartOptions);
            this.TA = new iChart.Charting.TA({chart: this.viewData.chart});
            this.viewData.chart.setDataSettings(this.dataSource.dataSettings);
            this.ui = new iChart.ui(this);
            this.dataRequestCounter = 0;
        } else {
            this.viewData.chart.chartOptions = $.extend(true, this.viewData.chart.chartOptions, settings);
            this.viewData.chart.overlay.deserialize(iChart.parseQueryString((this.dataSource.dataSettings.hash|| "#").substr(1)));
            this.viewData.chart.setDataSettings(this.getChartDataUserSettings());
            this.dataRequestCounter = 0;
        }

        this.ui.render();

        $(window).off('mousemove').on('mousemove', function(e){
            $(window).data('mousePosX', e.pageX);
            $(window).data('mousePosY', e.pageY);
        });

    };

    this.chart_dataAdapter = function (data, params) {
        var chartData = {
            "d": {
                "xSeries": [],
                "ySeries": [],
                "success": true,
                "warnings": [],
                "message": ''
            }
        };

        var hloc = {
            "chartType": "Column",
            "enabled": true,
            "formatProvider": {
                "decimalPlaces": "2",
                "decimalPrecision": null
            },
            "indicatorIndex": null,
            "indicatorIndex2": null,
            "kind": "HLOC",
            "name": params.id,
            "overlay": false,
            "points": [],
            "valuesPerPoint": 4
        };

        var volume = {
            "chartType": "Column",
            "enabled": true,
            "formatProvider": {
                "decimalPlaces": null,
                "decimalPrecision": null
            },
            "indicatorIndex": null,
            "indicatorIndex2": null,
            "kind": "Volume",
            "name": params.id + " - V",
            "overlay": false,
            "points": [],
            "valuesPerPoint": 1
        };

        if(data.hloc) {
            var tickers = Object.keys(data.hloc);

            if(tickers.length == 1) {
                chartData.d.ySeries[0] = $.extend(true,{},hloc);
                chartData.d.ySeries[1] = $.extend(true,{},volume);
                chartData.d.ySeries[0].name = tickers[0];

                for (var i = 0; i < data.xSeries[tickers[0]].length; i++) {
                    //chartData.d.xSeries.push(+(data.xSeries[tickers[0]][i]));
                    chartData.d.xSeries.push(+(data.xSeries[tickers[0]][i]) + getTimeOffsetServer(tzOffsetMoscow));
                    chartData.d.ySeries[0].points.push(data.hloc[tickers[0]][i]);
                    chartData.d.ySeries[1].points.push([data.vl[tickers[0]][i]]);
                }

            } else if (tickers.length > 1) {
                // При сравнении нескольких бумаг
                //Нормализация по времени
                var x = {}
                for (var j = 0; j < tickers.length; j++) {
                    for (var i = 0; i < data.xSeries[tickers[j]].length; i++) {
                        if(typeof x[data.xSeries[tickers[j]][i]] == "undefined") {
                            x[data.xSeries[tickers[j]][i]] = {}
                        }
                        x[data.xSeries[tickers[j]][i]][tickers[j]] = data.hloc[tickers[j]][i];
                    }
                }

                for (var j = 0; j < tickers.length; j++) {
                    chartData.d.ySeries[j] = $.extend(true,{},hloc);
                    chartData.d.ySeries[j].name = tickers[j];
                }
                //Распределение котировок
                for(var tmstmp in x) {
                    chartData.d.xSeries.push(+(tmstmp) + getTimeOffsetServer(tzOffsetMoscow));

                    for (var j = 0; j < tickers.length; j++) {
                        if(typeof x[tmstmp][tickers[j]] == "undefined") {
                            chartData.d.ySeries[j].points.push([null, null, null, null]);
                        } else {
                            chartData.d.ySeries[j].points.push(x[tmstmp][tickers[j]]);
                        }
                    }
                }
            }
        }
        return chartData;
    };

    this.chart_onCreateAreas = function () {};

    this.chart_onDataSettingsChange = function (bySchedule)
    {
        /// <summary>
        /// Called when the chart data settings change.
        /// </summary>

        var documentHash = _this.dataSource.dataSettings.useHash == false ? (_this.dataSource.dataSettings.hash || '#') : document.location.hash;
        var params = iChart.parseQueryString(documentHash.substr(1));
        var drawParams = _this.getDrawParams(params);

        delete _this.viewData.chart._dataSettings.hash;
        var hash = "#" + iChart.toQueryString($.extend(_this.viewData.chart._dataSettings, drawParams));

        _this.viewData.hash = hash;
        if(_this.dataSource.dataSettings.useHash == false) {
            if(_this.dataSource.dataSettings.hash != hash) {
                _this.dataSource.dataSettings.hash = hash;
                $(this.container).trigger('iguanaChartEvents', ['hashChanged', hash]);
            }
        } else {
            if(document.location.hash != hash) {
                document.location.hash = hash;
                $(this.container).trigger('iguanaChartEvents', ['hashChanged', hash]);
            }
        }
    };

    /**
     *
     * @param params
     * @returns {{}}
     */
    this.getDrawParams = function (params) {
        var drawParams = {};

        for (var paramKey in params) {
            if (paramKey.match(/^L$/) || paramKey.match((/^L[0-9]{1,2}_/))) {
                drawParams[paramKey] = params[paramKey];
            }
        }

        return drawParams;
    };

    this.chart_onIntervalChange = function (chart)
    {
        /// <summary>
        /// Called when the date/time interval of the visible viewport changes.
        /// </summary>
        if(_this.viewData.chart) {
            _this.viewData.chart.updateVolumeByPrice();
        }
    };

    this.toggleVolumeByPrice_onClick = function ()
    {
        this.viewData.chart.chartOptions.showVolumeByPrice = !this.viewData.chart.chartOptions.showVolumeByPrice;

        if (this.viewData.chart && this.viewData.chart.areas)
        {
            var volumeArea = $.grep(this.viewData.chart.areas, function (x) { return x.name === "ChartArea2"; })[0];
            if (volumeArea)
            {
                this.viewData.chart.updateVolumeByPrice();
                volumeArea.enabled = this.viewData.chart.chartOptions.showVolumeByPrice;
            }

            // Redraw the chart using new settings.
            this.viewData.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
        }
    };

    this.VolumeByPrice_onClick = function (state)
    {

        _this.viewData.chart.chartOptions.showVolumeByPrice = typeof state != "undefined" ? state : !_this.viewData.chart.chartOptions.showVolumeByPrice;

        if (_this.viewData.chart && _this.viewData.chart.areas)
        {
            var volumeArea = $.grep(_this.viewData.chart.areas, function (x) { return x.name === "VolumeByPriceArea"; })[0];
            if (volumeArea)
            {
                _this.viewData.chart.updateVolumeByPrice();
            }
            // Redraw the chart using new settings.
            _this.viewData.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
        }
    };

    this.VolumeByDate_onClick = function (state)
    {
        if(state === true || state === false) {
            _this.viewData.chart.chartOptions.showVolume = state ? "inside" : "hidden";
        } else {
            _this.viewData.chart.chartOptions.showVolume = (state == "inside" || state == "outside") ? state :
            _this.viewData.chart.chartOptions.showVolume === "inside" || _this.viewData.chart.chartOptions.showVolume === "outside" ? "hidden" : "inside";
        }

        if (_this.viewData.chart && _this.viewData.chart.areas)
        {
            var volumeArea = $.grep(_this.viewData.chart.areas, function (x) { return x.name === "ChartArea2"; })[0];
            if (volumeArea)
            {
                volumeArea.enabled = _this.viewData.chart.chartOptions.showVolume === "inside" || _this.viewData.chart.chartOptions.showVolume === "outside";
            }
            // Redraw the chart using new settings.
            _this.viewData.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
        }
    };

    /**********************************************************/
    this.apply_onClick = function () {
        _this.update();
    };
    this.chartType_onChange = function () {
        /// <summary>
        /// Called when selected chart type value changes.
        /// </summary>
        var chartType = $(this).val();
        if (_this.viewData.chart) {
            _this.viewData.chart.setChartType(chartType);
            _this.chartType_elementControl(chartType);
        }
        _this.setHashValue("type", chartType);
        _this.viewData.chart.setChartType(chartType);
    };

    this.chartType_elementControl = function (chartType) {
        $('div.chartType').removeClass('active');
        $('div.chartType div.isMenu').hide();
        $('div[value="'+chartType+'"]').addClass('active');
        $('div[value="'+chartType+'"] div.isMenu').show();
    };

    this.clearIndicators_onClick = function () {
        /// <summary>
        /// Removes all technical analysis indicators from the chart.
        /// </summary>
        for (var i = 0; i < 30; ++i) {
            $("[name='i" + i + "']").val("").trigger("change");
            _this.updateIndicatorDetails("i" + i, false);
        }
        if (_this.viewData.chart) {
            _this.viewData.chart.clearIndicators();
        }
    };

    this.getChartDataUserSettings = function () {
        /// <summary>
        /// Gets current chart parameters from the user settings.
        /// </summary>
        var params = {};
        params["id"] = this.dataSource.dataSettings.id;
        params.date_from = this.dataSource.dataSettings.date_from;
        params.date_to = this.dataSource.dataSettings.date_to;
        params.start = this.dataSource.dataSettings.date_from;
        params.end = this.dataSource.dataSettings.date_to;
        params.interval = this.dataSource.dataSettings.interval;
        params.timeframe = iChart.getChartTimeframe(this.dataSource.dataSettings.interval);
        params["type"] = this.dataSource.dataSettings.type;
        params["compareIds"] = this.dataSource.dataSettings.compareIds;
        params["compareTickets"] = this.dataSource.dataSettings.compareTickets;
        params["compareStocks"] = this.dataSource.dataSettings.compareStocks;
        //var p = $('[name=form_info_settings]').serializeArray();
        //for (var i = 0; i < p.length; i++) {
        //    params[p[i].name] = p[i].value;
        //}
        //$.extend(params, iChart.parseQueryString(localStorage.userSettingsGraphicIndicators));
        $.extend(params, iChart.parseQueryString(this.dataSource.dataSettings.graphicIndicators));
        return params;
    };

    this.getMinChartHeight = function ()
    {
        var container = $(this.container);
        if (container.length != 0) {
            return $(window).height() - container.offset().top - (this.settings && this.settings.paddingBottom ? this.settings.paddingBottom : 0);
        }
        return $(window).height();
    };

    this.indicator_onChange = function () {
        _this.updateIndicatorDetails($(this).attr('name').substr(1), {name: $(this).val()});
    };

    this.loadHash = function (bySchedule) {
        /// <summary>
        /// Updates form values based on the current page hash.
        /// </summary>
        var defaultIndicators = $("[name=graphicIndicators]").val();

        var hash = (this.dataSource.dataSettings.hash || ("#" + defaultIndicators) || "#&i0=SMA&i0_Period=10&i1=PSAR&i1_Acceleration=0.02&i1_Maximum=0.2");

        var params = iChart.parseQueryString(hash.substr(1));

        if(typeof this.viewData.chart !== 'undefined') {
            var graphicIndicators = iChart.parseQueryString(localStorage.userSettingsGraphicIndicators);
            if(typeof graphicIndicators == "object" && !$.isEmptyObject(graphicIndicators)) {
                $.extend(params, graphicIndicators);
            }
        }

        return params;
    };

    this.pan_onClick = function () {
        if (_this.viewData.chart) {
            _this.viewData.chart.pan($(this).attr("data-direction"));
        }
    };
    this.timeframe_onChange = function () {
        this.update();
    };
    this.removeSelectedInstrument_onClick = function () {
        if (_this.viewData.chart.overlay) {
            _this.viewData.chart.overlay.removeSelected();
        }
        return false;
    };
    this.removeAllInstruments_onClick = function () {
        if (_this.viewData.chart.overlay) {
            _this.viewData.chart.overlay.clear();
        }
        $(".m-chart-instrument-delete, .m-chart-instrument-settings").hide();
        return false;
    };
    this.resetZoom_onClick = function () {
        if (_this.viewData.chart) {
            _this.viewData.chart.resetZoom();
        }
    };
    this.update = function () {
        /// <summary>
        /// Forces a full chart data update.
        /// </summary>
        var dataSettings = this.getChartDataUserSettings();
        if (this.dataSource.dataSettings.useHash != false) {
            this.setHashValues(dataSettings);
        }
        if (this.viewData.chart) {
            this.viewData.chart.setDataSettings(dataSettings);
        }

    };
    this.updateForce = function () {
        var dataSettings = this.getChartDataUserSettings();
        if (this.dataSource.dataSettings.useHash != false) {
            this.setHashValues(dataSettings);
        }
        if (this.viewData.chart) {
            this.viewData.chart.setDataSettings(dataSettings, true);
        }
    };
    this.updateChart_onClick = function () {
        this.update();
    };

    this.removeIndicator_onClick = function () {
        $(this).parents('.js-chart-indiacator-block').remove();
    };

    this.addIndicator_onClick = function () {
        if(_this.uiGraphIndicatorsWindow2.element.is(':visible')) {
            var indicators = _this.deserializeIndicators(_this.uiGraphIndicatorsWindow2.element.find(':input').serialize(), false);
            _this.updateIndicatorDetails(indicators.length, '');
        }
    };

    this.serializeIndicators = function (indicators) {
        var query = '';
        for(var i=0; i<indicators.length; i++) {
            query += "i" + i + "=" + indicators[i].name + "&";

            if(indicators[i].params) {
                for(var paramKey in indicators[i].params) {
                    query += "i" + i + "_" + paramKey + "=" + indicators[i].params[paramKey] + "&";
                }
            }
        }
        return query;
    };

    this.deserializeIndicators = function (query, resetKey) {
        resetKey = typeof resetKey != "undefined" ? !!resetKey : true;
        var params = iChart.parseQueryString(query);
        var indicators = [];
        for (var paramKey in params)
        {
            if (paramKey === "fs" || paramKey.match(new RegExp("^i[0-9]+", "i")))
            {
                var regsIndParams = paramKey.match(new RegExp("^i([0-9])+_", "i"));
                var regsInd = paramKey.match(new RegExp("^i([0-9])+$", "i"));
                if (regsInd) {
                    if(!indicators[+regsInd[1]]) {
                        indicators[+regsInd[1]] = {};
                    }
                    indicators[+regsInd[1]].name = params[paramKey];
                } else if(regsIndParams) {
                    if(!indicators[+regsIndParams[1]]) {
                        indicators[+regsIndParams[1]] = {};
                    }
                    if(!indicators[+regsIndParams[1]].params) {
                        indicators[+regsIndParams[1]].params = {};
                    }
                    indicators[+regsIndParams[1]].params[paramKey.replace(/i[0-9]+_/i, '')] = +(params[paramKey]);
                }
            }
        }

        if(resetKey) {
            indicators = indicators.filter(function (n) {
                return n != undefined
            });
        }
        return indicators;
    };

    this.updateIndicatorDetails = function (id, indicator, updateChart) {

        updateChart = !!updateChart;

        var $root = this.uiGraphIndicatorsWindow2.element.find(".js-chartTADialog-i" + id + "-settings");

        if(!$root.length) {
            var indicatorOptions = '<option value="">'+  _t('14773', 'Выберите индикатор') +'</option>';

            for(var key in this.viewData.indicators) {
                if(this.viewData.indicators[key].type == "TA_LIB") {
                    indicatorOptions += '<option value="' + key + '" ' + ((key == indicator.name) ? 'selected' : '') + '>' + this.viewData.indicators[key].name + '</option>';
                }
            }

            var indForm =
            '<div style="border-bottom: 1px solid rgba(0, 0, 0, 0.12)" class="js-chart-indiacator-block tm-pad-large js-chartTADialog-i' + id + '-settings" id="iChart-i' + id + '-settings">' +
                '<div class="uk-panel">' +
                    '<div class="uk-flex uk-flex-middle uk-flex-space-between uk-margin-small-bottom">' +
                        '<div class="uk-h4">' + _t('12834','Индикатор') + ' ' + (id+1) + '</div>' +
                        '<div class="js-indicator-remove uk-icon-close uk-panel-hover uk-badge uk-button uk-button-mini"></div>' +
                    '</div>' +
                    '<div class="uk-form">' +
                        '<select name="i' + id + '" class="indicatorsSelect">' +
                        indicatorOptions +
                        '</select>' +
                    '</div>' +
                '</div>' +
            '</div>';

            this.uiGraphIndicatorsWindow2.element.find(".js-chartTADialogContainer").append(indForm);
            $root = this.uiGraphIndicatorsWindow2.element.find(".js-chartTADialog-i" + id + "-settings");
        }

        $(".iChart-indicator-description, .iChart-indicator-parameters, .iChart-indicator-colors, .iChart-indicator-width", $root).remove();

        var indicatorInfo = this.viewData.indicators[indicator.name] || {description:'',parameters:[]};

        $("<div/>", { "class":"iChart-indicator-description" }).html(indicatorInfo.description).appendTo($root);
        var indicatorParameters = indicatorInfo.parameters;

        for (var j = 0; j < indicatorParameters.length; ++j) {
            var parameterKey = "i" + id + "_" + indicatorParameters[j].Code;
            var $container = $("<div/>", { "class":"iChart-indicator-parameters uk-form", "text":indicatorParameters[j].Name + ": " }).appendTo($root);
            $("<input/>", { "name":parameterKey, "type":"text", "value":indicatorParameters[j].Value }).css({ "width":"50px" }).appendTo($container);
        }

        var $colorContainer = $("<div/>", {"class":"iChart-indicator-colors", "id":"iChart-indicator-colors"}).appendTo($root);
        var $widthContainer = $("<div/>", {"class":"iChart-indicator-width", "id":"iChart-indicator-width"}).appendTo($root);
        var colorIndex = id;

        if(this.viewData.indicators[indicator.name]) {
            for (var i = 0; i < this.viewData.indicators[indicator.name].output; i++) {
                if (typeof this.viewData.chart != 'undefined') {

                    var color = this.viewData.chart.chartOptions.indicatorColors[colorIndex][i];
                    if (this.userSettings.chartSettings.indicatorsColor[indicator.name] &&
                        this.userSettings.chartSettings.indicatorsColor[indicator.name][colorIndex] &&
                        this.userSettings.chartSettings.indicatorsColor[indicator.name][colorIndex][i]
                    ) {
                        color = this.userSettings.chartSettings.indicatorsColor[indicator.name][colorIndex][i];
                    }

                    $("<input/>", {
                            "type": "hidden",
                            "class": "iChart-indicator-color iChart-indicator-color-" + colorIndex + i,
                            "id": "iChart-indicator-color-" + colorIndex + i,
                            "indicator": indicator.name,
                            "colorIndex": colorIndex + "-" + i,
                            "ui-pos": (colorIndex < 2 ? "bottom" : "top")
                        }
                    ).val(color).appendTo($colorContainer);


                    this.initInsrMinicolors($(".iChart-indicator-color-" + colorIndex + i));

                    var width = 2;
                    if (this.userSettings.chartSettings.indicatorsWidth[indicator.name] &&
                        this.userSettings.chartSettings.indicatorsWidth[indicator.name][colorIndex] &&
                        this.userSettings.chartSettings.indicatorsWidth[indicator.name][colorIndex][i]) {
                        width = this.userSettings.chartSettings.indicatorsWidth[indicator.name][colorIndex][i];
                    }

                    var indicatorWidth = $('<span class="lineWidth indicatorWidthSelector-' + colorIndex + i + '" data-chartName="' + this.name + '" data-style="' + width + '"></span>').appendTo($widthContainer);
                    $('<div class="indicatorMenuHolder-' + colorIndex + i + '" data-chartName="' + this.name + '" style="display: none" widthIndex="' + colorIndex + "-" + i + '">' +
                        '<div widthIndex="' + colorIndex + "-" + i + '" indicator="' + indicator.name + '">' +
                        '<span class="lineWidth js-lineWidth ' + this.name + '" data-style="1"></span>' +
                        '<span class="lineWidth js-lineWidth ' + this.name + '" data-style="2"></span>' +
                        '<span class="lineWidth js-lineWidth ' + this.name + '" data-style="3"></span>' +
                        '<span class="lineWidth js-lineWidth ' + this.name + '" data-style="4"></span>' +
                        '<span class="lineWidth js-lineWidth ' + this.name + '" data-style="5"></span>' +
                        '<span class="lineWidth js-lineWidth ' + this.name + '" data-style="8"></span>' +
                        '<span class="lineWidth js-lineWidth ' + this.name + '" data-style="10"></span>' +
                        '</div>' +
                        '</div>').appendTo($widthContainer);
                    this.initIndicatorWidthMenu(indicatorWidth, $(".indicatorMenuHolder-" + colorIndex + i + "[data-chartName='" + this.name + "']").html());

                }
            }
        }

        if (updateChart) {
            this.update();
        }

    };

    this.setIndicators = function(graphicIndicators) {

        window.localStorage.setItem('userSettingsGraphicIndicators', graphicIndicators);
        this.dataSource.dataSettings.graphicIndicators = graphicIndicators;

        this.setScheduleUpdateState(0);
        this.TA.removeIndicator();
        if(typeof _this.TA != "undefined") {
            var indicators = iChart.parseQueryString(this.dataSource.dataSettings.graphicIndicators);
            $.each(indicators, function (n, i) {
                var params = {};
                if(i && n.match(/^i[0-9]+$/) && _this.viewData.indicators[i] && _this.viewData.indicators[i].type == "TA_LIB") {
                    var index = n.match(/^i([0-9]+)$/)[1];
                    for(var p = 0; p < _this.viewData.indicators[i].parameters.length; p++) {
                        var iParam = _this.viewData.indicators[i].parameters[p];
                        params[iParam.Code] = indicators[n + "_" + iParam.Code];
                    }
                    _this.TA[i](0, index);
                    _this.TA[i](1, index, params);
                }
            });
        }

        this.wrapper.trigger('iguanaChartEvents', ['hashChanged']);
        this.wrapper.trigger('iguanaChartEvents', ['indicatorsChanged', this.deserializeIndicators(this.dataSource.dataSettings.graphicIndicators)]);
        if(this.timers.updateInterval) {this.setScheduleUpdateState(1, this.timers.updateInterval)}

    };

    this.showIndicators = function (options) {
        options = options || {};
        //$("#iChart-tech-analysis-dialog").show();
        this.timers.updateInterval = this.viewData.chart.chartOptions.updateInterval;
        this.setScheduleUpdateState(0);

        var indicators = this.deserializeIndicators(this.dataSource.dataSettings.graphicIndicators);

        this.uiGraphIndicatorsWindow2.element.find(".js-chartTADialogContainer").empty();

        for(var i=0; i<indicators.length; i++) {
            this.updateIndicatorDetails(i, indicators[i], false);

            for (var paramKey in indicators[i].params)
            {
                var name = "i" + i + "_" + paramKey;
                this.uiGraphIndicatorsWindow2.element.find("[name='" + name + "']").val(indicators[i].params[paramKey]);
            }
        }

        if(!options.forAll) {
            this.uiGraphIndicatorsWindow2.element.find('.indicators-default').hide();
        }

        if(!this.uiGraphIndicatorsWindow2.UIkit) {

            $(this.wrapper).find(".js-chartTADialog." + this.name).appendTo('body');
            this.uiGraphIndicatorsWindow2 = UIkit.modal($(".js-chartTADialog." + this.name));

        }

        this.uiGraphIndicatorsWindow2.show();

        $(".indicators-set").off("click");
        $(".indicators-close").off("click");
        $(".indicators-set").on('click', function () {
            window.localStorage.setItem('userSettingsIndicatorsColor', JSON.stringify(_this.userSettings.chartSettings.indicatorsColor));
            window.localStorage.setItem('userSettingsIndicatorsWidth', JSON.stringify(_this.userSettings.chartSettings.indicatorsWidth));

            var indicators = _this.deserializeIndicators(
                _this.uiGraphIndicatorsWindow2.element.find(':input').serialize());
            var newParams = _this.uiGraphIndicatorsWindow2.element.find(':input').serializeArray();
            var validParams = true;
            var index = 0;
            newParams.forEach(function (param) {
                var fixParamForCheck = param;
                if (param.name.search('_') !== -1) {
                    var paramSplit = param.name.split('_');
                    fixParamForCheck.name = paramSplit[1];
                    index = paramSplit[0].split(/\D/).join('');
                }
                if (!_this.ui.checkValidParameters(fixParamForCheck, iChart.indicators[indicators[index].name])) {
                    validParams = false;
                }
                else {
                    indicators[index].params[param.name] = param.value;
                }
            });
            if (!validParams) {
                return false;
            }

            indicators = _this.serializeIndicators(indicators);
            _this.setIndicators(indicators);
            _this.uiGraphIndicatorsWindow2.hide();
            return false;
        });
        $(".indicators-close").on('click', function () {
            _this.uiGraphIndicatorsWindow2.hide();
            if(_this.timers.updateInterval) {_this.setScheduleUpdateState(1, _this.timers.updateInterval)}
            return false;
        });
    };

    this.window_onHashChange = function () {
        if (typeof _this == 'undefined') return;

        if(_this.dataSource.dataSettings.useHash == false) {
            var hash = _this.dataSource.dataSettings.hash;
        } else {
            var hash = document.location.hash;
        }
        if (decodeURIComponent(hash) !== decodeURIComponent(_this.viewData.hash)) {
            _this.loadHash();
            _this.update();

            if (typeof _this.viewData.chart == 'undefined') return;
            if (_this.viewData.chart.overlay) {
                _this.viewData.chart.overlay.update();
            }
        }
    };

    this.zoom_onClick = function () {
        if (_this.viewData.chart) {
            _this.viewData.chart.zoom($(this).attr("data-zoom"));
        }
    };

    this.percentMode_onClick = function () {
        if(_this.viewData.chart.chartOptions.percentMode) {
            $('#percentMode').removeClass('active');
        } else {
            $('#percentMode').addClass('active');
        }
        _this.viewData.chart.chartOptions.percentMode = !_this.viewData.chart.chartOptions.percentMode;
        _this.updateForce();
        return _this.viewData.chart.chartOptions.percentMode;
    };

    this.iconsLoad = function () {
        $(["/i/admin/add.png",
            "/iguanachart/images/buy.png",
            "/iguanachart/images/down.png",
            "/iguanachart/images/icon-exclamation.png",
            "/iguanachart/images/icon-left.png",
            "/iguanachart/images/icon-leftDown.png",
            "/iguanachart/images/icon-leftUp.png",
            "/iguanachart/images/icon-question.png",
            "/iguanachart/images/icon-right.png",
            "/iguanachart/images/icon-rightDown.png",
            "/iguanachart/images/icon-rightUp.png",
            "/iguanachart/images/icon-sell.png",
            "/iguanachart/images/icon-smileDown.png",
            "/iguanachart/images/icon-smileUp.png",
            "/iguanachart/images/icon-up.png",
            "/i/logo_tradernet_min.png"]).preload();
    };
    this.drawLables = function (legend, context, x, y) {
        x = (typeof x == "undefined") ? 0 : x;
        y = (typeof y == "undefined") ? 0 : y;
        //var cl = $('.m-chart-t').eq(2).clone();
        var cl = $(legend).clone();
        $(cl).children('span').remove();
        var values = $(cl).html().split(/ &nbsp; /);
        var txtWidth = x;
        var str = '';
        str = values[0].replace(/&nbsp;/g, '');
        context.font = 'normal 9px Arial,Helvetica,sans-serif';
        context.fillStyle = '#636669';
        context.fillText(str, txtWidth, y);
        txtWidth += context.measureText(str).width + 10;
        $(legend).children('span:odd').each(function (i, obj) {
            str = $(obj).text();
            context.font = 'bold 9px Arial,Helvetica,sans-serif';
            context.fillStyle = $(obj).css('color');
            context.fillText(str, txtWidth, y);
            txtWidth += context.measureText(str).width;
            str = values[i + 1].replace(/&nbsp;/g, '');
            context.font = 'normal 9px Arial,Helvetica,sans-serif';
            context.fillStyle = '#636669';
            context.fillText(str, txtWidth, y);
            txtWidth += context.measureText(str).width + 10;
        });
    };

    this.setMousewheelZoomState = function (turnOn) {
        if(turnOn) {
            this.viewData.chart.chartOptions.mousewheelZoom = true;
        } else {
            this.viewData.chart.chartOptions.mousewheelZoom = false;
        }
    }

    this.setScheduleUpdateState = function (turnOn) {
        if(turnOn) {
            this.viewData.chart.chartOptions.updateInterval = true;
            this.viewData.chart.scheduleUpdate();
        } else {
            this.viewData.chart.chartOptions.updateInterval = false;
            this.viewData.chart.scheduleUpdate();
        }
    }

    this.scrollBack = function () {
        this.viewData.chart.viewport.x.min = this.viewData.chart.areas[0].viewport.x.min;
        this.viewData.chart.viewport.x.max = this.viewData.chart.areas[0].viewport.x.max;

        var length = this.viewData.chart.viewport.x.max - this.viewData.chart.viewport.x.min;
        var min = this.viewData.chart.viewport.x.min;
        var duration = 1500 + min;
        $('<p>').animate({
            width: min
        }, {
            duration: duration,
            step: function(now, fx){
                _this.viewData.chart.viewport.x.min = min - now;
                _this.viewData.chart.viewport.x.max = _this.viewData.chart.viewport.x.min + length;
                _this.viewData.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": true });
            }
        });
    }

    this.scrollForward = function () {
        this.viewData.chart.viewport.x.min = this.viewData.chart.areas[0].viewport.x.min;
        this.viewData.chart.viewport.x.max = this.viewData.chart.areas[0].viewport.x.max;

        var length = this.viewData.chart.viewport.x.max - this.viewData.chart.viewport.x.min;
        var max = this.viewData.chart.areas[0].xSeries.length-1-this.viewData.chart.chartOptions.futureAmount;
        var p  = $('<p>').css({width: this.viewData.chart.viewport.x.max});
        var duration = 1500 + (max - this.viewData.chart.viewport.x.max);

        p.animate({
            width: max
        }, {
            duration: duration,
            step: function(now, fx){
                _this.viewData.chart.viewport.x.max = now;
                _this.viewData.chart.viewport.x.min = now - length;
                _this.viewData.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": true });
            },
            complete: function() {
                _this.viewData.chart.onDataSettingsChange.call(_this.viewData.chart);
                _this.wrapper.trigger('iguanaChartEvents', ['hashChanged']);
            }
        });
    };

    this.scrollTo = function (selection) {

        var xSpeed = selection.xSpeed;

        if(xSpeed < 0.05) {
            return false;
        }

        var t = 1000 + xSpeed * 100;
        var V0 = xSpeed;
        var a = -V0 / t;

        var _this = this;
        var startViewportXMin =  this.viewData.chart.viewport.x.min;
        var startViewportXMax =  this.viewData.chart.viewport.x.max;

        iChart.animate({
            duration: t,
            timing: function (timeFraction) {
                return timeFraction;
            },
            draw: function (progress) {

                if( !isNaN(progress) && progress > 0) {
                    var ms = t * progress;

                    var V1 = V0 + a * ms;
                    var scrollX1 = (V0 * ms) + ((a * ms * ms) / 2);

                    var viewportDx = _this.viewData.chart.areas[0].getXIndexByValue(_this.viewData.chart.areas[0].getXValue(_this.viewData.chart.areas[0].getXPositionByIndex(0) + scrollX1));

                    if (selection.x1 > selection.x2) {
                        _this.viewData.chart.viewport.x.min = startViewportXMin + viewportDx;
                        _this.viewData.chart.viewport.x.max = startViewportXMax + viewportDx;
                    } else if (selection.x1 < selection.x2) {
                        _this.viewData.chart.viewport.x.min = startViewportXMin - viewportDx;
                        _this.viewData.chart.viewport.x.max = startViewportXMax - viewportDx;
                    }

                    _this.viewData.chart._fixViewportBounds();
                    _this.viewData.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": true});

                }
            },
            complete: function () {
                _this.viewData.chart.loadMissingData();
            }
        });
    };

    this.updateLastCandle = function (data) {
        if(!data) { return;}
        var element = data;
        if(typeof this.viewData.chart != "undefined" && !!this.viewData.chart.areas && this.viewData.chart.canvas && !!this.viewData.chart.chartOptions.updateInterval && element.ltp) {
            var chartDate = new Date(this.viewData.chart.areas[0].xSeries[this.viewData.chart.areas[0].xSeries.length-this.viewData.chart.chartOptions.futureAmount-1]*1000);
            var currentDate = new Date(data.ltt);
            if(currentDate.getTime() >= chartDate.getTime() && currentDate.getTime() < (chartDate.getTime() + this.viewData.chart._dataSettings.timeframe * 60000)) {
                var point = this.viewData.chart.areas[0].ySeries[0].points[this.viewData.chart.areas[0].ySeries[0].points.length-this.viewData.chart.chartOptions.futureAmount-1];
                point[3] = element.ltp;
                point[0] = Math.max(point[0], point[3]);
                point[1] = Math.min(point[1], point[3]);
                point[4] = element.bap;
                point[5] = element.bbp;

                var context = iChart.getContext(this.viewData.chart.canvas);
                this.viewData.chart.render({ "context": context, "forceRecalc": false, "resetViewport": false, "testForIntervalChange": false });
            } else if(currentDate.getTime() > (chartDate.getTime() + this.viewData.chart._dataSettings.timeframe * 60000)) {

                var point = this.getLastPoint();
                var newPoint = {
                    "hloc": {},
                    "vl": {},
                    "xSeries" : {}
                };

                var hloc = [];
                hloc[0] = element.ltp;
                hloc[1] = element.ltp;
                hloc[2] = element.ltp;
                hloc[3] = element.ltp;

                newPoint["hloc"][Object.keys(point.xSeries)[0]] = [hloc];
                newPoint["vl"][Object.keys(point.xSeries)[0]] = [element.vol];

                var tm = ((currentDate.getTime() - currentDate.getTime() % (this.viewData.chart._dataSettings.timeframe * 60000)) / 1000) - getTimeOffsetServer(tzOffsetMoscow);
                newPoint["xSeries"][Object.keys(point.xSeries)[0]] = [tm];

                this.addPoint(newPoint);
            }
        }
    };

    this.getLastPoint = function () {
        if(typeof this.viewData.chart != "undefined" && !!this.viewData.chart.areas && this.viewData.chart.canvas) {
            var _this = this;
            var lastPointIndex = this.viewData.chart.areas[0].ySeries[0].points.length-this.viewData.chart.chartOptions.futureAmount-1;
            var name = this.viewData.chart.areas[0].ySeries[0].name;

            var hloc = {},
                vl = {},
                xSeries = {};

            xSeries[name] = [this.viewData.chart.areas[0].xSeries[lastPointIndex]];

            $.each(this.viewData.chart.areas, function(i,area){
                $.each(area.ySeries, function(j,series){
                    if($.inArray(series.kind, ['HLOC', 'Volume']) >= 0) {
                        if(series.kind == 'HLOC') {
                            hloc[name] = [series.points[lastPointIndex]];
                        }
                        if(series.kind == 'Volume') {
                            vl[name] = [series.points[lastPointIndex]];
                        }
                    }
                });
            });

            var result = {
                "hloc": hloc,
                "vl": vl,
                "xSeries": xSeries
            };

            return result;
        }
    };

    this.getLastPointX = function () {
        if(typeof this.viewData.chart != "undefined" && !!this.viewData.chart.areas && this.viewData.chart.canvas) {
            var lastPointIndex = this.viewData.chart.areas[0].ySeries[0].points.length-this.viewData.chart.chartOptions.futureAmount-1;
            return this.viewData.chart.areas[0].xSeries[lastPointIndex];
        }
        return false;
    };

    this.addTransactions = function (data, mode) {
        if(typeof this.viewData.chart != "undefined") {
            DataLoop:
                for(var i=0; i < data.length; i++) {
                    var overlayHistory = this.viewData.chart.overlay.history;
                    for(var j=0; j < overlayHistory.length; j++) {
                        var element = overlayHistory[j];
                        if(element.elementType == "Trade" && element.id == data[i].id) {
                            continue  DataLoop;
                        }
                    }

                    var element = this.viewData.chart.overlay.createElement("Trade");
                    element.hasSettings = true;
                    element.settings = data[i];
                    element.settings.mode = mode;
                    element.points = [{'x':new Date(data[i].date_time).getTime(), 'y':data[i].price}];
                    element.id = data[i].id;
                    this.viewData.chart.overlay.history.push(element);
                    this.userTransactionAmount++;
                }
            this.viewData.chart.overlay.render();
        }
    };

    this.removeTransactions = function () {
        if(typeof this.viewData.chart != "undefined") {
            var overlayHistory = this.viewData.chart.overlay.history;
            for(var i=0; i < overlayHistory.length; i++) {
                var element = overlayHistory[i];
                if(element.elementType == "Trade") {
                    overlayHistory.splice(i, 1);
                    i--;
                }
            }
            this.userTransactionAmount = -1;
            this.viewData.chart.overlay.render();
        }
    }

    this.setButton = function (data) {
        if(typeof this.viewData.chart != "undefined") {
            var element = this.viewData.chart.overlay.createElement("Button");
            element.hasSettings = true;
            element.setSettings(data);
            element.points = [{'x':data.point, 'y':data.price}];
            //element.id = data[i].id;
            this.viewData.chart.overlay.history.push(element);
            //this.viewData.chart.overlay.render();
        }


    };

    this.updateNewOrderButton = function () {
        var lastPoint = this.viewData.chart.areas[0].getXPositionByIndex(this.viewData.chart.areas[0].xSeries.length-1-this.viewData.chart.chartOptions.futureAmount) + 50;
        lastPoint = Math.min(lastPoint, this.viewData.chart.areas[0].getXPositionByIndex(this.viewData.chart.areas[0].xSeries.length-1));
        var pointX = this.viewData.chart.areas[0].getXValue(lastPoint)*1000;
        var point = this.viewData.chart.areas[0].ySeries[0].points[this.viewData.chart.areas[0].ySeries[0].points.length-this.viewData.chart.chartOptions.futureAmount-1];

        var element = this.getNewOrderButton();
        if(element) {
            element.points[0].x = pointX;
            element.points[0].y = point[3];
        } else {
            var click = function () {
                var point = _this.viewData.chart.areas[0].ySeries[0].points[_this.viewData.chart.areas[0].ySeries[0].points.length-_this.viewData.chart.chartOptions.futureAmount-1];
                var callback = function(){
                    _this.addVisualTradeUI();
                };
                jNTChartTrading.show(_this.userSettings.currentSecurity.nt_ticker, 2, iChart.roundToPrecision(point[3], _this.userSettings.currentSecurity.min_step), null, null, callback);
                _this.removeNewOrderButton();
            }
            this.setButton({point: pointX, price: point[3], click: click});
        }

    }

    this.getNewOrderButton = function () {
        if(typeof this.viewData.chart != "undefined") {
            var overlayHistory = this.viewData.chart.overlay.history;
            for(var i=0; i < overlayHistory.length; i++) {
                var element = overlayHistory[i];
                if(element.elementType == "Button") {
                    return element;
                }
            }
        }
        return false;
    };

    this.removeNewOrderButton = function () {
        if(typeof this.viewData.chart != "undefined") {
            var overlayHistory = this.viewData.chart.overlay.history;
            for(var i=0; i < overlayHistory.length; i++) {
                var element = overlayHistory[i];
                if(element.elementType == "Button") {
                    overlayHistory.splice(i, 1);
                    i--;
                }
            }
        }
    };

    this.removeLevel = function () {
        if (typeof this.viewData.chart != "undefined") {
            var overlayHistory = this.viewData.chart.overlay.history;
            for (var i = 0; i < overlayHistory.length; i++) {
                var element = overlayHistory[i];
                if (element.elementType == "Level") {
                    overlayHistory.splice(i, 1);
                    i--;
                }
            }
        }
    };

    this.addLevel = function (data) {
        if(typeof this.viewData.chart != "undefined") {
            this.removeLevel();

            var element = this.viewData.chart.overlay.createElement("Level");
            element.hasSettings = true;
            element.points = [{'x':new Date(), 'y':data.price}];
            element.setSettings(data);
            this.viewData.chart.overlay.history.push(element);
            this.viewData.chart.render({ "forceRecalc": true, "resetViewport": true, "testForIntervalChange": false });
            return element;
        }
        return false;
    };

    this.getDefaultDateFrom = function (Interval, enableMin){
        var date_to = new Date();
        var date_from = new Date();
        var year, month, day;
        switch (Interval) {
            case"D1":
                date_from.setDate(date_to.getDate() - 25);
                break;
            case"D7":
                date_from.setMonth(date_to.getMonth() - 7);
                break;
            case"M1":
                date_from.setMonth(date_to.getMonth() - 24);
                break;
            case"M3":
                date_from.setMonth(date_to.getMonth() - 36);
                break;
            case"M6":
                date_from.setMonth(date_to.getMonth() - 54);
                break;
            case"Y1":
                date_from.setFullYear(date_to.getFullYear() - 5);
                break;
            case"Y5":
                date_from.setFullYear(date_to.getFullYear() - 10);
                break;
            default:
                date_from.setMonth(date_to.getMonth() - 3)
        }
        year = date_from.getFullYear();
        month = '' + (date_from.getMonth() + 1);
        day = '' + date_from.getDate();

        if (month.length < 2)
            month = '0' + month;
        if (day.length < 2)
            day = '0' + day;

        if (enableMin) {
            return [day, month, year].join('.') + ' 00:00';
        } else {
            return [day, month, year].join('.');
        }

    };

    this.fixViewport = function () {
        if(typeof this.viewData.chart != "undefined" && this.viewData.chart.areas && this.viewData.chart.areas[0].viewport.x.max == this.viewData.chart.areas[0].viewport.x.min) {
            this.viewData.chart.viewport.x.max = this.viewData.chart.areas[0].viewport.x.max - this.viewData.chart.chartOptions.futureAmount;
            this.viewData.chart.viewport.x.min = Math.max(this.viewData.chart.areas[0].viewport.x.max - this.viewData.chart.chartOptions.futureAmount - 30 ,0);
            if (this.viewData.chart.viewport.x.min > this.viewData.chart.viewport.x.max) {
                this.viewData.chart.viewport.x.max = 30;
            }
            this.viewData.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
        }
    };

    this.switchTrading = function () {
        this.userSettings.chartSettings.tradingToolsEnable = this.userSettings.chartSettings.tradingToolsEnable ? 0 : 1;
        window.localStorage.setItem('userSettingsTradingToolsEnable', this.userSettings.chartSettings.tradingToolsEnable);
        //$(this.container).trigger('chartTradingTools');
        $(this.container).trigger('iguanaChartEvents', ['chartTradingTools', this.userSettings.chartSettings.tradingToolsEnable]);
    };

    this.tradingToolsControl = function() {
        if(this.userSettings.chartSettings.tradingToolsEnable) {

            //this.updateNewOrderButton();
            //this.viewData.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
        } else {

            //this.removeNewOrderButton();
            //this.viewData.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
        }
    };

    this.addEvents = function(events) {
        events = events || [];
        for (var i = 0; i < events.length; i++) {
            var element = this.viewData.chart.overlay.createElement("Event");
            element.hasSettings = true;
            var data = $.extend({}, events[i]);
            element.setSettings(data);
            element.points = [{x: data.x, y:data.y}];
            element.id = 'Event';
            this.viewData.chart.overlay.history.push(element);
        }
        this.viewData.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
    };

    this.clearEvents = function() {
        if (typeof this.viewData.chart != "undefined") {
            var overlayHistory = this.viewData.chart.overlay.history;
            for (var i = 0; i < overlayHistory.length; i++) {
                var element = overlayHistory[i];
                if (element.elementType == "Event") {
                    overlayHistory.splice(i, 1);
                    i--;
                }
            }
            this.viewData.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });
        }
    };
    this.errorMessages = function () {
        var text = _t('18104', 'Нет данных');
        if (typeof $.jGrowl != 'function') {
            alert(text);
        } else {
            $.jGrowl(text, {theme: '_red'});
        }
    };
    this.setDatePeriod = function (interval, start, end){
        this.dataSource.dataSettings.interval = interval;
        this.dataSource.dataSettings.period = period;
        this.dataSource.dataSettings.start = start;
        this.dataSource.dataSettings.end = end;
        this.dataSource.dataSettings.date_to = end;
        this.dataSource.dataSettings.timeframe = iChart.getChartTimeframe(interval);

        var period = "M1";
        switch (interval) {
            case"I1":
                period = "D1";
                break;
            case"I5":
                period = "D3";
                break;
            case"I15":
                period = "D7";
                break;
            case"H1":
                period = "D14";
                break;
            case"D1":
                period = "M6";
                break;
            case"D7":
                period = "Y1";
                break
        }

        this.checkPeriod(period);
    };
    this.checkDateInterval = function (new_date_from, new_date_to) {

        var date_from = iChart.formatDateTime(new Date(new_date_from), "dd.MM.yyyy HH:mm");
        var date_to = iChart.formatDateTime(new Date(new_date_to), "dd.MM.yyyy HH:mm");

        var fPeriodChanged = false;
        if (this.dataSource.dataSettings.date_from != date_from || this.dataSource.dataSettings.date_to != date_to) {
            fPeriodChanged = true;
        }

        this.dataSource.dataSettings.date_from = date_from;
        this.dataSource.dataSettings.date_to = date_to;
        this.dataSource.dataSettings.start = date_from;
        this.dataSource.dataSettings.end = date_to;
        //this.dataSource.dataSettings.end = date_to + ' 23:59';
        var interval_tmp = this.dataSource.dataSettings.interval;

        var interval = (new_date_to - new_date_from) / 86400000;
        var fromNow = (new Date().getTime() - new_date_from) / 86400000;

        var Allow1 = new Array;

        Allow1.push("I1");
        Allow1.push("I5");
        Allow1.push("I15");
        Allow1.push("H1");
        Allow1.push("D1");
        Allow1.push("D7"); //TODO: нету данных в mChartAnalysisJSON, нужна доработка сервера

        var restriction = {};

        if(fromNow > 93) { // больше полгода
            restriction = {"I1":"D1", "I5":"D3", "I15":"D7", "H1":"M1"}
        } else if (fromNow < 93 && fromNow >= 32) { // от трех месяцев до полгода
            restriction = {"I1":"D1", "I5":"D3", "I15":"D7"}
        } else if (fromNow < 32 && fromNow >= 10) { // от месяца до трех месяцев
            restriction = {"I1":"D1", "I5":"D3"}
        } else if (fromNow < 10 && fromNow >= 3) { // от недели до месяца
            restriction = {"I1":"D1"}
        } else if (fromNow < 3 && fromNow >= 0) { // от дня
        }

        var dataSource = new Array();

        for (var i = 0; i < Allow1.length; i++) {
            var text = intervalNames(Allow1[i]) + ((typeof restriction[Allow1[i]] != "undefined") ? (" > " + intervalShortNames(restriction[Allow1[i]])) : "");
            dataSource.push({ text: text, value: Allow1[i], restriction: restriction[Allow1[i]] });
        }


        this.dataSource.dataSettings.interval = interval_tmp;

        var result = {restriction: restriction, dataSource: dataSource, value: interval_tmp, text: intervalNames(interval_tmp)};
        if(JSON.stringify(this.dataSource.dataSettings.intervalRestriction) != JSON.stringify(restriction) && interval_tmp == this.dataSource.dataSettings.interval) {
            this.dataSource.dataSettings.intervalRestriction = restriction;
            $(this.container).trigger('iguanaChartEvents', ['intervalRestriction', result]);
        }

        return result;
    };

    this.checkPeriodInterval = function (obj, change) {

        if (change === undefined) change = true;
        var date_to = new Date();
        var date_from = new Date();
        var period;
        period = $(obj).val();
        // задание начальной даты
        switch (period) {
            case "D1":
                break;
            case "D7":
                date_from.setDate(date_to.getDate() - 7);
                break;
            case "M1":
                date_from.setMonth(date_to.getMonth() - 1);
                break;
            case "M3":
                date_from.setMonth(date_to.getMonth() - 3);
                break;
            case "M6":
                date_from.setMonth(date_to.getMonth() - 6);
                break;
            case "Y1":
                date_from.setFullYear(date_to.getFullYear() - 1);
                break;
            case "Y5":
                date_from.setFullYear(date_to.getFullYear() - 5);
                break;
            default:
                date_from.setMonth(date_to.getMonth() - 3);
        }

        if (period) {
            $('#date_to').val(iChart.formatDateTime(date_to, "dd.MM.yyyy"));
            $('#date_from').val(iChart.formatDateTime(date_from, "dd.MM.yyyy"));
        } else {
            var range = (Date.parse($("#date_to").val()) - Date.parse($("#date_from").val())) / 1000;
            if($("#interval").val() == "D1" && range < 86400) {
                $('#date_from').val(iChart.formatDateTime(new Date(Date.parse($("#date_from").val()).getTime() - 86400000 * 7), "dd.MM.yyyy"));
            } else if ($("#interval").val() == "D7" && range < 86400 * 7) {
                $('#date_from').val(iChart.formatDateTime(new Date(Date.parse($("#date_from").val()).getTime() - 86400000 * 14), "dd.MM.yyyy"));
            }
        }

    };

    this.checkPeriod = function (period) {

        var date_to = iChart.parseDateTime(this.dataSource.dataSettings.date_to);
        var date_from = new Date(date_to);

        // задание начальной даты

        var periodRegs = period.match(/([D,M,Y])(\d+)/);

        if(periodRegs) {
            switch (periodRegs[1]) {
                case "D":
                    date_from.setDate(date_to.getDate() - +(periodRegs[2]));
                    break;
                case "M":
                    date_from.setMonth(date_to.getMonth() - +(periodRegs[2]));
                    break;
                case "Y":
                    date_from.setFullYear(date_to.getFullYear() - +(periodRegs[2]));
                    break;
            }
        } else {
            period = "D1";
        }

        if (period) {
            this.dataSource.dataSettings.date_from = iChart.formatDateTime(date_from, "dd.MM.yyyy");
            this.dataSource.dataSettings.date_to = iChart.formatDateTime(date_to, "dd.MM.yyyy");
        } else {
            var range = (iChart.parseDateTime(this.dataSource.dataSettings.date_from).getTime() - iChart.parseDateTime(this.dataSource.dataSettings.date_to).getTime()) / 1000;
            if (this.dataSource.dataSettings.interval == "D1" && range < 86400) {
                this.dataSource.dataSettings.date_from = iChart.formatDateTime(new Date(iChart.parseDateTime(this.dataSource.dataSettings.date_from).getTime() - 86400000 * 7), "dd.MM.yyyy");
            } else if (this.dataSource.dataSettings.interval == "D7" && range < 86400 * 7) {
                this.dataSource.dataSettings.date_from = iChart.formatDateTime(new Date(iChart.parseDateTime(this.dataSource.dataSettings.date_from).getTime() - 86400000 * 14), "dd.MM.yyyy");
            }
        }
        this.checkDateInterval(iChart.parseDateTime(this.dataSource.dataSettings.date_from), iChart.parseDateTime(this.dataSource.dataSettings.date_to));
    };

    this.setInterval = function (interval) {

        var period = "M1";
        switch (interval) {
            case "I1":
                period = "D1";
                break;
            case "I5":
                period = "D3";
                break;
            case "I15":
                period = "D7";
                break;
            case "H1":
                period = "D14";
                break;
            case "D1":
                period = "M6";
                break;
            case "D7":
                period = "Y1";
                break;
        }

        var date_to = new Date(this.getLastPointX() * 1000);
        date_to.setHours(0);
        date_to.setMinutes(0);
        date_to.setSeconds(0);
        date_to.setDate(date_to.getDate()+1);

        this.dataSource.dataSettings.date_to = date_to;
        this.dataSource.dataSettings.interval = interval;
        this.dataSource.dataSettings.timeframe = iChart.getChartTimeframe(interval);
        this.checkPeriod(period);
        this.updateForce();
    };

    this.setHashValue = function (key, value)
    {
        /// <summary>
        /// Sets value at the specified key in the location hash.
        /// </summary>
        /// <param name="key">A key at which the value should be stored.</param>
        /// <param name="value">A value to set.</param>

        if (this.dataSource.dataSettings.useHash == false) {
            var currentHash = this.dataSource.dataSettings.hash;
        } else {
            var currentHash = document.location.hash;
        }
        var values = iChart.parseQueryString(currentHash.substr(1));
        values[key] = value;
        var hash = "#" + iChart.toQueryString(values);
        if (hash !== currentHash)
        {
            if (this.dataSource.dataSettings.useHash == false) {
                this.dataSource.dataSettings.hash = hash;
            } else {
                document.location.hash = hash;
            }
            $(this.container).trigger('iguanaChartEvents', ['hashChanged', hash]);
        }
    };

    this.setHashValues = function (valuesNew)
    {
        /// <summary>
        /// Sets values at the specified keys in the location hash.
        /// </summary>
        /// <param name="valuesNew" type="Object">A dictionary of values to set.</param>

        if (this.dataSource.dataSettings.useHash == false) {
            var currentHash = this.dataSource.dataSettings.hash;
        } else {
            var currentHash = document.location.hash;
        }

        var values = iChart.parseQueryString(currentHash.substr(1));
        for (var key in valuesNew)
        {
            if (valuesNew.hasOwnProperty(key))
            {
                values[key] = valuesNew[key];
            }
        }
        var hash = "#" + iChart.toQueryString(values);
        if (hash !== currentHash && !$.isEmptyObject(values))
        {
            if (this.dataSource.dataSettings.useHash == false) {
                this.dataSource.dataSettings.hash = hash;
            } else {
                document.location.hash = hash;
            }
            $(this.container).trigger('iguanaChartEvents', ['hashChanged', hash]);
        }
    };

    this.initInsrMinicolors = function (element) {
        var color = element.val();

        $(element).minicolors({
            animationSpeed: 50,
            animationEasing: 'swing',
            change: null,
            changeDelay: 0,
            control: 'hue',
            defaultValue: color,
            hide: null,
            hideSpeed: 100,
            inline: false,
            letterCase: 'lowercase',
            opacity: false,
            position: element.attr('ui-pos') + ' left',
            show: null,
            showSpeed: 100,
            theme: 'default'
        }).change(function(){
            var serialIndex = $(this).attr('colorIndex').split('-')[0];
            var colorIndex = $(this).attr('colorIndex').split('-')[1];
            var indicator = $(this).attr('indicator');
            if($.isArray(_this.userSettings.chartSettings.indicatorsColor)) {
                _this.userSettings.chartSettings.indicatorsColor = {};
            }
            if(!_this.userSettings.chartSettings.indicatorsColor[indicator]) {
                _this.userSettings.chartSettings.indicatorsColor[indicator] = [];
            }
            if(!_this.userSettings.chartSettings.indicatorsColor[indicator][serialIndex]) {
                _this.userSettings.chartSettings.indicatorsColor[indicator][serialIndex] = Array(_this.viewData.indicators[indicator].output);
            }
            _this.userSettings.chartSettings.indicatorsColor[indicator][serialIndex][colorIndex] = $(this).val();
        });
    };

    this.initIndicatorWidthMenu = function (element, menu) {
        $(element).qtip({
            style: {
                classes: 'qtip-light'
            },
            position: {
                at: 'left bottom',
                my: 'top left',
                effect: false
            },
            content: {
                text: menu
            },
            hide: {
                fixed: true,
                delay: 300,
                effect: function() {
                    //$(this).hide('slide', 500);
                    $(this).slideUp(500);
                }
            },
            show: {
                solo: true,
                effect: function() {
                    //$(this).show('slideDown', 500);
                    $(this).slideDown(500);
                }
            },
            events: {
                show: function(event, api) {
                }
            }
        });
    };

    this.setIndicatorWidth = function (element) {

        var serialIndex = $(element).parent().attr('widthIndex').split('-')[0];
        var lineIndex = $(element).parent().attr('widthIndex').split('-')[1];
        var indicator = $(element).parent().attr('indicator');

        if($.isArray(this.userSettings.chartSettings.indicatorsWidth)) {
            this.userSettings.chartSettings.indicatorsWidth = {};
        }

        if(!this.userSettings.chartSettings.indicatorsWidth[indicator]) {
            this.userSettings.chartSettings.indicatorsWidth[indicator] = [];
        }
        if(!this.userSettings.chartSettings.indicatorsWidth[indicator][serialIndex]) {
            this.userSettings.chartSettings.indicatorsWidth[indicator][serialIndex] = Array(this.viewData.indicators[indicator].output);
        }
        $(".indicatorWidthSelector-" + serialIndex + lineIndex + "[data-chartName='" + this.name +"']").attr('data-style', $(element).attr('data-style'));
        this.userSettings.chartSettings.indicatorsWidth[indicator][serialIndex][lineIndex] = $(element).attr('data-style');
    };

    this.getIndicatorParameters = function (indicator) {
        var params = {};
        if(typeof this.viewData.indicators[indicator] != "undefined") {
            for(var i=0; i<this.viewData.indicators[indicator].parameters.length;i++) {
                params[this.viewData.indicators[indicator].parameters[i].Code] = this.viewData.indicators[indicator].parameters[i].Value;
            }
        }
        return params;
    };

    this.setIndicator = function (indicator, params, number) {
        number = number || 0;

        if(typeof this.viewData.indicators[indicator] == "undefined") {
            throw new Error("Indicator '" + indicator + "' is not supported.");
        }

        params = params || this.getIndicatorParameters(indicator);

        var newIndicator = {};

        newIndicator['i'+number] = indicator;
        for(var param in params) {
            newIndicator['i' + number + '_' + param] = params[param];
        }

        var oldIndicators = iChart.parseQueryString(this.dataSource.dataSettings.graphicIndicators);
        for (var paramKey in oldIndicators)
        {
            if (paramKey.match(new RegExp("^i" + number + '_', "i"))) {
                delete  oldIndicators[paramKey];
            }
        }

        oldIndicators['i' + number] = '';
        this.dataSource.dataSettings.graphicIndicators = iChart.toQueryString($.extend({}, oldIndicators, newIndicator));
        this.updateForce();
    };

    this.getPeriodDates = function (period) {
        var date_to = new Date();
        var date_from = new Date();

        date_to.setHours(0);
        date_to.setMinutes(0);
        date_to.setSeconds(0);
        date_to.setDate(date_to.getDate()+1);
        date_from.setHours(0);
        date_from.setMinutes(0);
        date_from.setSeconds(0);

        var periodRegs = period.match(/([D,M,Y])(\d+)/);

        if(periodRegs) {
            switch (periodRegs[1]) {
                case "D":
                    date_from.setDate(date_from.getDate() - +(periodRegs[2]) + 1);
                    break;
                case "M":
                    date_from.setMonth(date_from.getMonth() - +(periodRegs[2]));
                    break;
                case "Y":
                    date_from.setFullYear(date_from.getFullYear() - +(periodRegs[2]));
                    break;
            }
        } else {
            date_from.setMonth(date_from.getMonth() - +(3));
        }

        return {
            date_from: iChart.formatDateTime(date_from, "dd.MM.yyyy"),
            date_to: iChart.formatDateTime(date_to, "dd.MM.yyyy")
        };
    };

    this.addPoint = function (point) {
        var data = this.dataSource.dataAdapter(point, {});
        this.viewData.chart._mergeData(data, {});
        this.viewData.chart.render({
            "forceRecalc": true,
            "resetViewport": false,
            "testForIntervalChange": false
        });
    };

    this.setStyleToCanvas = function (color, prop) {
        var selected = this.viewData.chart.overlay.selected;
        if (selected != null && selected.hasSettings) {
            var settings = selected.settings;
            settings[prop] = color;
            selected.setSettings(settings);
            if(this.viewData.chart.chartOptions.elementStyle[selected.elementType]) {
                this.viewData.chart.chartOptions.elementStyle[selected.elementType][prop] = color;
            }
        }
        this.userSettings.chartSettings.contextSettings[prop] = color;
    };

    this.setLineWidthToCanvas = function (width) {
        var selected = this.viewData.chart.overlay.selected;
        if (selected != null && selected.hasSettings) {
            selected.settings.lineWidth = width;
            selected.setSettings(selected.settings);
        }

        this.userSettings.chartSettings.contextSettings.lineWidth = width;
    };

    if(typeof jNTChartTrading != 'undefined') {
        /*//РИСОВАНИЕ ПРИКАЗОВ*/

        if (typeof jNTUserinfo !== "undefined" && jNTUserinfo.isDemo) {
            if (typeof extendIChartWithTrandorders == 'function') {
                extendIChartWithTrandorders.call(this);
            }
        } else {
            if (typeof extendIChartWithOrders == 'function') {
                extendIChartWithOrders.call(this);
            }
        }

        /*РИСВАНИЕ ПОЗИЦИИ*/
        if (typeof extendIChartWithPositions == 'function') {
            extendIChartWithPositions.call(this);
        }

        /*РИСВАНИЕ ТОРГОВЫХ ПАНЕЛЕЙ*/
        if (typeof extendIChartWithTradePanels == 'function') {
            extendIChartWithTradePanels.call(this);
        }
    }

//----------------------------------------------------------------------------------------------------------------------
    this.setTrendorder = function (data) {

        if(typeof this.viewData.chart != "undefined") {

            var element = this.viewData.chart.overlay.createElement("Trendorder");
            element.hasSettings = true;
            element.setSettings(data);

            this.viewData.chart.overlay.history.push(element);

        }
    };

    this.drawTrendorder = function () {

        var data = {
            date: 1461569774688.537,
            price: 2890.65358452394,
            date2: 1461584727590.7007,
            price2: 2883.7317157761254,
            fillStyle: '#7cb342',
            strokeStyle: '#36BDF4',
            textColor: '#ffffff',
            text: _t("87549", "Трендовый приказ"),
            mode: "trend",
            onCancel: function() {console.log(this);}
        };

        var data3 = {
            date: 1461531600000,
            price: 2893,
            date2: 1461618000000,
            price2: 2879,
            fillStyle: '#7cb342',
            strokeStyle: '#36BDF4',
            textColor: '#ffffff',
            text: _t("87549", "Трендовый приказ"),
            mode: "trend",
            onCancel: function() {console.log(this);}
        };

        var data4 = {
            date: 1472798700000,
            price: 142.73127071556314,
            date2: 1472799600000,
            price2: 142.75374359194433,
            tf: 900,
            fillStyle: '#7cb342',
            strokeStyle: '#36BDF4',
            textColor: '#ffffff',
            text: _t("87549", "Трендовый приказ"),
            mode: "trend",
            onCancel: function() {console.log(this);}
        };

        var data2 = {
            date: 1472553953049000,
            price: 135,
            fillStyle: '#7cb342',
            strokeStyle: '#36BDF4',
            textColor: '#ffffff',
            text: _t("87549", "Трендовый приказ"),
            mode: "line",
            onCancel: function() {console.log(this);}
        };


        this.setTrendorder(data4);
        this.viewData.chart.render({ "forceRecalc": true, "resetViewport": true, "testForIntervalChange": false });
    };

//----------------------------------------------------------------------------------------------------------------------

    $(document).on("change", ".indicatorsSelect", this.indicator_onChange);
    $(document).on("click", ".js-indicator-remove", this.removeIndicator_onClick);
    $(document).on("click", ".js-indicator-add", this.addIndicator_onClick);
    $(document).on("change", "[name='timeframe']", this.timeframe_onChange);
    //$(document).on("change", "[name=graphic_format]", this.chartType_onChange);
    $(document).on("click", "[name='apply']", this.apply_onClick);
    $(document).on("click", "[name='clearIndicators']", this.clearIndicators_onClick);
    $(document).on("click", "[name='pan']", this.pan_onClick);
    $(document).on("click", ".js-lineWidth." + this.name, function(){
        _this.setIndicatorWidth(this)
    });
    //    $(document).on("click", "[name='removeAllInstruments']", this.removeAllInstruments_onClick);
    //    $(document).on("click", "[name='removeSelectedInstrument']", this.removeSelectedInstrument_onClick);
    $(document).on("click", "[name='resetZoom']", this.resetZoom_onClick);
    //$(document).on("click", "[name='SelectInstrument']", this.selectInstrument_onClick);
    $(document).on("click", "[name='updateChart']", this.updateChart_onClick);
    $(document).on("click", "[name='zoom']", this.zoom_onClick);
    $(document).on("dblclick", function () {
        _this.viewData.chart.render({ "forceRecalc": true, "resetViewport": true, "testForIntervalChange": false });
    });
    $(_this.wrapper).on('iguanaChartEvents', function(event, name, data) {
        if(name === 'chartDataReady') {
            if(_this.viewData.chart && _this.dataRequestCounter == 0) {
                _this.viewData.chart.updateVolumeByPrice();
                _this.ui.initStatesControls();
            }
        } else if(name === 'selectInstrument') {
            _this.ui.onSelectInstrument(data);
        } else if(name === 'drawComplete') {
            _this.ui.setUiStateForInstrumentLine(null, 0);
            _this.ui.setUiStateForInstrumentForm(null, 0);
            _this.ui.setUiStateForInstrumentText(null, 0);
        }
    });

    $(_this.wrapper).on("click", ".iChart-indicator-description a", function(e){
        e.stopPropagation();
        e.stopImmediatePropagation();
        return false;
    });

    //$(window).on("hashchange", this.window_onHashChange);

    $(window).on("resize", function(){
        _this.wrapper.trigger('iguanaChartEvents', ['chartResize']);
    });

    $(document).on("click", "[name='toggleVolumeByPrice']", this.toggleVolumeByPrice_onClick);

};

(function ()
{
    "use strict";

    /**
     * @param {IguanaChart} chart
     */

    iChart.ui = function (chart) {

        this.chart = chart;
        var _this = this;

        this.$uiContainer = this.chart.wrapper;
        this.$topToolBarContainer = this.chart.wrapper.find('.iChartToolsTop');

        this.render = function () {
            var chartOptionsUiTools = this.chart.viewData.chart.chartOptions.uiTools;
            if(chartOptionsUiTools.top) {
                this.renderTopBar();
            }
            this.bindUiControls();
        };

        this.renderTopBar = function () {
            this.$topToolBarContainer.empty();
            //this.renderIndicators();
            this.renderTopToolBar();
            this.$topToolBarContainer.show();
        };

        /**
         *
         */
        this.renderIndicators = function () {
            var data = {
                indicators: Object.keys(iChart.indicators).map(function(k) { return iChart.indicators[k] }),
                userData: this.chart.deserializeIndicators(this.chart.dataSource.dataSettings.graphicIndicators)
            };

            var indicatorsDropdownHtml = $.render.indicatorsDropdownTmpl(data);

            //this.$topToolBarContainer.append(indicatorsDropdownHtml);
            this.chart.wrapper.find('.js-chart-ui-indicators').append(indicatorsDropdownHtml);

            $(this.chart.wrapper).off('click', '.js-add-indicator').on('click', '.js-add-indicator', function () {
                var ind = $(this).data('value');
                var params = {};
                iChart.indicators[ind].parameters.forEach(function(n){
                    params[n.Code] = n.Value
                });
                var indicators = _this.chart.deserializeIndicators(_this.chart.dataSource.dataSettings.graphicIndicators);
                indicators.push({name: ind, params: params});
                _this.chart.dataSource.dataSettings.graphicIndicators = _this.chart.serializeIndicators(indicators);
                _this.chart.setIndicators(_this.chart.dataSource.dataSettings.graphicIndicators);
                _this.renderIndicatorsCurrent();
            });


            $(this.chart.wrapper).off('click', '.js-remove-indicator').on('click', '.js-remove-indicator', function (e) {
                var ind = _this.chart.deserializeIndicators(_this.chart.dataSource.dataSettings.graphicIndicators);
                ind.splice($(this).data('index'), 1);
                _this.chart.dataSource.dataSettings.graphicIndicators = _this.chart.serializeIndicators(ind);
                _this.chart.setIndicators(_this.chart.dataSource.dataSettings.graphicIndicators);
                _this.renderIndicatorsCurrent();
                e.stopPropagation();
                e.preventDefault();
            });

            $(this.chart.wrapper).off('click', '.js-edit-indicator').on('click', '.js-edit-indicator', function (e) {
                var indicators = _this.chart.deserializeIndicators(_this.chart.dataSource.dataSettings.graphicIndicators);
                var inx = $(this).data('index');

                var uis = $.extend({}, iChart.indicators[indicators[inx].name]);
                uis.parameters.forEach(function(n){
                    n.Value = indicators[inx].params[n.Code];
                });

                _this.renderIndicatorDialog(uis, inx);
            });
        };

        /**
         *
         */
        this.renderIndicatorsList = function () {
            var data = {
                indicators: Object.keys(iChart.indicators).map(function(k) { return iChart.indicators[k] }),
            };

            var indicatorsListHtml = $.render.indicatorsListTmpl(data);

            this.$topToolBarContainer.find('.js-iChartTools-indicators-list').html(indicatorsListHtml);
        };

        /**
         *
         */
        this.renderIndicatorsCurrent = function () {
            var data = {
                userData: this.chart.deserializeIndicators(this.chart.dataSource.dataSettings.graphicIndicators)
            };

            var indicatorsCurrentHtml = $.render.indicatorsCurrentTmpl(data);

            this.$topToolBarContainer.find('.js-iChartTools-indicators-current').html(indicatorsCurrentHtml);

        };

        /**
         *
         * @param data
         * @param index
         */
        this.renderIndicatorDialog = function (data, index) {
            if($.modal.impl.d.data) {
                $.modal.impl.close();
            }

            $('.iChartDialog').remove();
            var $indicatorDialogHtml = $($.render.indicatorDialogTmpl(data));

            var $colorContainer = $indicatorDialogHtml.find('.js-iChartTools-indicators-colorContainer');
            var $widthContainer = $indicatorDialogHtml.find('.js-iChartTools-indicators-widthContainer');
            var colorIndex = index;

            if(iChart.indicators[data.value]) {
                for (var i = 0; i < iChart.indicators[data.value].output; i++) {
                    if (typeof this.chart.viewData.chart != 'undefined') {

                        var color = this.chart.viewData.chart.chartOptions.indicatorColors[colorIndex][i];
                        if (this.chart.userSettings.chartSettings.indicatorsColor[data.value] &&
                            this.chart.userSettings.chartSettings.indicatorsColor[data.value][colorIndex] &&
                            this.chart.userSettings.chartSettings.indicatorsColor[data.value][colorIndex][i]
                        ) {
                            color = this.chart.userSettings.chartSettings.indicatorsColor[data.value][colorIndex][i];
                        }

                        $("<input/>", {
                                "type": "hidden",
                                "class": "iChart-indicator-color iChart-indicator-color-" + colorIndex + i,
                                "id": "iChart-indicator-color-" + colorIndex + i,
                                "indicator": data.value,
                                "colorIndex": colorIndex + "-" + i,
                                "ui-pos": (colorIndex < 2 ? "bottom" : "top")
                            }
                        ).val(color).appendTo($colorContainer);


                        this.chart.initInsrMinicolors($colorContainer.find(".iChart-indicator-color-" + colorIndex + i));

                        var width = 2;
                        if (this.chart.userSettings.chartSettings.indicatorsWidth[data.value] &&
                            this.chart.userSettings.chartSettings.indicatorsWidth[data.value][colorIndex] &&
                            this.chart.userSettings.chartSettings.indicatorsWidth[data.value][colorIndex][i]) {
                            width = this.chart.userSettings.chartSettings.indicatorsWidth[data.value][colorIndex][i];
                        }

                        var indicatorWidth = $('<span class="lineWidth indicatorWidthSelector-' + colorIndex + i + '" data-chartName="' + this.chart.name + '" data-style="' + width + '"></span>').appendTo($widthContainer);
                        $('<div class="indicatorMenuHolder-' + colorIndex + i + '" data-chartName="' + this.chart.name + '" style="display: none" widthIndex="' + colorIndex + "-" + i + '">' +
                            '<div widthIndex="' + colorIndex + "-" + i + '" indicator="' + data.value + '">' +
                            '<span class="lineWidth js-lineWidth ' + this.chart.name + '" data-style="1"></span>' +
                            '<span class="lineWidth js-lineWidth ' + this.chart.name + '" data-style="2"></span>' +
                            '<span class="lineWidth js-lineWidth ' + this.chart.name + '" data-style="3"></span>' +
                            '<span class="lineWidth js-lineWidth ' + this.chart.name + '" data-style="4"></span>' +
                            '<span class="lineWidth js-lineWidth ' + this.chart.name + '" data-style="5"></span>' +
                            '<span class="lineWidth js-lineWidth ' + this.chart.name + '" data-style="8"></span>' +
                            '<span class="lineWidth js-lineWidth ' + this.chart.name + '" data-style="10"></span>' +
                            '</div>' +
                            '</div>').appendTo($widthContainer);
                        this.chart.initIndicatorWidthMenu(indicatorWidth, $widthContainer.find(".indicatorMenuHolder-" + colorIndex + i + "[data-chartName='" + this.chart.name + "']").html());

                    }
                }
            }

            $(document).off('click', '.js-set-params-indicator').on('click', '.js-set-params-indicator', function (e) {
                var indicators = _this.chart.deserializeIndicators(_this.chart.dataSource.dataSettings.graphicIndicators);
                var newParams = $('.js-iChartTools-indicators-params input').serializeArray();
                var validParams = true;

                newParams.forEach(function (param) {
                    //check valid parameters
                    if (!_this.checkValidParameters(param, iChart.indicators[indicators[index].name])) {
                        validParams = false;
                    }
                    else {
                        indicators[index].params[param.name] = param.value;
                    }
                });
                if (!validParams) {
                    return;
                }
                indicators = _this.chart.serializeIndicators(indicators);
                _this.chart.setIndicators(indicators);
                $.modal.impl.close();
            });

            this.chart.wrapper.append($indicatorDialogHtml);
            $('.iChartDialog').modal({modal: false, zIndex: 1500, title: _t('17398', 'Настройки индикатора')});
        };
        this.checkValidParameters = function (newParams, indicator) {
            var result = true;
            indicator.parameters.forEach(function (param) {
                if (param.Code !== newParams.name) return;

                result = _this.getResultErrorOnMaxMinValue(newParams, param, result);
            });
            return result;
        };
        this.getResultErrorOnMaxMinValue = function (newParams, param, result) {
            if (param.MinValue !== undefined && parseInt(newParams.value) < param.MinValue) {
                _this.errorMessage(
                    _t('62392', 'Неверный параметр %name%, он должен быть больше %value%',
                        {name: param.Name, value: param.MinValue - 1})
                );
                result = false;
            }

            if (param.MaxValue !== undefined && parseInt(newParams.value) < param.MaxValue) {
                _this.errorMessage(
                    _t('62393', 'Неверный параметр %name%, он должен быть меньше %value%',
                        {name: param.Name, value: param.MaxValue})
                );
                result = false;
            }
            return result;
        };
        this.errorMessage = function (text) {
            if ($.jGrowl === undefined) {
                alert(text);
            } else {
                $.jGrowl(text, {theme: '_red'});
            }
        };
        this.renderThemeConfigDialog = function (additionButtons) {
            additionButtons = additionButtons || [];
            var $windowContent = $($.render.themeConfigTmpl());

            if(additionButtons) {

                var $additionButtonsContainer = $windowContent.find('.js-themeAdditionButtons');
                $additionButtonsContainer.empty();

                additionButtons.forEach(function(row){
                    var $button = $('<button/>', {class: 'uk-button ' + row.class, text: row.title});
                    $additionButtonsContainer.append($button);

                });
            }

            $windowContent.find('.js-themeConfigOptions').empty().append(this.renderThemeConfigOptions());
            $windowContent.find('.js-themeConfigSelector').empty().append(this.renderThemeConfigSelector());

            $windowContent.data("chartOptions", $.extend(true, {}, this.chart.wrapper.iguanaChart('chartOptions')));


            this.chart.wrapper.find('.js-themeConfig').remove();
            this.chart.wrapper.append($windowContent);

            var $themeConfig = this.chart.wrapper.find('.js-themeConfig');


            var onCloseModal = function() {
                _this.chart.wrapper.iguanaChart('chartOptions', $windowContent.data("chartOptions"));
                _this.setUiStateForThemeConfig(false);
                if($.modal.impl.d.data) {
                    $.modal.impl.close();
                }
            };

            $themeConfig.modal({
                modal: false,
                draggable: true,
                maxWidth: 600,
                zIndex: 1500,
                title: _t('13754', "Настройки вида"),
                onClose: onCloseModal
            });


            $themeConfig.on('click','.js-chartOptions', function(){
                switch ($(this).attr('data-value')) {
                    case 'ok':
                        _this.chart.wrapper.trigger('iguanaChartEvents', ['hashChanged']);
                        _this.chart.wrapper.trigger('iguanaChartEvents', ['chartOptionsChanged', iChart.Charting.ChartOptions.getThemeOptions(_this.chart.viewData.chart.chartOptions)]);
                        _this.chart.userSettings.chartSettings.defaultTheme = 0;
                        _this.setUiStateForThemeConfig(false);
                        if($.modal.impl.d.data) {
                            $.modal.impl.close(false);
                        }
                        break;
                    case 'cancel':
                        onCloseModal();
                        break;
                }
            });

            $themeConfig.on('click', '.js-themeSelect', function(){
                _this.chart.wrapper.iguanaChart('setTheme', $(this).data('theme'));
                $windowContent.find('.js-themeConfigOptions').empty().append(_this.renderThemeConfigOptions());
                return false;
            });

            $themeConfig.on('click', '.js-themeSaveAs', function(){

                UIkit.modal.prompt(_t('5228', "Название") + ':', '', function(title){
                    if(title) {
                        var data = {
                            name: title,
                            settings: iChart.Charting.ChartOptions.getThemeOptions(_this.chart.viewData.chart.chartOptions)
                        };

                        $iguanaChart.thems.push($.extend({custom: true}, data));
                        data = JSON.stringify(data);
                        _this.chart.wrapper.trigger('iguanaChartEvents', ['themeSave', data]);
                        $windowContent.find('.js-themeConfigSelector').empty().append(_this.renderThemeConfigSelector());
                    }
                });
                return false;
            });

            $themeConfig.on('click', '.js-themeDelete', function(e){
                var name = $(this).data('name');
                var pos = $.grep($iguanaChart.thems, function(n, i){ return (n.name == name) ? (n.i = i) : null})[0];
                $iguanaChart.thems.splice(pos,1);
                $themeConfig.find('.js-themeSelect[data-theme="' + name + '"]').remove();
                _this.chart.wrapper.trigger('iguanaChartEvents', ['themeDelete', name]);
                e.stopPropagation();
                return false;
            });


            return $themeConfig;

        };

        this.renderThemeConfigSelector = function () {
            var $themeConfigSelector = $($.render.themeConfigSelectorTmpl({themes: $iguanaChart.thems}));
            return $themeConfigSelector;
        };


        this.renderThemeConfigOptions = function () {
            var $themeConfigOptions = $($.render.themeConfigOptionsTmpl({chartOptions: _this.chart.viewData.chart.chartOptions}));

            $themeConfigOptions.find('.js-widthSlector').each(function(){
                var $this = $(this),
                    menu = $this.find('.menuHolder').html();

                $this.qtip({
                    style: {
                        classes: 'qtip-light'
                    },
                    position: {
                        at: 'center right',
                        my: 'left center',
                        effect: false
                    },
                    content: {
                        text: menu
                    },
                    hide: {
                        fixed: true,
                        delay: 300,
                        effect: function() {
                            $(this).slideUp(500);
                        }
                    },
                    show: {
                        solo: true,
                        effect: function() {
                            $(this).slideDown(500);
                        }
                    },
                    events: {
                        show: function(event, api) {
                            $(this).find('.js-widthSlectorWrapper').each(function(){
                                var $wrapper = $(this);
                                $wrapper.off().on('click', '.js-lineWidth', function(){
                                    var value = $(this).attr('data-style');
                                    _this.chart.wrapper.iguanaChart('chartOptions', $wrapper.attr('data-option'), value);
                                    $this.find('.js-widthSlectorValue').attr('data-style', value);
                                });
                            });
                        }
                    }
                });
            });

            var onMinicolorsChange = function(value, opacity){
                var color = $(this).val(),
                    colorRGBA = color,
                    option = $(this).attr('data-option');

                if(!color.match(/^rgb.*/)) {
                    colorRGBA = iChart.hexToRGB(color, opacity)
                }

                _this.chart.wrapper.iguanaChart('chartOptions', option, colorRGBA);
                $(".js-colorSelector[data-option='" + option + "']").css({'background-color': colorRGBA});

                $(this).minicolors('value', color);
                $(this).minicolors('opacity', opacity);
            };

            var onPaletteChange = function() {
                var color = this.value,
                    colorRGBA = iChart.hexToRGB(color, 1),
                    option = this.element.attr('data-option');

                _this.chart.wrapper.iguanaChart('chartOptions', option, colorRGBA);
                $(".js-colorSelector[data-option='" + option + "']").css({'background-color': colorRGBA});

                this.element.parent().find('.js-colorPicker').minicolors('value', color);
            };

            $themeConfigOptions.find('.js-colorSelector').each(function(){

                var $this = $(this),
                    menu = $this.find('.menuHolder').html();

                $this.qtip({
                    style: {
                        classes: 'qtip-light'
                    },
                    position: {
                        at: 'center right',
                        my: 'left center',
                        effect: false,
                        viewport: $('html'),
                        adjust: {
                            method: 'shift none'
                        }
                    },
                    content: {
                        //title: title,
                        text: menu
                    },
                    hide: {
                        fixed: true,
                        delay: 300
                    },
                    show: {
                        solo: true
                    },
                    events: {
                        show: function(event, api) {
                            $(event.currentTarget).find('.js-colorPicker').each(function(){
                                _this.addMinicolors(this, event.currentTarget, onMinicolorsChange, onPaletteChange);
                            });
                        }
                    }
                });
            });

            $themeConfigOptions.find('.js-checkbox').on('click', '.js-flag', function(){
                _this.chart.wrapper.iguanaChart('chartOptions', $(this).attr('data-option'), $(this).prop('checked'));
            });

            return $themeConfigOptions;
        };


        this.initMinicolors = function (element, onMinicolorsChange) {

            onMinicolorsChange = typeof onMinicolorsChange == "function" ? onMinicolorsChange : function(){};

            var $input = $(element);
            var opacityTrue = ($input.first().attr('data-opacity'))?true:false;
            var opacity = $input.first().attr('data-opacity');
            var color = $input.first().val();
            color = color ? color : 'rgba(82, 175, 201, 0.5)';

            $(element).minicolors({
                animationSpeed: 50,
                animationEasing: 'swing',
                change: onMinicolorsChange,
                changeDelay: 0,
                control: 'hue',
                defaultValue: color,
                hide: null,
                hideSpeed: 100,
                inline: true,
                letterCase: 'lowercase',
                opacity: opacityTrue,
                position: 'bottom left',
                show: null,
                showSpeed: 100,
                theme: 'default'
            });
            $(element).minicolors('value', color);
        };

        this.initColorPalette = function (holder, onPaletteChange) {
            onPaletteChange = typeof onPaletteChange == "function" ? onPaletteChange : function(){};
            $(holder).find('.js-colorPalette').each( function() {
                if($(this).data("palette") == undefined) {
                    $(this).palette({
                        palette: "basic",
                        columns: 2,
                        size: 13,
                        change: onPaletteChange
                    });
                }
             });
        };

        this.addMinicolors = function (element, holder, onMinicolorsChange, onPaletteChange) {
            if($(element).hasClass('minicolors-input')) {
                var color = $(element).val();
                $(element).minicolors('value', color);
                return;
            }
            this.initMinicolors(element, onMinicolorsChange);
            this.initColorPalette(holder, onPaletteChange);
        };

/* ================================================================================================================== */
        
        this.renderTopToolBar = function () {
            var $topToolBarHtml = $($.render.iChart_topToolBarTmpl());

            this.$topToolBarContainer.append($topToolBarHtml);
            this.renderIndicators();
        };

        /**
         * init states control elements
         */
        this.initStatesControls = function () {
            var type = this.chart.viewData.chart.chartOptions.chartType;
            this.setUiStateForChartType(type);

            var state = !!this.chart.viewData.chart.chartOptions.showVolumeByPrice;
            this.setUiStateForShowVolumeByPrice(state);

            var state = _this.chart.viewData.chart.chartOptions.showVolume;
            this.setUiStateForShowVolume(state);

            var state = _this.chart.viewData.chart.chartOptions.percentMode;
            this.setUiStateForPercentMode(state);

            this.setUiStateForDataInterval(_this.chart.dataSource.dataSettings.interval);
        };

        this.bindUiControls = function () {
            this.$uiContainer.off('click', '.js-chart-ui-control').on('click', '.js-chart-ui-control', function (e) {
                var $this = $(this);

                var property  = $this.data('property');
                var value = $this.data('value');

                var method = 'uiSet_' + property;

                if(typeof _this[method] === 'function') {
                    _this[method](value);
                }
            });

            this.$uiContainer.on('show.uk.dropdown', '.js-chart-ui-control[data-property="fillStyle"]', function(){
                var $this = $(this);
                $(this).find('.js-colorPicker').each(function(){
                    _this.addMinicolors(this, $this.find('.js-chart-ui-control-holder'), _this.onMinicolorsChange, _this.onPaletteChange);
                });
            });

            this.$uiContainer.on('show.uk.dropdown', '.js-chart-ui-control[data-property="strokeStyle"]', function(){
                var $this = $(this);
                $(this).find('.js-colorPicker').each(function(){
                    _this.addMinicolors(this, $this.find('.js-chart-ui-control-holder'), _this.onMinicolorsChange, _this.onPaletteChange);
                });
            });

        };

        this.uiSet_chartType = function (value) {
            this.chart.viewData.chart.setChartType(value);
            this.setUiStateForChartType(value);
            this.chart.wrapper.trigger('iguanaChartEvents', ['chartOptionsChanged', {"chartType" : value}]);
        };

        this.uiSet_showVolumeByPrice = function (value) {
            this.chart.VolumeByPrice_onClick();
            var state = !!this.chart.viewData.chart.chartOptions.showVolumeByPrice;
            this.setUiStateForShowVolumeByPrice(state);
            this.chart.wrapper.trigger('iguanaChartEvents', ['chartOptionsChanged', {"showVolumeByPrice" : state}]);
        };

        this.uiSet_showVolume = function (value) {
            this.chart.VolumeByDate_onClick();
            var state = _this.chart.viewData.chart.chartOptions.showVolume;
            this.setUiStateForShowVolume(state);
            this.chart.wrapper.trigger('iguanaChartEvents', ['chartOptionsChanged', {"showVolume" : state}]);
        };

        this.uiSet_percentMode = function (value) {
            var percentMode = this.chart.percentMode_onClick();
            this.setUiStateForPercentMode(percentMode);
            this.chart.wrapper.trigger('iguanaChartEvents', ['chartOptionsChanged', {"percentMode" : percentMode}]);
        };

        this.uiSet_themeConfig = function () {

            if($.modal.impl.d.data) {
                $.modal.impl.close();
                this.setUiStateForThemeConfig(false);
            } else {
                this.renderThemeConfigDialog();
                this.setUiStateForThemeConfig(true);
            }
        };

        this.uiSet_instrumentLine = function (value) {
            var settings = $.extend({}, this.chart.userSettings.chartSettings.contextSettings, this.chart.viewData.chart.chartOptions.elementStyle[value]);

            this.chart.wrapper.iguanaChart("toolStart", value, settings);
            this.setUiStateForInstrumentLine(value, 1);
            this.onSelectInstrument({settings: settings});
        };

        this.uiSet_instrumentForm = function (value) {
            var settings = $.extend({}, this.chart.userSettings.chartSettings.contextSettings, this.chart.viewData.chart.chartOptions.elementStyle[value]);

            this.chart.wrapper.iguanaChart("toolStart", value, settings);
            this.setUiStateForInstrumentForm(value, 1);
            this.onSelectInstrument({settings: settings});
        };

        this.uiSet_instrumentText = function (value) {
            var settings = $.extend({}, this.chart.userSettings.chartSettings.contextSettings, this.chart.viewData.chart.chartOptions.elementStyle[value]);

            this.chart.wrapper.iguanaChart("toolStart", value, settings);
            this.setUiStateForInstrumentText(value, 1);
            this.onSelectInstrument({settings: settings});
        };

        this.uiSet_clearInstruments = function () {
            this.chart.removeAllInstruments_onClick();
        };

        this.uiSet_lineWidthSelector = function (value) {
            this.chart.setLineWidthToCanvas(value);
            this.setUiStateForLineWidth(value);
        };

        this.uiSet_dataInterval = function (value) {
            this.chart.setInterval(value);
            this.setUiStateForDataInterval(value);
        };

        this.uiSet_captureImage = function () {
            var dataImage = this.chart.viewData.chart.toBase64withSize('image/png');

            if($.modal.impl.d.data) {
                $.modal.impl.close();
            }

            $('.iChartDialog').remove();
            var $captureDialogTmpl = $($.render.captureDialogTmpl());

            $captureDialogTmpl.find('.js-iChartTools-capture').
                attr('src', 'data:image/png;base64, ' + dataImage.string).
                attr('height', dataImage.height).
                attr('width', dataImage.width)
            ;

            $captureDialogTmpl.on('click', '.js-set-params-indicator', function () {
                _this.saveScreenOnDisk();
            });
            this.chart.wrapper.append($captureDialogTmpl);

            var width = dataImage.width;
            var height = dataImage.height;

            width = width ? width : 120;
            height = height > 0 ? height : 150;

            $('.iChartDialog').
                modal({
                    modal: false,
                    zIndex: 1500,
                    close: true,
                    minWidth: width,
                    minHeight: height,
                    title: _t('1724', 'Скачать картинку')
                });
        };

        this.saveScreenOnDisk = function () {
            var link = document.createElement('a');
            link.href = $('.iChartDialog').find('.js-iChartTools-capture').attr('src');
            link.download = 'tn-screen.png';
            link.click();
        };

        this.onMinicolorsChange = function(value, opacity){
            var color = $(this).val(),
                colorRGBA = color,
                option = $(this).attr('data-option');

            if(!color.match(/^rgb.*/)) {
                colorRGBA = iChart.hexToRGB(color, opacity)
            }

            _this.chart.userSettings.chartSettings.contextSettings[option] = colorRGBA;
            _this.setUiStateForColorSelector(option, colorRGBA);

            $(this).minicolors('value', colorRGBA);
            _this.chart.setStyleToCanvas(colorRGBA, option);
        };

        this.onPaletteChange = function(){
            var color = this.value;
            var option = this.element.attr('data-option');
            var colorRGBA = color;

            if(!color.match(/^rgb.*/)) {
                colorRGBA = iChart.hexToRGB(color, 1);
            }

            _this.chart.userSettings.chartSettings.contextSettings[option] = colorRGBA;
            _this.setUiStateForColorSelector(option, colorRGBA);
            this.element.parent().find('.js-colorPicker').minicolors('value', colorRGBA);
            _this.chart.setStyleToCanvas(colorRGBA, option);
        };



// =====================================================================================================================
// Processing ui elements

        this.setUiStateForChartType = function (type, uiClass) {

            if(!!type) {
                uiClass = this.getUiStateForChartType(type);
            }

            this.$uiContainer.find('.js-chart-ui-control-state[data-property="chartType"]')
                .removeClass('sprite-icon-line sprite-icon-candle sprite-icon-bars')
                .addClass(uiClass);
        };

        this.getUiStateForChartType = function (type) {
            var uiClass = 'sprite-icon-line';

            switch (type) {
                case 'Candlestick':
                    uiClass = 'sprite-icon-candle';
                    break;
                case 'Stock':
                    uiClass = 'sprite-icon-bars';
                    break;
                case 'Line':
                    uiClass = 'sprite-icon-line';
                    break;
            }

            return uiClass;
        };

        this.setUiStateForShowVolumeByPrice = function (state) {
            if(state) {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="showVolumeByPrice"]').addClass('active');
            } else {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="showVolumeByPrice"]').removeClass('active');
            }
        };

        this.setUiStateForShowVolume = function (state) {
            if(state == "inside" || state == "outside") {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="showVolume"]').addClass('active');
            } else {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="showVolume"]').removeClass('active');
            }
        };

        this.setUiStateForPercentMode = function (state) {
            if(state) {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="percentMode"]').addClass('active');
            } else {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="percentMode"]').removeClass('active');
            }
        };

        this.setUiStateForThemeConfig = function (state) {
            if(state) {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="themeConfig"]').addClass('active');
            } else {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="themeConfig"]').removeClass('active');
            }
        };

        this.setUiStateForLineWidth = function (width) {
            this.$uiContainer.find('.js-chart-ui-control-state[data-property="lineWidthSelector"]')
                .removeClass('sprite-icon-1px sprite-icon-2px sprite-icon-3px sprite-icon-4px sprite-icon-5px sprite-icon-8px sprite-icon-10px')
                .addClass('sprite-icon-' + width + 'px');
        };

        this.setUiStateForColorSelector = function (option, colorRGBA) {
            if(!colorRGBA.match(/^rgb.*/)) {
                colorRGBA = iChart.hexToRGB(colorRGBA, 1);
            }

            this.$uiContainer.find('.js-chart-ui-control-state[data-property="' + option + '"]').css({'background-color': colorRGBA});
            this.$uiContainer.find('.js-chart-ui-control[data-property="' + option + '"] .js-colorPicker').val(colorRGBA);
        };

        this.setUiStateForInstrumentLine = function (instrument, state) {
            state = !!state;

            var uiClass = '';

            switch (instrument) {
                case 'Line':
                    uiClass = 'sprite-icon-free-line';
                    break;
                case 'HorizontalLine':
                    uiClass = 'sprite-icon-h-line';
                    break;
                case 'VerticalLine':
                    uiClass = 'sprite-icon-v-line';
                    break;
                case 'Channel':
                    uiClass = 'sprite-icon-channel';
                    break;
                case 'Trend':
                    uiClass = 'sprite-icon-angle-trend';
                    break;
                case 'Arrow':
                    uiClass = 'sprite-icon-arrow-line';
                    break;
            }

            if(state) {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="instrumentLine"]').addClass('active');
            } else {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="instrumentLine"]').removeClass('active');
            }

            if(!!instrument) {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="instrumentLine"] i.sprite')
                    .removeClass('sprite-icon-free-line sprite-icon-h-line sprite-icon-v-line sprite-icon-channel sprite-icon-angle-trend sprite-icon-arrow-line')
                    .addClass(uiClass);
            }
        };

        this.setUiStateForInstrumentForm = function (instrument, state) {
            state = !!state;

            var uiClass = '';

            switch (instrument) {
                case 'Polygon':
                    uiClass = 'sprite-icon-f-poligon';
                    break;
                case 'Rectangle':
                    uiClass = 'sprite-icon-f-square';
                    break;
                case 'Triangle':
                    uiClass = 'sprite-icon-f-triangle';
                    break;
                case 'Ellipse':
                    uiClass = 'sprite-icon-f-ellipse';
                    break;
                case 'FibonacciArc':
                    uiClass = 'sprite-icon-f-fibonacci-arcs';
                    break;
                case 'FibonacciFan':
                    uiClass = 'sprite-icon-f-fibonacci-fan';
                    break;
                case 'FibonacciCorrection':
                    uiClass = 'sprite-icon-f-fibonacci-correction';
                    break;
                case 'HorizontalRange':
                    uiClass = 'sprite-icon-h-line-double';
                    break;
            }

            if(state) {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="instrumentForm"]').addClass('active');
            } else {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="instrumentForm"]').removeClass('active');
            }

            if(!!instrument) {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="instrumentForm"] i.sprite')
                    .removeClass('sprite-icon-f-poligon sprite-icon-f-square sprite-icon-f-triangle')
                    .removeClass('sprite-icon-f-ellipse sprite-icon-f-fibonacci-arcs sprite-icon-f-fibonacci-fan sprite-icon-f-fibonacci-correction')
                    .addClass(uiClass);
            }
        };

        this.setUiStateForInstrumentText = function (instrument, state) {
            state = !!state;

            if(state) {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="instrumentText"][data-value="' + instrument + '"]').addClass('active');
            } else {
                this.$uiContainer.find('.js-chart-ui-control-state[data-property="instrumentText"]').removeClass('active');
            }
        };

        this.onSelectInstrument = function (element) {
            if(element.settings) {
                if(element.settings.lineWidth) {
                    this.setUiStateForLineWidth(element.settings.lineWidth);
                }

                if(element.settings.fillStyle) {
                    this.setUiStateForColorSelector('fillStyle', element.settings.fillStyle);
                }

                if(element.settings.strokeStyle) {
                    this.setUiStateForColorSelector('strokeStyle', element.settings.strokeStyle);
                }
            }
        };

        this.setUiStateForDataInterval = function (value) {
            this.$uiContainer.find('.js-chart-ui-control[data-property="dataInterval"]').removeClass('active');
            if(!!value) {
                this.$uiContainer.find('.js-chart-ui-control[data-property="dataInterval"][data-value="' + value + '"]').addClass('active');
            }

        };


    };
})();
(function ($){

    $iguanaChart =  {};

    $iguanaChart.defaultTheme = {};
    $iguanaChart.thems = [{
        name: "White",
        settings: {
            backgroundColor:'#ffffff',
            axisColor: '#999999',
            showAxes: false,
            labelColor: '#595959',
            labelFontColor: '#ffffff',
            gridColor: '#cccccc',
            gridStyle: 'dashed', // [dashed|solid]
            watermarkColor: 'rgba(238,238,238,1)',
            watermarkFont: 'bold 40px Verdana',
            watermarkSubFont: 'bold 25px Verdana',
            candleUp: '#66B85C',
            candleDown: '#C75757',
            candleBorder: true,
            candleBorderUp: '#66B85C',
            candleBorderDown: '#C75757',
            candleWick: true,
            candleWickStyle: '#595959',
            stockUp: '#66B85C',
            stockDown: '#C75757',
            stockWidth: 1,
            lineColor: '#595959',
            lineWidth: 1,
            areaColor: '#eff6fb',
            areaLineColor: '#cccccc',
            volumeStyle: 'rgba(119, 119, 119, 0.3)',
            scrollerOverlayColor: 'rgba(0,0,0, 0.1)',
            scrollerHandlerColor: 'rgba(255,255,255, 1)',
            shadowColor: '#999999',
        }
    },{
        name: "Dark",
        settings: {
            backgroundColor:'#1e222d',
            axisColor: '#2a2e39',
            showAxes: false,
            labelColor: '#595959',
            labelFontColor: '#ffffff',
            gridColor: '#2a2e39',
            gridStyle: 'dashed', // [dashed|solid]
            watermarkColor: '#2a2e39',
            watermarkFont: 'bold 40px Roboto',
            watermarkSubFont: 'bold 25px Roboto',
            candleUp: '#26a69a',
            candleDown: '#ef5350',
            candleBorder: true,
            candleBorderUp: '#26a69a',
            candleBorderDown: '#ef5350',
            candleWick: true,
            candleWickStyle: '#595959',
            stockUp: '#26a69a',
            stockDown: '#ef5350',
            stockWidth: 1,
            lineColor: '#787b86',
            lineWidth: 1,
            areaColor: 'rgba(33,150,243,.12)',
            areaLineColor: 'rgba(33,150,243,.12)',
            volumeStyle: 'rgba(33,150,243,.12)',
            scrollerOverlayColor: 'rgba(0,0,0, 0.1)',
            scrollerHandlerColor: '#787b86',
            shadowColor: '#2a2e39'
        }
    }];

    $iguanaChart.defaultSettings = {
        chartSettings: {
            contextSettings: {
                fillStyle: 'rgba(82,175,201,.2)',
                strokeStyle: 'rgba(82,175,201,1)',
                lineWidth: 1,
                fontFamaly: 'Arial,Helvetica,sans-serif',
                fontColor: '#444444',
                fontSize: '14'
            },
            indicatorsColor: {},
            indicatorsWidth: {},
            showTransactionsMode: 0,
            tradingToolsEnable: 0,
            autochartistEnable: 0,
            defaultTheme: 1
        },
        currentSecurity: {
            id: '',
            short_name: '',
            default_ticker: '',
            nt_ticker: '',
            firstDate: '',
            currency: '',
            min_step: ''
        }
    };

    $iguanaChart.getTemplate = function(containerId, name) {
        return '' +
            '<div class="iChart-control-form" style="min-height: 200px">' +
                '<div class="js-chartContainerWrapper">' +
                    '<div class="iChartToolsContainer"><div class="iChartToolsTop" style="display: none;">' +
                    '</div></div>' +
                    '<div id="' + containerId + '" class="m-chart-container" style="height: 100%;">' +
                    '</div>' +
                '</div>' +
                    '<div data-uk-modal="{center:true}" class="uk-modal iChart-form-simple-v js-chartTADialog uk-padding-remove ' + name + '" id="iChart-tech-analysis-dialog" style="display: none;">' +
                        '<div class="uk-modal-dialog">' +
                            '<a class="uk-modal-close uk-close"></a>' +
                                '<div class="uk-modal-header">' + _t('3101', "Индикаторы") + '</div>' +
                                '<div class="js-chartTADialogContainer"></div>' +
                                '<div class="uk-modal-footer">' +
                                '<div class="uk-flex uk-flex-middle uk-flex-space-between tm-pad-large">' +
                                    '<div class="js-indicator-add md-btn md-btn-small md-btn-success">' +
                                        _t('15460', 'Добавить индикатор') +
                                    '</div>' +
                                '<div class="md-btn-group"><a class="md-btn md-btn-small md-btn-primary indicators-set" href="#">' + _t('532', 'Применить') + '</a>' +
                                '<a class="md-btn md-btn-small indicators-default" href="#">' + _t('15461', 'Для всех') + '</a>' +
                                '<a class="md-btn md-btn-small indicators-close" href="#">' + _t('1403', "Отмена") + '</a></div>' +
                            '</div>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="chart-loader-wrapper" style="top: 0; width: 100%; height: 100%;"><div class="chart-loader"></div></div>' +
            '</div>'
    };

    $iguanaChart.init = function (chartObj, params) {

        function initReadyCallback (chartOptions) {
            chartObj.initChart(chartOptions);
            if(typeof params.events != "undefined") {
                chartObj.addEvents(params.events);
            }
        }

        chartObj.dataSource.preInit(initReadyCallback, params);
    };

    $iguanaChart.optionsStore = function () {
        var chartsStore = JSON.parse(window.localStorage.getItem('chartsStore') || '{}');

        if($.isPlainObject(arguments[0]) && !$.isEmptyObject(arguments[0])) {
            chartsStore = $.extend(chartsStore, data);
        } else if(typeof arguments[0] == 'string') {
            chartsStore[arguments[0]] = arguments[1];
        }
        window.localStorage.setItem('chartsStore', JSON.stringify(chartsStore));
    };

    $iguanaChart.optionsRestore = function (key) {
        var chartsStore = JSON.parse(window.localStorage.getItem('chartsStore') || '{}');
        if(key) {
            return chartsStore[key];
        } else {
            return chartsStore;
        }
    };

    var methods = {
        // инициализация плагина
        init: function(params, n) {

            var $wrapper = this;

            if ($wrapper.data('iguanaChart')) {

                var chart = $wrapper.data('iguanaChart');
                for (var timer in chart.timers) {
                    clearTimeout(chart.timers[timer]);
                }
                chart.ajaxDataRequest.abort();
                chart.viewData.chart._dataLoading = false;

                $iguanaChart.init($wrapper.data('iguanaChart'), params);

            } else {

                var name = 'chart' + n + '_' + (new Date().getTime()),
                    containerId = name + '_container',
                    //template = $.render.iChart_mainTmpl({id: containerId, name: name}),
                    template = $iguanaChart.getTemplate(containerId, name),
                    lib_path = params.lib_path || '',
                    chartObj = new IguanaChart({name: name, container: "#" + containerId, wrapper: $wrapper, lib_path: lib_path, dataSource: $.extend(true, {}, params.dataSource)});

                //chartObj.userSettings = $.extend(true, {}, chartObj.userSettings, params.settings);

                $wrapper
                    .html(template)
                    .data('iguanaChart', chartObj)
                    .on('iguanaChartEvents', function(e, name, data){

                        switch (name) {
                            case 'chartDataReceived':
                                var tmLoader = $wrapper.data('tmLoader');
                                clearTimeout(tmLoader);
                                $wrapper.find('.chart-loader-wrapper').css({opacity: "0.0", height: 0, left: "-2000px", transition: "opacity .75s ease-in-out, height 0s ease-in-out .75s, left 0s ease-in-out .75s"});
                                break;

                            case 'chartDataRequest':
                                var tmLoader = $wrapper.data('tmLoader');
                                clearTimeout(tmLoader);
                                tmLoader = setTimeout(function () {$wrapper.find('.chart-loader-wrapper').css({opacity: "1.0", height: "100%", left: 0, transition: "opacity .0s ease-in-out, height 0s ease-in-out .0s"})}, 750);
                                $wrapper.data('tmLoader', tmLoader);

                                break;
                        }
                    })
                ;
                $iguanaChart.init($wrapper.data('iguanaChart'), params);
            }

            this.trigger('iguanaChartEvents', ['initComplete', params]);

        },
        setType: function(chartType) {

            var chartObj = this.data('iguanaChart');

            if (chartObj.viewData.chart) {
                chartObj.viewData.chart.setChartType(chartType);
            }

            chartObj.setHashValue("type", chartType);

            this.trigger('iguanaChartEvents', ['setType', chartType]);
        },
        setTheme: function(options) {
            var themeName = options[0];
            var theme = $.grep($iguanaChart.thems, function(theme) {return (theme.name == themeName ? theme : null);} )[0];
            if(typeof theme !== "undefined") {
                var iguanaChart = this.data('iguanaChart'),
                    chart = iguanaChart.viewData.chart;
                $.extend(chart.chartOptions, theme.settings);
                methods.render.call(this);
                this.trigger('iguanaChartEvents', ['setTheme', themeName]);
            } else {
                throw new Error('Theme "' + themeName + '" is not exist.');
            }
        },
        render: function(options) {
            if(!$.isArray(options)) {
                options = [];
            }
            var iguanaChart = this.data('iguanaChart'),
                forceRecalc = (typeof options[0] !== "undefined") ? !!options[0] : true,
                resetViewport = (typeof options[1] !== "undefined") ? !!options[1] : false,
                testForIntervalChange = (typeof options[2] !== "undefined") ? !!options[2] : false;
            if(iguanaChart.viewData.chart) {
                var chart = iguanaChart.viewData.chart;
                chart.render({
                    "forceRecalc": forceRecalc,
                    "resetViewport": resetViewport,
                    "testForIntervalChange": testForIntervalChange
                });
                $(iguanaChart.container).find('.js-scrollerOverlay').css({background: chart.chartOptions.scrollerOverlayColor});
                $(iguanaChart.container).find('.js-scrollerHandler').css({background: chart.chartOptions.scrollerHandlerColor});
            }
        },
        chartOptions: function(options) {
            var iguanaChart = this.data('iguanaChart'),
                chart = iguanaChart.viewData.chart;

            if(typeof options[0] !== "undefined") {
                if(typeof options[0] == "object") {
                    $.extend(true, chart.chartOptions, options[0]);
                } else if (typeof options[0] == "string" && typeof options[1] !== "undefined") {
                    chart.chartOptions[options[0]] = options[1];
                }
                methods.render.call(this);
            } else {
                return chart.chartOptions;
            }
        },
        events: function(options) {
            var chart = this.data('iguanaChart');
            chart.clearEvents();
            if(typeof options[0] != 'undefined') {
                chart.addEvents(options[0]);
            }
            methods.render.call(this);
        },
        toolStart: function(options) {
            var iguanaChart = this.data('iguanaChart'),
                chart = iguanaChart.viewData.chart;
            if (chart.overlay) {
                var element = chart.overlay.start(options[0]);
                element.setSettings(options[1]);
            }
            return false;
        },
        addPoint: function(options) {
            var iguanaChart = this.data('iguanaChart');
            iguanaChart.addPoint(options[0]);
        },
        destroy: function() {
            if (this.data('iguanaChart')) {
                var chart = this.data('iguanaChart');
                //console.log('destroy:', chart.name);
                for (var timer in chart.timers) {
                    clearTimeout(chart.timers[timer]);
                    chart.ajaxDataRequest.abort();
                }
            }
        }
    };

    $.fn.iguanaChart = function (options) {

        if(typeof options === "undefined" || typeof options === 'object') {

            return this.each(function(n){
                var selector = $(this);
                methods.init.call(selector, options, n);
                return selector;
            });

        } else if (typeof options === 'string') {

            var args = Array.prototype.slice.call(arguments, 1);

            if (methods[options] && typeof methods[options] == 'function') {

                if(args.length) {
                    return this.each(function (n) {
                        var selector = $(this);
                        methods[options].call(selector, args);
                        return selector;
                    });
                } else {
                    var selector = $(this).eq(0);
                    return methods[options].call(selector, args);
                }

            } else {
                return console.error('Method should be function');
            }
        } else {
            return console.error('Options should be object, string or undefined');
        }

    };

})(jQuery);
TA = {
    TICKER: 0,
    PER: 1,
    DATE: 2,
    TIME: 3,
    OPEN: 4,
    HIGH: 5,
    LOW: 6,
    CLOSE: 7,
    VOL: 8,
    FULLDATE: 9,
    FULLTIME: 10,
    DATESTRING: 11
};

TA.TA_COMPATIBILITY_DEFAULT = 0x0000;
TA.TA_GLOBALS_COMPATIBILITY = TA.TA_COMPATIBILITY_DEFAULT;


/**
 * Типы скользящей средней
 */
TA.MATypes = {
	SMA: 0x000,
	EMA: 0x001,
	WMA: 0x002,
	DEMA: 0x003,
	TEMA: 0x004,
	TRIMA: 0x005,
	KAMA: 0x006,
	MAMA: 0x007,
	T3: 0x008
};

TA.TA_IS_ZERO = function (v) { return (((-0.00000001)<v)&&(v<0.00000001))};

/* Convert a period into the equivalent k:
 *
 *    k = 2 / (period + 1)
 *
 * Useful to calculate the 'k' for TA_INT_EMA().
 */
TA.PER_TO_K = function (per) {
	return (2.0 / ((per + 1)));
};

TA.TA_FUNC_UNST_EMA = 0x0000;
TA.TA_FUNC_UNST_ADX = 0x0001;

TA.TA_Globals = {
	unstablePeriod: [0, 0]
};

TA.TA_GLOBALS_UNSTABLE_PERIOD = function (x, y) {
	return TA.TA_Globals.unstablePeriod[x]
};

/**
 * Базовый класс. Содержит функции управления значениями и индивидуальными настройками.
 */
TA.BASE_TEMPLATE = {

	__TICKER__: undefined,

	/**
	 * Настройки по умолчанию. Используются когда устанавливаются индивидуальные настройки тикера и при этом некоторые значения не указаны.
	 * Используются при инициализации индикатора.
	 */
	DefaultSettings: {

	},

	/**
	 * Проверяет заполнено ли переданное значение, если нет - возвращает установленное значение
	 * @param   {Object}	value            Любое значение
	 * @param   {String}	standartVariable Имя переменной по умолчанию
	 * @returns {Object}	Получаемое значение
	 */
	CheckStandartValue: function (value, standartVariable) {
		if (!value) {
			if (!this.Settings[standartVariable]) {
				return this.Settings[standartVariable];
			} else {
				return this.DefaultSettings[standartVariable];
			}
		} else {
			return value;
		}
	},

	/**
	 * Устанавливает индикатору переданные значения из параметра settings
	 * @param {Object} settings набор настроек индикатора
	 * @return {Object} Индикатор
	 */
	SetSettings: function (settings) {
		var name;

		if (!!settings) {
			if (settings != this.DefaultSettings) {
				this.SetSettings(this.DefaultSettings);
			}

			for (name in settings) {
				this.Settings[name] = +(settings[name]);
			}
		}

		return this;
	},

	/**
	 * Получает текущие настройки индикатора
	 * @returns {Object} Возвращает коллекцию текущих настроек
	 */
	GetSettings: function () {
		var i,
			answer = this.DefaultSettings;

		for (i in answer) {
			answer[i] = this.Settings[i];
		}
		return answer;
	},

	IndividualSettings: {

	},

	/**
	 * Устанавливает индивидуальные настройки для тикера
	 * @param {String} ticker тикер, для которого требуется установить индивидуальные настройки
	 * @return {Object} Этот объект
	 */
	SetIndividualSettings: function (ticker) {
		ticker = MainController.RatesController.getTicker(ticker);

		this.SetSettings(this.DefaultSettings);

		if (!!this.IndividualSettings[ticker]) {
			this.SetSettings(this.IndividualSettings[ticker]);
		}

		return this;
	},

	/**
	 * Проверяет - равен ли переданный тикер тому, по которому объект хранит индивидуальные настройки. Если тикер - другой, перезаполняет его новыми значениями.
	 * @param   {String}	ticker тикер, который требуется проверить
	 * @returns {Boolean}  	TRUE - перезаполнение не требуется.
	 *                      FALSE - потребовалось перезаполнение настроек.
	 */
	checkTicker: function (ticker) {
		ticker = MainController.RatesController.getTicker(ticker);
		if (this.__TICKER__ != ticker) {
			this.__TICKER__ = ticker;
			this.SetIndividualSettings(ticker);

			return false;
		}

		return true;
	},

	/**
	 * Возвращает настройки для автоматического подбора параметров. Если настройка - число возвращается значение вида '<НачальноеЗначение>-<КонечноеЗначение>:<ШагПодбора>', иначе - массив вида [Значение1, Значение2, ...]
	 * @param {Array} Массив имен свойств, по которым надо получить настройки. Если не заполнен - возвращаются все.
	 * @returns {Array} Массив объектов для автоматического подбора объектов
	 */
	getSettingsParameters: function (settingsNames) {
		var answer = [],
			totalItems = 0;

		for (var i in this.Settings) {
			if (!!settingsNames && !(settingsNames.indexOf(i) + 1)) {
				continue;
			}

			if (typeof this.Settings[i] == 'number') {
				answer.push({
					name: i,
					values: '' + this.Settings[i] + '-' + this.Settings[i] + ':1'
				});
			} else if (typeof this.Settings[i] == 'boolean') {
				answer.push({
					name: i,
					values: [true, false]
				});
			} else {
				answer.push({
					name: i,
					values: [this.Settings[i]]
				});
			}
		}

		return answer;
	},

	/**
	 * Возвращает новый объект класса. Важно! Использовать для всех не базовых экземпляров классов: индикаторы, контроллеры, интерфейсы и прочее
	 * @returns {[[Type]]} [[Description]]
	 */
	Create: function () {
		var newObject = $.extend(true, {}, this);

		function extendGetterSetter(target, owner) {
			for (var i in owner) {
				if (typeof owner[i] === 'object' && !!owner[i] && owner[i] != {}) {
					extendGetterSetter(target[i], owner[i]);
				}
				var setter = owner.__lookupSetter__(i);
				var getter = owner.__lookupGetter__(i);

				if (!!setter || !!getter) {
					if (!target[i])
						delete target[i];

					if (!!setter) {
						target.__defineSetter__(i, setter);
					}

					if (!!getter) {
						target.__defineGetter__(i, getter);
					}
				}
			}
		};

		extendGetterSetter(newObject, this);

		return newObject;
	}
};

/**
 * Базовый класс индикатора. Добавлены настройки вывода на график и функции получения сигналов.
 */
TA.INDICATOR_TEMPLATE = TA.BASE_TEMPLATE.Create();

TA.INDICATOR_TEMPLATE.Create = function(settings) {
	var newObject = TA.BASE_TEMPLATE.Create.apply(this);
	var _lookback;
    newObject.justifyCalculate = function() {
        var result = this.calculate.apply(this, arguments);

        if ($.isArray(result)) {
            _lookback = this._lookback(this.Settings.TimePeriod);
            for(var i = 0; i < _lookback; i++) {
                result.unshift(0);
            }
        }
		else {
			_lookback = TA.INDICATOR_TEMPLATE.getLookBackParam(this);

			for (var key in result) {
				for (var i = 0; i < _lookback; i++) {
					result[key].unshift(0);
				}
			}
        }
        return result;
    };
	
	if(!!settings)
		this.SetSettings(settings);
	
	return newObject;
};

TA.INDICATOR_TEMPLATE.getLookBackParam = function(that) {
	var lookBack;
	switch (that.name) {
		case 'MACD':
			lookBack = that._lookback(that.Settings.SlowPeriod, that.Settings.FastPeriod,
				that.Settings.SignalPeriod);
			break;
		case 'BBANDS':
			lookBack = that._lookback(that.Settings.TimePeriod, that.Settings.DeviationsUp,
				that.Settings.DeviationsDown, that.Settings.MAType);
			break;
		case 'PCH':
			lookBack = that._lookback(that.Settings.TimePeriodLower, that.Settings.TimePeriodUpper);
			break;
		case 'ELDR':
			lookBack = that._lookback(that.Settings.TimePeriod, that.Settings.MAType);
			break;
		case 'SAR':
			lookBack = that._lookback(that.Settings.Acceleration, that.Settings.Maximum);
			break;
		case 'STOCH':
			lookBack = that._lookback(that.Settings.PeriodFastK, that.Settings.PeriodSlowK,
				that.Settings.PeriodSlowD, that.Settings.SlowKMAType, that.Settings.SlowDMAType);
			break;
		case 'VAR':
			lookBack = that._lookback(that.Settings.PeriodFastK, that.Settings.DeviationsUp);
			break;
		default:
			lookBack = that._lookback(that.Settings.TimePeriod);
	}
	return lookBack;
}

/**
 * Шаблон для переопределяемой функции инициации вывода графика
 * @param   {Array} 	dataShape Массив свечей котировки
 * @param   {Object} 	options   Массив настроек вывода графика
 * @param   {string} 	ticker    Тикер для которого выводится график
 * @returns {Object} ссылка на объект индикатора
 */
TA.INDICATOR_TEMPLATE.initChart = function (dataShape, options, ticker) {
	this.checkTicker(ticker);
	return this;
};

/**
 * Шаблон переопределяемой функции фильтрации переданных сигналов.
 * @param   {Array} 	dataShape    Массив свечей котировки
 * @param   {Array} 	signalsArray Массив сигналов, которые надо отфильтровать
 * @returns {Array} Массив отфильтрованных сигналов
 */
TA.INDICATOR_TEMPLATE.filterSignalsArray = function (dataShape, signalsArray) {
	return [];
};

/**
 * Фильтрует сигнал на определенную дату
 * @param   {Array} 	dataShape       Массив котировок свечей
 * @param   {Date} 		dateSignal      Дата, на которую надо отфильтровать сигнал
 * @param   {Array} 	signalArray 	Массив сигналов
 * @returns {Object} Объект вида: {clear: {Boolean}}
 */
TA.INDICATOR_TEMPLATE.filterSignal = function (dataShape, dateSignal, signalArray) {
	return {
		clear: true
	};
};

/**
 * Функция возвращает сигнал - надо ли открывать позицию для торговли.
 * @param {Date} 		dateSignal Дата, на которую надо расчитать сигнал
 * @param {String} 		ticker     Тикер, для которого получается сигнал
 * @return {null|String} ORDER_BUY, ORDER_SELL, null сигнал - надо ли открывать позицию
 */
TA.INDICATOR_TEMPLATE.getOpenSignal = function (dateSignal, ticker) {
	this.checkTicker(ticker);

	return null;
};

/**
 * Функция возвращает - надо ли закрывать открытую позицию.
 * @param   {Date} 		dateSignal Дата, для которой расчитывается сигнал
 * @param   {String} 	ticker     Тикер, для которого расчитывается сигнал
 * @returns {Boolean}  	Признак, что позицию надо закрывать.
 */
TA.INDICATOR_TEMPLATE.getCloseSignal = function (dateSignal, ticker) {
	this.checkTicker(ticker);

	return false;
};

/**
 * Возвращает настройки для вывода индикатора на график
 * @param   {Array}		settingsNames Имена возможных параметров настройки
 * @returns {Array} Массив возможных настроек графика. Подробнее см. getSettingsParameters
 */
TA.INDICATOR_TEMPLATE.getGraphicSettingsParameters = function (settingsNames) {
	var answer = this.getSettingsParameters.apply(this, arguments);

	return answer;
};

/**
 * Возвращает настройки для сигналов индикатора
 * @param   {Array}		settingsNames Имена возможных параметров настройки
 * @returns {Array} Массив возможных настроек сигнала индикатора. Подробнее см. getSettingsParameters
 */
TA.INDICATOR_TEMPLATE.getTradeSettingsParameters = function (settingsNames) {
	var answer = this.getSettingsParameters.apply(this, arguments);

	return answer;
};

/**
 * Базовый класс контроллера.
 */
TA.CONTROLLER_TEMPLATE = TA.BASE_TEMPLATE.Create();

/**
 * Возвращает отобранные объекты по фильтру
 * @param   {Object}	filers - Объект вида {<ИмяПараметра>: <ИмяОтбора>}
 * @returns {Array}    Отобранные объекты контроллера.
 */
TA.CONTROLLER_TEMPLATE.getByFilter = function (filers) {
	return [];
};

/**
 * Выполняет инициализацию контроллера. Надо переопределять в объекте контроллера
 * @returns {Object} - Возвращает объект контроллера.
 */
TA.CONTROLLER_TEMPLATE.init = function () {
	this.checkTicker();
	return this;
};

/**
 * Шаблон для переопределяемой функции инициации вывода графика
 * @param   {Array} 	dataShape Массив свечей котировки
 * @param   {Object} 	options   Массив настроек вывода графика
 * @param   {string} 	ticker    Тикер для которого выводится график
 * @returns {Object} ссылка на объект контроллера
 */
TA.CONTROLLER_TEMPLATE.initChart = function (dataShape, options, ticker) {
	this.checkTicker(ticker);
	return this;
};

/**
 * Хранилище текущих значений контроллера. ОБЯЗАТЕЛЬНО ТРЕБУЕТ ПЕРЕОПРЕДЕЛЕНИЯ В КОНКРЕТНОМ КОНТРОЛЛЕРЕ.
 */
TA.CONTROLLER_TEMPLATE._data = null;

/**
 * Функция получения значения хранилища.
 */
TA.CONTROLLER_TEMPLATE.__defineGetter__('data', function () {
	return this._data;
});

/**
 * Функция установки значения хранилища.
 */
TA.CONTROLLER_TEMPLATE.__defineSetter__('data', function (data) {
	return this.update(data)
});

/**
 * Функция установки значения хранилища контроллера
 * @param   {Object}	data значение, которое надо установить контроллеру.
 * @returns {Object} Объект контроллера
 */
TA.CONTROLLER_TEMPLATE.update = function (data) {
	return this;
};

/**
 * Возвращает признак - есть ли данные в контроллере.
 * @returns {Boolean} Признак - есть ли данные в контроллере.
 */
TA.CONTROLLER_TEMPLATE.isEmpty = function () {
	return !this._data.length;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.AD = TA.INDICATOR_TEMPLATE.Create();
else
    TA.AD = {};

TA.AD.name = 'AD';
TA.AD.type = 'line';

TA.AD.DefaultSettings = {};

TA.AD.Settings = {};

TA.AD.calculate = function(startIdx, endIdx, dataShape){
	var nbBar, currentBar, outIdx;

	var high, low, close, tmp;
	var ad;
	
	var outReal = [];

	if(!startIdx)
		startIdx = 0;
	
	if(!endIdx)
		endIdx = dataShape.length - 1;

	if( startIdx < 0 )
		throw 'TA_OUT_OF_RANGE_START_INDEX';
	if( (endIdx < 0) || (endIdx < startIdx))
		throw 'TA_OUT_OF_RANGE_END_INDEX';

	if(!dataShape || !dataShape.length)
		throw 'TA_BAD_PARAM';


	if( !outReal )
		throw 'TA_BAD_PARAM';


	/* Default return values */
	nbBar = endIdx-startIdx+1;
	
	currentBar = startIdx;
	outIdx = 0;
	ad = 0.0;

	while( nbBar != 0 ) {
		high  = dataShape[currentBar][TA.HIGH];
		low   = dataShape[currentBar][TA.LOW];
		tmp   = high-low;
		close = dataShape[currentBar][TA.CLOSE];

		if( tmp > 0.0 )
			ad += (((close-low)-(high-close))/tmp)*( dataShape[currentBar][TA.VOL]);

		outReal[outIdx++] = ad;

		currentBar++;
		nbBar--;
	}

	return outReal;
};

TA.AD.getValue = function(dataShape, itemIdx) {
	var high, low, close, tmp;
	var ad = 0;
	
	high  = dataShape[itemIdx][TA.HIGH];
	low   = dataShape[itemIdx][TA.LOW];
	tmp   = high-low;
	close = dataShape[itemIdx][TA.CLOSE];

	if( tmp > 0 )
		ad += (((close-low)-(high-close))/tmp)*( dataShape[itemIdx][TA.VOL]);
	
	return ad;
};

TA.AD._lookback = function() {
	return 0;
};

TA.AD._S = function(startIdx, endIdx, dataShape) {
	var nbBar, currentBar, outIdx;
    var high, low, close, tmp;
	var ad;

	var outReal = [];
	
	if( startIdx < 0 )
		throw 'TA_OUT_OF_RANGE_START_INDEX';
	if( (endIdx < 0) || (endIdx < startIdx))
		throw 'TA_OUT_OF_RANGE_END_INDEX';

	if(!dataShape || !dataShape.length)
		throw 'TA_BAD_PARAM';


	if( !outReal )
		throw 'TA_BAD_PARAM';

    nbBar = endIdx-startIdx+1;

    currentBar = startIdx;
    outIdx = 0;
    ad = 0.0;
    while( nbBar != 0 ) {
		high  = dataShape[currentBar][TA.HIGH];
		low   = dataShape[currentBar][TA.LOW];
		tmp   = high-low;
		close = dataShape[currentBar][TA.CLOSE];

		if( tmp > 0 )
			ad += (((close-low)-(high-close))/tmp)*( dataShape[currentBar][TA.VOL]);

		outReal[outIdx++] = ad;
		currentBar++;
		nbBar--;
    }
    
	return outReal;
};

if (!!TA.INDICATOR_TEMPLATE)
    TA.ADOSC = TA.INDICATOR_TEMPLATE.Create();
else
    TA.ADOSC = {};

TA.ADOSC.name = 'ADOSC';
TA.ADOSC.type = 'line';

TA.ADOSC.DefaultSettings = {
	/**
	 * Number of period for the fast MA
	 */
	FastPeriod: 3,
	
	/**
	 * Number of period for the slow MA
	 */
	SlowPeriod: 10
};

TA.ADOSC.Settings = {};

TA.ADOSC.calculate = function (startIdx, endIdx, dataShape, settings) {
	var today, outIdx, lookbackTotal;
	var slowestPeriod;
	var high, low, close, tmp;

	var slowEMA, slowk, one_minus_slowk;
	var fastEMA, fastk, one_minus_fastk;
	var ad;

	var outReal = [];

	this.SetSettings(settings);

	if (!startIdx)
		startIdx = 0;

	if (!endIdx)
		endIdx = dataShape.length - 1;

	if (startIdx < 0)
		throw 'TA_OUT_OF_RANGE_START_INDEX';
	if ((endIdx < 0) || (endIdx < startIdx))
		throw 'TA_OUT_OF_RANGE_END_INDEX';

	if (!dataShape || !dataShape.length)
		throw 'TA_BAD_PARAM';

	if (!this.Settings.FastPeriod)
		this.Settings.FastPeriod = 3;
	else if ((this.Settings.FastPeriod < 2) || (this.Settings.FastPeriod > 100000))
		throw 'TA_BAD_PARAM';

	if (!this.Settings.SlowPeriod)
		this.Settings.SlowPeriod = 10;
	else if ((this.Settings.SlowPeriod < 2) || (this.Settings.SlowPeriod > 100000))
		throw 'TA_BAD_PARAM';


	if (this.Settings.FastPeriod < this.Settings.SlowPeriod)
		slowestPeriod = this.Settings.SlowPeriod;
	else
		slowestPeriod = this.Settings.FastPeriod;


	lookbackTotal = TA.EMA._lookback(slowestPeriod);
	if (startIdx < lookbackTotal)
		startIdx = lookbackTotal;

	if (startIdx > endIdx) {
		return outReal;
	}

	today = startIdx - lookbackTotal;

	ad = 0.0;
	var CALCULATE_AD = '\
   { \
      high  = dataShape[today][TA.HIGH]; \
      low   = dataShape[today][TA.LOW]; \
      tmp   = high-low; \
      close = dataShape[today][TA.CLOSE]; \
      if( tmp > 0.0 ) \
         ad += (((close-low)-(high-close))/tmp)*(dataShape[today][TA.VOL]); \
      today++; \
   }';


	fastk = TA.PER_TO_K(this.Settings.FastPeriod);
	one_minus_fastk = 1.0 - fastk;

	slowk = TA.PER_TO_K(this.Settings.SlowPeriod);
	one_minus_slowk = 1.0 - slowk;


	eval(CALCULATE_AD);
	fastEMA = ad;
	slowEMA = ad;


	while (today < startIdx) {
		eval(CALCULATE_AD);
		fastEMA = (fastk * ad) + (one_minus_fastk * fastEMA);
		slowEMA = (slowk * ad) + (one_minus_slowk * slowEMA);
	}


	outIdx = 0;
	while (today <= endIdx) {
		eval(CALCULATE_AD);
		fastEMA = (fastk * ad) + (one_minus_fastk * fastEMA);
		slowEMA = (slowk * ad) + (one_minus_slowk * slowEMA);

		outReal[outIdx++] = fastEMA - slowEMA;
	}

	return outReal;
};

TA.ADOSC.getValue = function(dataShape, itemIdx, settings) {
	return NaN;
};

TA.ADOSC._lookback = function() {
	var slowestPeriod;

	if ( this.Settings.FastPeriod )
		this.Settings.FastPeriod = 3;
	else if (( this.Settings.FastPeriod < 2) || ( this.Settings.FastPeriod > 100000))
		return -1;


	if ( !this.Settings.SlowPeriod )
		this.Settings.SlowPeriod = 10;
	else if (( this.Settings.SlowPeriod < 2) || ( this.Settings.SlowPeriod > 100000))
		return -1;

	if (this.Settings.FastPeriod < this.Settings.SlowPeriod)
		slowestPeriod = this.Settings.SlowPeriod;
	else
		slowestPeriod = this.Settings.FastPeriod;


	return TA.EMA._lookback(slowestPeriod);
};

TA.ADOSC._S = function(startIdx, endIdx, dataShape, settings){
	return NaN;
};

TA.ADOSC.initChart = function (dataShape, hcOptions, ticker) {
	INDICATOR_TEMPLATE.initChart.apply(this, arguments);
	
	
};

TA.ADOSC.SetSettings(TA.ADOSC.DefaultSettings);

if (!!TA.INDICATOR_TEMPLATE)
    TA.ADX = TA.INDICATOR_TEMPLATE.Create();
else
    TA.ADX = {};

TA.ADX.name = 'ADX';
TA.ADX.type = 'line';

TA.ADX.DefaultSettings = {
	TimePeriod: 14
};

TA.ADX.Settings = {};

TA.ADX.calculate = function (startIdx, endIdx, dataShape, settings, dontFillTotalArray) {
	/* insert local variable here */
	var today, lookbackTotal, outIdx;
	var prevHigh, prevLow, prevClose;
	var prevMinusDM, prevPlusDM, prevTR;
	var tempReal, tempReal2, diffP, diffM;
	var minusDI, plusDI, sumDX, prevADX;

	var i;

	var outReal = [];

    this.SetSettings(settings);

	function TRUE_RANGE(TH, TL, YC, OUT) {
		return '\
      ' + OUT + ' = ' + TH + '-' + TL + '; \
      tempReal2 = Math.abs(' + TH + '-' + YC + '); \
      if( tempReal2 > ' + OUT + ' ) \
         ' + OUT + ' = tempReal2; \
      tempReal2 = Math.abs(' + TL + '-' + YC + '); \
      if( tempReal2 > ' + OUT + ' ) \
         ' + OUT + ' = tempReal2;';
	}

	if (!startIdx)
		startIdx = 0;

	if (!endIdx)
		endIdx = dataShape.length - 1;

	if (startIdx < 0)
		throw 'TA_OUT_OF_RANGE_START_INDEX';
	if ((endIdx < 0) || (endIdx < startIdx))
		throw 'TA_OUT_OF_RANGE_END_INDEX';

	if (!dataShape || !dataShape.length)
		throw 'TA_BAD_PARAM';



	if (!this.Settings.TimePeriod)
		this.Settings.TimePeriod = 14;
	else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
		throw 'TA_BAD_PARAM';


	/**** END GENCODE SECTION 4 - DO NOT DELETE THIS LINE ****/

	/* Insert TA function code here. */

	/* 
	 * The DM1 (one period) is base on the largest part of
	 * today's range that is outside of yesterdays range.
	 *
	 * The following 7 cases explain how the +DM and -DM are
	 * calculated on one period:
	 *
	 * Case 1:                       Case 2:
	 *    C|                        A|
	 *     |                         | C|
	 *     | +DM1 = (C-A)           B|  | +DM1 = 0
	 *     | -DM1 = 0                   | -DM1 = (B-D)
	 * A|  |                           D|
	 *  | D|
	 * B|
	 *
	 * Case 3:                       Case 4:
	 *    C|                           C|
	 *     |                        A|  |
	 *     | +DM1 = (C-A)            |  | +DM1 = 0
	 *     | -DM1 = 0               B|  | -DM1 = (B-D)
	 * A|  |                            |
	 *  |  |                           D|
	 * B|  |
	 *    D|
	 *
	 * Case 5:                      Case 6:
	 * A|                           A| C|
	 *  | C| +DM1 = 0                |  |  +DM1 = 0
	 *  |  | -DM1 = 0                |  |  -DM1 = 0
	 *  | D|                         |  |
	 * B|                           B| D|
	 *
	 *
	 * Case 7:
	 *
	 *    C|
	 * A|  |
	 *  |  | +DM=0
	 * B|  | -DM=0
	 *    D|
	 *
	 * In case 3 and 4, the rule is that the smallest delta between
	 * (C-A) and (B-D) determine which of +DM or -DM is zero.
	 *
	 * In case 7, (C-A) and (B-D) are equal, so both +DM and -DM are
	 * zero.
	 *
	 * The rules remain the same when A=B and C=D (when the highs
	 * equal the lows).
	 *
	 * When calculating the DM over a period > 1, the one-period DM
	 * for the desired period are initialy sum. In other word,
	 * for a -DM14, sum the -DM1 for the first 14 days (that's
	 * 13 values because there is no DM for the first day!)
	 * Subsequent DM are calculated using the Wilder's
	 * smoothing approach:
	 *
	 *                                    Previous -DM14
	 *  Today's -DM14 = Previous -DM14 -  -------------- + Today's -DM1
	 *                                         14
	 *
	 * (Same thing for +DM14)
	 *
	 * Calculation of a -DI14 is as follow:
	 *
	 *               -DM14
	 *     -DI14 =  --------
	 *                TR14
	 *
	 * (Same thing for +DI14)
	 *
	 * Calculation of the TR14 is:
	 *
	 *                                   Previous TR14
	 *    Today's TR14 = Previous TR14 - -------------- + Today's TR1
	 *                                         14
	 *
	 *    The first TR14 is the summation of the first 14 TR1. See the
	 *    TA_TRANGE function on how to calculate the true range.
	 *
	 * Calculation of the DX14 is:
	 *
	 *    diffDI = ABS( (-DI14) - (+DI14) )
	 *    sumDI  = (-DI14) + (+DI14)
	 *
	 *    DX14 = 100 * (diffDI / sumDI)
	 *
	 * Calculation of the first ADX:
	 *
	 *    ADX14 = SUM of the first 14 DX
	 *
	 * Calculation of subsequent ADX:
	 *
	 *            ((Previous ADX14)*(14-1))+ Today's DX
	 *    ADX14 = -------------------------------------
	 *                             14
	 *
	 * Reference:
	 *    New Concepts In Technical Trading Systems, J. Welles Wilder Jr
	 */

	/* Original implementation from Wilder's book was doing some integer
	 * rounding in its calculations.
	 *
	 * This was understandable in the context that at the time the book
	 * was written, most user were doing the calculation by hand.
	 *
	 * For a computer, rounding is unnecessary (and even problematic when inputs
	 * are close to 1).
	 *
	 * TA-Lib does not do the rounding. Still, if you want to reproduce Wilder's examples,
	 * you can comment out the following #undef/#define and rebuild the library.
	 */

	function round_pos(x) {
		return x;
	};

	lookbackTotal = (2 * this.Settings.TimePeriod) /*+ TA_GLOBALS_UNSTABLE_PERIOD(TA_FUNC_UNST_ADX, Adx)*/ - 1;

	/* Adjust startIdx to account for the lookback period. */
	if (startIdx < lookbackTotal)
		startIdx = lookbackTotal;

	/* Make sure there is still something to evaluate. */
	if (startIdx > endIdx) {
		return outReal;
	}

	/* Indicate where the next output should be put
	 * in the outReal.
	 */
	outIdx = 0;

	/* Process the initial DM and TR */

	prevMinusDM = 0.0;
	prevPlusDM = 0.0;
	prevTR = 0.0;
	today = startIdx - lookbackTotal;
	prevHigh = dataShape[today][TA.HIGH];
	prevLow = dataShape[today][TA.LOW];
	prevClose = dataShape[today][TA.CLOSE];
	i = this.Settings.TimePeriod - 1;
	while (i-- > 0) {
		/* Calculate the prevMinusDM and prevPlusDM */
		today++;
		tempReal = dataShape[today][TA.HIGH];
		diffP = tempReal - prevHigh; /* Plus Delta */
		prevHigh = tempReal;

		tempReal = dataShape[today][TA.LOW];
		diffM = prevLow - tempReal; /* Minus Delta */
		prevLow = tempReal;

		if ((diffM > 0) && (diffP < diffM)) {
			/* Case 2 and 4: +DM=0,-DM=diffM */
			prevMinusDM += diffM;
		} else if ((diffP > 0) && (diffP > diffM)) {
			/* Case 1 and 3: +DM=diffP,-DM=0 */
			prevPlusDM += diffP;
		}

		eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
		prevTR += tempReal;
		prevClose = dataShape[today][TA.CLOSE];
	}

	/* Add up all the initial DX. */
	sumDX = 0.0;
	i = this.Settings.TimePeriod;
	while (i-- > 0) {
		/* Calculate the prevMinusDM and prevPlusDM */
		today++;
		tempReal = dataShape[today][TA.HIGH];
		diffP = tempReal - prevHigh; /* Plus Delta */
		prevHigh = tempReal;

		tempReal = dataShape[today][TA.LOW];
		diffM = prevLow - tempReal; /* Minus Delta */
		prevLow = tempReal;

		prevMinusDM -= prevMinusDM / this.Settings.TimePeriod;
		prevPlusDM -= prevPlusDM / this.Settings.TimePeriod;

		if ((diffM > 0) && (diffP < diffM)) {
			/* Case 2 and 4: +DM=0,-DM=diffM */
			prevMinusDM += diffM;
		} else if ((diffP > 0) && (diffP > diffM)) {
			/* Case 1 and 3: +DM=diffP,-DM=0 */
			prevPlusDM += diffP;
		}

		/* Calculate the prevTR */
		eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
		prevTR = prevTR - (prevTR / this.Settings.TimePeriod) + tempReal;
		prevClose = dataShape[today][TA.CLOSE];

		/* Calculate the DX. The value is rounded (see Wilder book). */
		if (!TA.TA_IS_ZERO(prevTR)) {
			minusDI = round_pos(100.0 * (prevMinusDM / prevTR));
			plusDI = round_pos(100.0 * (prevPlusDM / prevTR));
			/* This loop is just to accumulate the initial DX */
			tempReal = minusDI + plusDI;
			if (!TA.TA_IS_ZERO(tempReal))
				sumDX += round_pos(100.0 * (Math.abs(minusDI - plusDI) / tempReal));
		}
	}

	/* Calculate the first ADX */
	prevADX = round_pos(sumDX / this.Settings.TimePeriod);

	/* Skip the unstable period */
	i = TA.TA_GLOBALS_UNSTABLE_PERIOD(TA.TA_FUNC_UNST_ADX);
	while (i-- > 0) {
		/* Calculate the prevMinusDM and prevPlusDM */
		today++;
		tempReal = dataShape[today][TA.HIGH];
		diffP = tempReal - prevHigh; /* Plus Delta */
		prevHigh = tempReal;

		tempReal = dataShape[today][TA.LOW];
		diffM = prevLow - tempReal; /* Minus Delta */
		prevLow = tempReal;

		prevMinusDM -= prevMinusDM / this.Settings.TimePeriod;
		prevPlusDM -= prevPlusDM / this.Settings.TimePeriod;

		if ((diffM > 0) && (diffP < diffM)) {
			/* Case 2 and 4: +DM=0,-DM=diffM */
			prevMinusDM += diffM;
		} else if ((diffP > 0) && (diffP > diffM)) {
			/* Case 1 and 3: +DM=diffP,-DM=0 */
			prevPlusDM += diffP;
		}

		/* Calculate the prevTR */
		eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
		prevTR = prevTR - (prevTR / this.Settings.TimePeriod) + tempReal;
		prevClose = dataShape[today][TA.CLOSE];

		if (!TA.TA_IS_ZERO(prevTR)) {
			/* Calculate the DX. The value is rounded (see Wilder book). */
			minusDI = round_pos(100.0 * (prevMinusDM / prevTR));
			plusDI = round_pos(100.0 * (prevPlusDM / prevTR));
			tempReal = minusDI + plusDI;
			if (!TA.TA_IS_ZERO(tempReal)) {
				tempReal = round_pos(100.0 * (Math.abs(minusDI - plusDI) / tempReal));
				/* Calculate the ADX */
				prevADX = round_pos(((prevADX * (this.Settings.TimePeriod - 1)) + tempReal) / this.Settings.TimePeriod);
			}
		}
	}

	/* Output the first ADX */
	outReal[0] = prevADX;
	outIdx = 1;

	/* Calculate and output subsequent ADX */
	while (today < endIdx) {
		/* Calculate the prevMinusDM and prevPlusDM */
		today++;
		tempReal = dataShape[today][TA.HIGH];
		diffP = tempReal - prevHigh; /* Plus Delta */
		prevHigh = tempReal;

		tempReal = dataShape[today][TA.LOW];
		diffM = prevLow - tempReal; /* Minus Delta */
		prevLow = tempReal;

		prevMinusDM -= prevMinusDM / this.Settings.TimePeriod;
		prevPlusDM -= prevPlusDM / this.Settings.TimePeriod;

		if ((diffM > 0) && (diffP < diffM)) {
			/* Case 2 and 4: +DM=0,-DM=diffM */
			prevMinusDM += diffM;
		} else if ((diffP > 0) && (diffP > diffM)) {
			/* Case 1 and 3: +DM=diffP,-DM=0 */
			prevPlusDM += diffP;
		}

		/* Calculate the prevTR */
		eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
		prevTR = prevTR - (prevTR / this.Settings.TimePeriod) + tempReal;
		prevClose = dataShape[today][TA.CLOSE];

		if (!TA.TA_IS_ZERO(prevTR)) {
			/* Calculate the DX. The value is rounded (see Wilder book). */
			minusDI = round_pos(100.0 * (prevMinusDM / prevTR));
			plusDI = round_pos(100.0 * (prevPlusDM / prevTR));
			tempReal = minusDI + plusDI;
			if (!TA.TA_IS_ZERO(tempReal)) {
				tempReal = round_pos(100.0 * (Math.abs(minusDI - plusDI) / tempReal));
				/* Calculate the ADX */
				prevADX = round_pos(((prevADX * (this.Settings.TimePeriod - 1)) + tempReal) / this.Settings.TimePeriod);
			}
		}

		/* Output the ADX */
		outReal[outIdx++] = prevADX;
	}

	//Приведение возврщаемого массива к общей длине
	if(!dontFillTotalArray) {
		if (outReal.length >= dataShape.length) {
			throw _t("", "Ошибка расчета ADX");
		} else if (outReal.length <= dataShape.length) {
			while (outReal.length != dataShape.length) {
				outReal.unshift(0);
			}
		}
	}
	
	return outReal;
};

TA.ADX.getValue = function(dataShape, itemIdx, settings) {
	
};

TA.ADX._lookback = function() {
	return (2 * this.Settings.TimePeriod) /*+ TA_GLOBALS_UNSTABLE_PERIOD(TA_FUNC_UNST_ADX,Adx)*/ - 1;
};

TA.ADX._S = function(startIdx, endIdx, dataShape, settings){
	
};

TA.ADX.initChart = function (dataShape, hcOptions, ticker) {
	TA.INDICATOR_TEMPLATE.initChart.apply(this, arguments);
};

TA.ADX.SetSettings(TA.ADX.DefaultSettings);

if (!!TA.INDICATOR_TEMPLATE)
    var APO = TA.INDICATOR_TEMPLATE.Create();
else
    var APO = {};

APO.name = 'APO';
APO.type = 'line';

APO.DefaultSettings = {
	FastPeriod: 12,
	SlowPeriod: 26,
	MAType: TA.MATypes.SMA,
	CandleValueIdx: TA.CLOSE
};

APO.Settings = {};

APO._S = function(startIdx, endIdx, dataShape, settings){
	
};

APO.initChart = function (dataShape, hcOptions, ticker) {
	if(!!INDICATOR_TEMPLATE)
		INDICATOR_TEMPLATE.initChart.apply(this, arguments);
	
	
};

APO.SetSettings(APO.DefaultSettings);

APO._lookback = function ( optInFastPeriod, optInSlowPeriod, optInMAType ) {

    if( !optInFastPeriod )
       optInFastPeriod = this.DefaultSettings.FastPeriod;
    else if( (optInFastPeriod < 2) || (optInFastPeriod > 100000) )
       return -1;
 
    /* min/max are checked for optInSlowPeriod. */
    if( !optInSlowPeriod )
       optInSlowPeriod = this.DefaultSettings.SlowPeriod;
    else if( (optInSlowPeriod < 2) || (optInSlowPeriod > 100000) )
       return -1;
 
    if( !optInMAType )
       optInMAType = this.DefaultSettings.MAType;
    else if( (optInMAType < 0) || (optInMAType > 8) )
       return -1;

   /* insert lookback code here. */

   /* The slow MA is the key factor determining the lookback period. */
   return MA._lookback( Math.max(optInSlowPeriod,optInFastPeriod), optInMAType );
}



 APO.calculate = function( startIdx, endIdx, dataShape, settings ) {
	 var tempBuffer = [],
		 outReal = [];
	 
 
	 if(!!settings)
		 this.SetSettings(settings);
	 
	 if(!startIdx)
		 startIdx = 0;
	 
	 if(!endIdx)
		 endIdx = dataShape.length - 1;
 
    /* Validate the requested output range. */
    if( startIdx < 0 )
       throw 'TA_OUT_OF_RANGE_START_INDEX';
    if( (endIdx < 0) || (endIdx < startIdx))
       throw 'TA_OUT_OF_RANGE_END_INDEX';
 
    if( !dataShape || !dataShape.length )
		throw 'TA_BAD_PARAM';

    /* min/max are checked for optInFastPeriod. */
    if( !this.Settings.FastPeriod )
       this.Settings.FastPeriod = this.DefaultSettings.FastPeriod;
    else if( (this.Settings.FastPeriod < 2) || (this.Settings.FastPeriod > 100000) )
       throw 'TA_BAD_PARAM';
 
    /* min/max are checked for optInSlowPeriod. */
    if( !this.Settings.SlowPeriod )
       this.Settings.SlowPeriod = this.DefaultSettings.SlowPeriod;
    else if( (this.Settings.SlowPeriod < 2) || (this.Settings.SlowPeriod > 100000) )
       throw 'TA_BAD_PARAM';
 
    if( this.Settings.MAType )
       this.Settings.MAType = this.DefaultSettings.MAType;
    else if( (this.Settings.MAType < 0) || (this.Settings.MAType > 8) )
       throw 'TA_BAD_PARAM';
 
    if( !outReal )
       throw 'TA_BAD_PARAM';
 


   outReal = this.INT_PO( startIdx, endIdx, dataShape,
                                    this.Settings.FastPeriod, 
                                    this.Settings.SlowPeriod, 
                                    this.Settings.MAType,
                                    outReal,
                                    tempBuffer,
                                    0 /* No percentage. */ );
	 
	return outReal;
};


APO.INT_PO  = function( startIdx, endIdx, dataShape, optInFastPeriod, optInSlowPeriod, optInMethod_2, outReal, tempBuffer, doPercentageOutput )
{
   var tempReal,
	   tempInteger,
	   outBegIdx1 = 0,
	   outNbElement1 = 0,
	   outBegIdx2 = 0,
	   outNbElement2 = 0,
	   i = 0, j = 0;

   /* Make sure slow is really slower than
    * the fast period! if not, swap...
    */
   if( optInSlowPeriod < optInFastPeriod )
   {
       /* swap */
       tempInteger     = optInSlowPeriod;
       optInSlowPeriod = optInFastPeriod;
       optInFastPeriod = tempInteger;
   }

	/* Calculate the fast MA into the tempBuffer. */

	var MA_local = MA.Create({TimePeriod: optInFastPeriod, MAType: optInMethod_2, CandleValueIdx: this.Settings.CandleValueIdx});
	tempBuffer = MA_local.calculate( startIdx, endIdx, dataShape);

   if( !!tempBuffer && !!tempBuffer.length )
   {
      /* Calculate the slow MA into the output. */
      outReal = MA_local.calculate( startIdx, endIdx, dataShape, {TimePeriod: optInSlowPeriod} );

      if( !!outReal && !!outReal.length )
      {
         tempInteger = (tempBuffer.length - 1) - (outReal.length - 1);
         if( doPercentageOutput != 0 )
         {
            /* Calculate ((fast MA)-(slow MA))/(slow MA) in the output. */   
            for( i=0,j=tempInteger; i < tempBuffer.length - 1; i++, j++ )
            {
               tempReal = outReal[i];
               if( !TA.TA_IS_ZERO(tempReal) )
                  outReal[i] = ((tempBuffer[j]-tempReal)/tempReal)*100.0;
               else
                  outReal[i] = 0.0;
            }
         }
         else
         {
            /* Calculate (fast MA)-(slow MA) in the output. */   
            for( i=0,j=tempInteger; i < tempBuffer.length - 1; i++, j++ )
               outReal[i] = tempBuffer[j]-outReal[i];
         }

         //VALUE_HANDLE_DEREF(outBegIdx)     = VALUE_HANDLE_GET(outBegIdx1);
         //VALUE_HANDLE_DEREF(outNBElement)  = VALUE_HANDLE_GET(outNbElement1);
      }
   }

   return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.AROON = TA.INDICATOR_TEMPLATE.Create();
else
    TA.AROON = {};

TA.AROON.name = 'AROON';
TA.AROON.type = 'line';

TA.AROON.DefaultSettings = {
	TimePeriod: 14
};

TA.AROON.Settings = {};

TA.AROON._S = function (startIdx, endIdx, dataShape, settings) {

};

TA.AROON.initChart = function (dataShape, hcOptions, ticker) {
	if (!!TA.INDICATOR_TEMPLATE)
		TA.INDICATOR_TEMPLATE.initChart.apply(this, arguments);
};

TA.AROON.SetSettings(TA.AROON.DefaultSettings);

TA.AROON.calculate = function (startIdx, endIdx, dataShape, settings) {
	var outAroonDown = [],
		outAroonUp = [],
		lowest, highest, tmp, factor,
		outIdx,
		trailingIdx, lowestIdx, highestIdx, today, i;

    this.SetSettings(settings);

	startIdx = startIdx || 0;
	endIdx = endIdx || dataShape.length - 1;

	if (startIdx < 0)
		throw 'TA_OUT_OF_RANGE_START_INDEX';
	if ((endIdx < 0) || (endIdx < startIdx))
		throw 'TA_OUT_OF_RANGE_END_INDEX';

	if (!dataShape || !dataShape.length)
		throw 'TA_BAD_PARAM';

	if (!this.Settings.TimePeriod)
		this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
	else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
		throw 'TA_BAD_PARAM';

	/* Insert TA function code here. */

	/* This function is using a speed optimized algorithm
	 * for the min/max logic.
	 *
	 * You might want to first look at how TA_MIN/TA_MAX works
	 * and this function will become easier to understand.
	 */

	/* Move up the start index if there is not
	 * enough initial data.
	 */
	if (startIdx < this.Settings.TimePeriod)
		startIdx = this.Settings.TimePeriod;

	/* Make sure there is still something to evaluate. */
	if (startIdx > endIdx) {
		return {AroonDown: outAroonDown, AroonUp: outAroonUp};
	}

	/* Proceed with the calculation for the requested range.
	 * Note that this algorithm allows the input and
	 * output to be the same buffer.
	 */
	outIdx = 0;
	today = startIdx;
	trailingIdx = startIdx - this.Settings.TimePeriod;
	lowestIdx = -1;
	highestIdx = -1;
	lowest = 0.0;
	highest = 0.0;
	factor = 100.0 / this.Settings.TimePeriod;

	while (today <= endIdx) {
		/* Keep track of the lowestIdx */
		tmp = dataShape[today][TA.LOW];
		if (lowestIdx < trailingIdx) {
			lowestIdx = trailingIdx;
			lowest = dataShape[lowestIdx][TA.LOW];
			i = lowestIdx;
			while (++i <= today) {
				tmp = dataShape[i][TA.LOW];
				if (tmp <= lowest) {
					lowestIdx = i;
					lowest = tmp;
				}
			}
		} else if (tmp <= lowest) {
			lowestIdx = today;
			lowest = tmp;
		}

		/* Keep track of the highestIdx */
		tmp = dataShape[today][TA.HIGH];
		if (highestIdx < trailingIdx) {
			highestIdx = trailingIdx;
			highest = dataShape[highestIdx][TA.HIGH];
			i = highestIdx;
			while (++i <= today) {
				tmp = dataShape[i][TA.HIGH];
				if (tmp >= highest) {
					highestIdx = i;
					highest = tmp;
				}
			}
		} else if (tmp >= highest) {
			highestIdx = today;
			highest = tmp;
		}

		/* Note: Do not forget that input and output buffer can be the same,
		 *       so writing to the output is the last thing being done here.
		 */
		outAroonUp[outIdx] = factor * (this.Settings.TimePeriod - (today - highestIdx));
		outAroonDown[outIdx] = factor * (this.Settings.TimePeriod - (today - lowestIdx));

		outIdx++;
		trailingIdx++;
		today++;
	}

	return {AroonDown: outAroonDown, AroonUp: outAroonUp};
};

TA.AROON.getValue = function (dataShape, itemIdx, settings) {

};

TA.AROON._lookback = function (optInTimePeriod) {

	if (!optInTimePeriod)
		optInTimePeriod = this.DefaultSettings.TimePeriod;
	else if ((optInTimePeriod < 2) || (optInTimePeriod > 100000))
		return -1;

	return optInTimePeriod;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.ATR = TA.INDICATOR_TEMPLATE.Create();
else
    TA.ATR = {};

TA.ATR.name = 'ATR';
TA.ATR.type = 'line';

TA.ATR.DefaultSettings = {
    TimePeriod: 14
};

TA.ATR.Settings = {};


TA.ATR._lookback = function(optInTimePeriod) {
    if (!optInTimePeriod)
        optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if ((optInTimePeriod < 1) || (optInTimePeriod > 100000))
        return -1;
    if (optInTimePeriod > 1)
        return optInTimePeriod;
    else
        return 1;
};


TA.ATR.calculate = function(startIdx, endIdx, dataShape, settings) {
    var outIdx, today, lookbackTotal,
        nbATR,
        prevATR,
        tempBuffer = [],
        prevATRTemp,
        outReal = [];

    this.SetSettings(settings);

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!this.Settings.TimePeriod)
        this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
    else if ((this.Settings.TimePeriod < 1) || (this.Settings.TimePeriod > 100000))
        throw 'TA_BAD_PARAM';

    lookbackTotal = this._lookback(this.Settings.TimePeriod);

    if (startIdx < lookbackTotal)
        startIdx = lookbackTotal;
    if (startIdx > endIdx)
        return outReal;
    if (this.Settings.TimePeriod <= 1) {
        return TA.TRANGE.calculate(startIdx, endIdx, dataShape, {});
    }

    tempBuffer = TA.TRANGE.calculate((startIdx - lookbackTotal + 1), endIdx, dataShape, {});

    if( !tempBuffer || !tempBuffer.length )
    {
        return outReal;
    }

    var tempBufferArr = [];
    for(var i=0;i<tempBuffer.length-1;i++){
        tempBufferArr.push([tempBuffer[i]]);
    }

    var prevATRTemp = TA.SMA.calculate( this.Settings.TimePeriod-1,
        this.Settings.TimePeriod-1,
        tempBufferArr, {TimePeriod: this.Settings.TimePeriod, CandleValueIdx: 0});

    if( !prevATRTemp || !prevATRTemp.length )
    {
        return outReal;
    }

    prevATR = prevATRTemp[0];

    today = this.Settings.TimePeriod;

    outIdx = 0;

    while (outIdx != 0) {
        prevATR *= this.Settings.TimePeriod - 1;
        prevATR += tempBuffer[today++];
        prevATR /= this.Settings.TimePeriod;
        outIdx--;
    }
    outIdx = 1;
    outReal[0] = prevATR;
    nbATR = (endIdx - startIdx) + 1;
    while (--nbATR != 0) {
        prevATR *= this.Settings.TimePeriod - 1;
        prevATR += tempBuffer[today++];
        prevATR /= this.Settings.TimePeriod;
        outReal[outIdx++] = prevATR;
    }
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.BBANDS = TA.INDICATOR_TEMPLATE.Create();
else
	TA.BBANDS = {};

TA.BBANDS.name = 'BBANDS';
TA.BBANDS.type = 'line';

TA.BBANDS.DefaultSettings = {
	TimePeriod:		7,
	DeviationsUp:	2,
	DeviationsDown:	2,
	MAType:			TA.MATypes.SMA,
	CandleValueIdx: TA.CLOSE
};

TA.BBANDS.Settings = {};

TA.BBANDS.calculate = function (startIdx, endIdx, dataShape, settings) {

	var i;
	var tempReal, tempReal2;
	var tempBuffer1 = [];
	var tempBuffer2 = [];

	var outRealUpperBand = [];
	var outRealMiddleBand = [];
	var outRealLowerBand = [];
	
	var outNBElement;

    this.SetSettings(settings);

	if (!startIdx)
		startIdx = 0;

	if (!endIdx)
		endIdx = dataShape.length - 1;

	if (startIdx < 0)
		throw 'TA_OUT_OF_RANGE_START_INDEX';
	if ((endIdx < 0) || (endIdx < startIdx))
		throw 'TA_OUT_OF_RANGE_END_INDEX';


	if (!dataShape || !dataShape.length)
		throw 'TA_BAD_PARAM';

	if (!this.Settings.TimePeriod)
		this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
	else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
		throw 'TA_BAD_PARAM';

	if (!this.Settings.DeviationsUp)
		this.Settings.DeviationsUp = this.DefaultSettings.DeviationsUp;
	else if ((this.Settings.DeviationsUp < -3.000000e+37) || (this.Settings.DeviationsUp > 3.000000e+37))
		throw 'TA_BAD_PARAM';

	if (!this.Settings.DeviationsDown)
		this.Settings.DeviationsDown = this.DefaultSettings.DeviationsDown;
	else if ((this.Settings.DeviationsDown < -3.000000e+37) || (this.Settings.DeviationsDown > 3.000000e+37))
		throw 'TA_BAD_PARAM';

	if (this.Settings.MAType)
		this.Settings.MAType = this.DefaultSettings.MAType;
	else if ((this.Settings.MAType < 0) || (this.Settings.MAType > 8))
		throw 'TA_BAD_PARAM';

	if (!outRealUpperBand)
		throw 'TA_BAD_PARAM';

	if (!outRealMiddleBand)
		throw 'TA_BAD_PARAM';

	if (!outRealLowerBand)
		throw 'TA_BAD_PARAM';

	tempBuffer1 = outRealMiddleBand;
	tempBuffer2 = outRealUpperBand;

	/* Calculate the middle band, which is a moving average.
	 * The other two bands will simply add/substract the
	 * standard deviation from this middle band.
	 */

	var localMA = TA.MA.Create({TimePeriod: this.Settings.TimePeriod, MAType: this.Settings.MAType});
	tempBuffer1 = localMA.calculate(startIdx, endIdx, dataShape, {TimePeriod: this.Settings.TimePeriod, MAType: this.Settings.MAType});

	if (!tempBuffer1 || !tempBuffer1.length) {
		return {UpperBand: [], LowerBand: [], MiddleBand: []};
	}

	
	/* Calculate the Standard Deviation */
	var localSTDDEV = TA.STDDEV.Create({TimePeriod: this.Settings.TimePeriod, Deviations: 1});

	tempBuffer2 = localSTDDEV.calculate(startIdx, endIdx, dataShape, {TimePeriod: this.Settings.TimePeriod, Deviations: 1});

	if ( !tempBuffer2 || !tempBuffer2.length ) {
		return {UpperBand: [], LowerBand: [], MiddleBand: []};
	}

	/* Copy the MA calculation into the middle band ouput, unless
	 * the calculation was done into it already!
	 */
	outRealMiddleBand = tempBuffer1.slice();

	//outNBElement = outRealMiddleBand.length - 1;
	outNBElement = outRealMiddleBand.length;
	/* Now do a tight loop to calculate the upper/lower band at
	 * the same time.
	 *
	 * All the following 5 loops are doing the same, except there
	 * is an attempt to speed optimize by eliminating uneeded
	 * multiplication.
	 */
	if (this.Settings.DeviationsUp == this.Settings.DeviationsDown) {
		if (this.Settings.DeviationsUp == 1.0) {
			/* No standard deviation multiplier needed. */
			for (i = 0; i < outNBElement; i++) {
				tempReal			= tempBuffer2[i];
				tempReal2			= outRealMiddleBand[i];
				outRealUpperBand[i] = tempReal2 + tempReal;
				outRealLowerBand[i] = tempReal2 - tempReal;
			}
		} else {
			/* Upper/lower band use the same standard deviation multiplier. */
			for (i = 0; i < outNBElement; i++) {
				tempReal = tempBuffer2[i] * this.Settings.DeviationsUp;
				tempReal2 = outRealMiddleBand[i];
				outRealUpperBand[i] = tempReal2 + tempReal;
				outRealLowerBand[i] = tempReal2 - tempReal;
			}
		}
	} else if (this.Settings.DeviationsUp == 1.0) {
		/* Only lower band has a standard deviation multiplier. */
		for (i = 0; i < outNBElement; i++) {
			tempReal = tempBuffer2[i];
			tempReal2 = outRealMiddleBand[i];
			outRealUpperBand[i] = tempReal2 + tempReal;
			outRealLowerBand[i] = tempReal2 - (tempReal * this.Settings.DeviationsDown);
		}
	} else if (this.Settings.DeviationsDown == 1.0) {
		/* Only upper band has a standard deviation multiplier. */
		for (i = 0; i < outNBElement; i++) {
			tempReal = tempBuffer2[i];
			tempReal2 = outRealMiddleBand[i];
			outRealLowerBand[i] = tempReal2 - tempReal;
			outRealUpperBand[i] = tempReal2 + (tempReal * this.Settings.DeviationsUp);
		}
	} else {
		/* Upper/lower band have distinctive standard deviation multiplier. */
		for (i = 0; i < outNBElement; i++) {
			tempReal = tempBuffer2[i];
			tempReal2 = outRealMiddleBand[i];
			outRealUpperBand[i] = tempReal2 + (tempReal * this.Settings.DeviationsUp);
			outRealLowerBand[i] = tempReal2 - (tempReal * this.Settings.DeviationsDown);
		}
	}

	return {UpperBand: outRealUpperBand, LowerBand: outRealLowerBand, MiddleBand: outRealMiddleBand};
};

TA.BBANDS.getValue = function(dataShape, itemIdx, settings) {
	
};

TA.BBANDS._lookback = function( optInTimePeriod, optInNbDevUp, optInNbDevDn, optInMAType ) {
    if( !optInTimePeriod )
       optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if( (optInTimePeriod < 2) || (optInTimePeriod > 100000) )
       return -1;
 
    if( !optInNbDevUp )
       optInNbDevUp = this.DefaultSettings.DeviationsUp;
    else if( (optInNbDevUp < -3.000000e+37) ||  (optInNbDevUp > 3.000000e+37) )
       return -1;
 
    if( !optInNbDevDn )
       optInNbDevDn = this.DefaultSettings.DeviationsDown;
    else if( (optInNbDevDn < -3.000000e+37) ||  (optInNbDevDn > 3.000000e+37) )
       return -1;
 
    if( !optInMAType)
       optInMAType = this.DefaultSettings.MAType;
    else if( (optInMAType < 0) || (optInMAType > 8) )
       return -1;

	return TA.MA._lookback( optInTimePeriod, optInMAType );
};

TA.BBANDS.SetSettings(TA.BBANDS.DefaultSettings);

if (!!TA.INDICATOR_TEMPLATE)
    TA.CCI = TA.INDICATOR_TEMPLATE.Create();
else
    TA.CCI = {};

TA.CCI.name = 'CCI';
TA.CCI.type = 'line';

TA.CCI.DefaultSettings = {
	TimePeriod: 14
};

TA.CCI.Settings = {};

TA.CCI.calculate = function (startIdx, endIdx, dataShape, settings) {
	var tempReal, tempReal2, theAverage, lastValue,
		i, j, outIdx, lookbackTotal;

    this.SetSettings(settings);

	//	#define CIRCBUF_PROLOG(Id,Type,Size) Type local_##Id[Size]; \
	//                                  int Id##_Idx; \
	//                                  Type *Id; \
	//                                  int maxIdx_##Id

	//	CIRCBUF_PROLOG(circBuffer,double,30);
	var local_circBuffer = new Array(30),
		circBuffer_Idx, circBuffer, maxIdx_circBuffer;

	var outReal = [];

	if (!startIdx)
		startIdx = 0;

	if (!endIdx)
		endIdx = dataShape.length - 1;

	if (startIdx < 0)
		throw 'TA_OUT_OF_RANGE_START_INDEX';
	if ((endIdx < 0) || (endIdx < startIdx))
		throw 'TA_OUT_OF_RANGE_END_INDEX';

	if (!dataShape || !dataShape.length)
		throw 'TA_BAD_PARAM';

	if (!this.Settings.TimePeriod)
		this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
	else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
		throw 'TA_BAD_PARAM';

	if (!outReal)
		throw 'TA_BAD_PARAM';

	/* Insert TA function code here. */

	/* Identify the minimum number of price bar needed
	 * to calculate at least one output.
	 */
	lookbackTotal = (this.Settings.TimePeriod - 1);

	/* Move up the start index if there is not
	 * enough initial data.
	 */
	if (startIdx < lookbackTotal)
		startIdx = lookbackTotal;

	/* Make sure there is still something to evaluate. */
	if (startIdx > endIdx) {
		return outReal;
	}

	/* Allocate a circular buffer equal to the requested
	 * period.
	 */
	//   CIRCBUF_INIT( circBuffer, double, optInTimePeriod );
	//	#define CIRCBUF_INIT(Id,Type,Size) \
	//   { \
	//      if( Size < 1 ) \
	//         return TA_INTERNAL_ERROR(137); \
	//      if( (int)Size > (int)(sizeof(local_##Id)/sizeof(Type)) ) \
	//      { \
	//         Id = TA_Malloc( sizeof(Type)*Size ); \
	//         if( !Id ) \
	//            return TA_ALLOC_ERR; \
	//      } \
	//      else \
	//         Id = &local_##Id[0]; \
	//      maxIdx_##Id = (Size-1); \
	//      Id##_Idx = 0; \
	//   }


	circBuffer = [];
	//local_circBuffer[0];
	maxIdx_circBuffer = (this.Settings.TimePeriod - 1);
	circBuffer_Idx = 0;


	/* Do the MA calculation using tight loops. */

	/* Add-up the initial period, except for the last value. 
	 * Fill up the circular buffer at the same time.
	 */
	i = startIdx - lookbackTotal;
	if (this.Settings.TimePeriod > 1) {
		while (i < startIdx) {
			circBuffer[circBuffer_Idx] = (dataShape[i][TA.HIGH] + dataShape[i][TA.LOW] + dataShape[i][TA.CLOSE]) / 3;
			i++;

			circBuffer_Idx++;
			if (circBuffer_Idx > maxIdx_circBuffer)
				circBuffer_Idx = 0;
		}
	}

	/* Proceed with the calculation for the requested range.
	 * Note that this algorithm allows the inReal and
	 * outReal to be the same buffer.
	 */
	outIdx = 0;
	do {
		lastValue = (dataShape[i][TA.HIGH] + dataShape[i][TA.LOW] + dataShape[i][TA.CLOSE]) / 3;
		circBuffer[circBuffer_Idx] = lastValue;

		/* Calculate the average for the whole period. */
		theAverage = 0;
		for (j = 0; j < this.Settings.TimePeriod; j++)
			theAverage += circBuffer[j];
		theAverage /= this.Settings.TimePeriod;

		/* Do the summation of the ABS(TypePrice-average)
		 * for the whole period.
		 */
		tempReal2 = 0;
		for (j = 0; j < this.Settings.TimePeriod; j++)
			tempReal2 += Math.abs(circBuffer[j] - theAverage);

		/* And finally, the CCI... */
		tempReal = lastValue - theAverage;

		if ((tempReal != 0.0) && (tempReal2 != 0.0)) {
			outReal[outIdx++] = tempReal / (0.015 * (tempReal2 / this.Settings.TimePeriod));
		} else
			outReal[outIdx++] = 0.0;

		/* Move forward the circular buffer indexes. */
		circBuffer_Idx++;
		if (circBuffer_Idx > maxIdx_circBuffer)
			circBuffer_Idx = 0;

		i++;
	} while (i <= endIdx);

	return outReal;

};

TA.CCI.getValue = function(dataShape, itemIdx, settings) {
	
};

TA.CCI._lookback = function(optInTimePeriod) {
 	if( !optInTimePeriod )
       optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if( (optInTimePeriod < 2) || (optInTimePeriod > 100000) )
       return -1;
	
   return (optInTimePeriod-1);	
};

TA.CCI._S = function(startIdx, endIdx, dataShape, settings){
	
};

TA.CCI.initChart = function (dataShape, hcOptions, ticker) {
	if(!!TA.INDICATOR_TEMPLATE)
		TA.INDICATOR_TEMPLATE.initChart.apply(this, arguments);
	
	
};

TA.CCI.SetSettings(TA.CCI.DefaultSettings);


if (!!TA.INDICATOR_TEMPLATE)
    TA.CHV = TA.INDICATOR_TEMPLATE.Create();
else
    TA.CHV = {};

TA.CHV.name = 'CHV';
TA.CHV.type = 'line';

TA.CHV.DefaultSettings = {
    TimePeriod: 10,
    TimePeriodRoc: 10,
    CandleValueIdx: TA.CLOSE
};

TA.CHV.Settings = {};

TA.CHV.calculate = function(startIdx, endIdx, dataShape, settings){

    var outReal = [];
    var output = [];
    this.SetSettings(settings);

    for (var i = startIdx; i <= endIdx; ++i)
    {
        output[i] = [dataShape[i][TA.HIGH] - dataShape[i][TA.LOW]];
    }

    var localEMA = TA.EMA.Create({TimePeriod: this.Settings.TimePeriod, CandleValueIdx: 0});
    var tempArr = localEMA.calculate(startIdx, endIdx, output, {TimePeriod: this.Settings.TimePeriod, CandleValueIdx: 0});
    var outputCount = tempArr.length - this.Settings.TimePeriodRoc;

    for (var i = 0; i < outputCount; i++)
    {
        outReal[i] = 100 * (tempArr[i + this.Settings.TimePeriodRoc] - tempArr[i]) / tempArr[i];
    }

    return outReal;
};


TA.CHV._lookback = function(optInTimePeriod) {
    return TA.EMA._lookback(optInTimePeriod) + this.Settings.TimePeriodRoc;
};


if (!!TA.INDICATOR_TEMPLATE)
    TA.DPO = TA.INDICATOR_TEMPLATE.Create();
else
    TA.DPO = {};

TA.DPO.name = 'DPO';
TA.DPO.type = 'line';

TA.DPO.DefaultSettings = {
    TimePeriod: 20,
    CandleValueIdx: TA.CLOSE
};

TA.DPO.Settings = {};

TA.DPO.calculate = function(startIdx, endIdx, dataShape, settings){

    var outReal = [];
    this.SetSettings(settings);

    var localSMA = TA.SMA.Create({TimePeriod: this.Settings.TimePeriod});
    var tempArr = localSMA.calculate(startIdx, endIdx, dataShape, {TimePeriod: this.Settings.TimePeriod, CandleValueIdx: TA.CLOSE});

    var period = this.Settings.TimePeriod;
    var outputOffset = TA.SMA._lookback(period);
    var shift = ((period / 2) | 0) + 1;
    outputOffset += shift;

    for (var i = endIdx - outputOffset; i >= 0; --i)
    {
        outReal[i] = dataShape[i + outputOffset][TA.CLOSE] - tempArr[i];
    }

    return outReal;
};


TA.DPO._lookback = function(optInTimePeriod) {
    return TA.SMA._lookback(optInTimePeriod) + ((optInTimePeriod / 2) | 0) + 1;
};


if (!!TA.INDICATOR_TEMPLATE)
    TA.ELDR = TA.INDICATOR_TEMPLATE.Create();
else
    TA.ELDR = {};

TA.ELDR.name = 'ELDR';
TA.ELDR.type = 'line';

TA.ELDR.DefaultSettings = {
    TimePeriod: 13,
    MAType: TA.MATypes.EMA
};

TA.ELDR.Settings = {};

TA.ELDR._lookback = function(TimePeriod, MAType) {
    if( !TimePeriod )
        TimePeriod = this.DefaultSettings.TimePeriod;
    else if( (TimePeriod < 1) || (TimePeriod > 100000) )
        return -1;

    if( !MAType)
        MAType = this.DefaultSettings.MAType;
    else if( (MAType < 0) || (MAType > 8) )
        return -1;

    return TA.MA._lookback( TimePeriod, MAType );
};

TA.ELDR.calculate = function(startIdx, endIdx, dataShape, settings) {
    var EMA = [],
        Bulls = [],
        Bears = [],
        ELDR = [],
        Signal = [],
        Smooth = [],
        tempBuffer = [],
        SmoothPeriod = 2;

    this.SetSettings(settings);

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!dataShape || !dataShape.length) throw 'TA_BAD_PARAM';
    if (!this.Settings.TimePeriod)
        this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
    else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
        throw 'TA_BAD_PARAM';

    lookbackTotal = TA.EMA._lookback(this.Settings.TimePeriod);

    var localMA = TA.MA.Create({TimePeriod: this.Settings.TimePeriod, MAType: this.Settings.MAType});
    EMA = localMA.calculate(startIdx, endIdx, dataShape, {TimePeriod: this.Settings.TimePeriod, MAType: this.Settings.MAType, CandleValueIdx: TA.CLOSE});

    for(var i=0; i < EMA.length; i++) {
        Bulls[i] = dataShape[i+lookbackTotal][TA.HIGH] - EMA[i];
        Bears[i] = dataShape[i+lookbackTotal][TA.LOW] - EMA[i];
        ELDR[i] = ((dataShape[i+lookbackTotal][TA.HIGH] + dataShape[i+lookbackTotal][TA.LOW]) / 2) - EMA[i];
    }

    ELDR.forEach(function(n,i){tempBuffer[i] = [n]});

    var localMA = TA.MA.Create({TimePeriod: this.Settings.TimePeriod, MAType: this.Settings.MAType});
    Signal = localMA.calculate(0, tempBuffer.length-1, tempBuffer, {TimePeriod: this.Settings.TimePeriod, MAType: this.Settings.MAType, CandleValueIdx: 0});

    for (var i=0; i<this.Settings.TimePeriod-1; i++) {
        Signal.splice(0,0,0);
    }

    var localMA = TA.MA.Create({TimePeriod: this.Settings.TimePeriod, MAType: this.Settings.MAType});
    Smooth = localMA.calculate(0, tempBuffer.length-1, tempBuffer, {TimePeriod: SmoothPeriod, MAType: this.Settings.MAType, CandleValueIdx: 0});

    for (var i=0; i<SmoothPeriod-1; i++) {
        Smooth.splice(0,0,0);
    }

    return {"ELDR": ELDR, "Signal": Signal, "Smooth": Smooth, "EMA": EMA};
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.EMA = TA.INDICATOR_TEMPLATE.Create();
else
    TA.EMA = {};

TA.EMA.name = 'EMA';
TA.EMA.type = 'line';

TA.EMA.DefaultSettings = {
    TimePeriod: 30,
    CandleValueIdx: TA.CLOSE
};

TA.EMA.Settings = {};

TA.EMA.calculate = function(startIdx, endIdx, dataShape, settings){
     
    var outReal = [];
    
    this.SetSettings(settings);

    if (!startIdx)
        startIdx = 0;

    if (!endIdx)
        endIdx = dataShape.length - 1;

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';

    if (!dataShape || !dataShape.length)
        throw 'TA_BAD_PARAM';

    if (!this.Settings.TimePeriod)
        this.Settings.TimePeriod = 30;
    else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
        throw 'TA_BAD_PARAM';

    return this._int_ema(startIdx, endIdx, dataShape,
        this.Settings.TimePeriod,
        TA.PER_TO_K(this.Settings.TimePeriod),
        outReal);
};

TA.EMA._int_ema = function ( startIdx, endIdx, dataShape, optInTimePeriod, optInK_1, outReal ) {
   var tempReal, prevMA;
   var i, today, outIdx, lookbackTotal;

   /* Ususally, optInK_1 = 2 / (optInTimePeriod + 1),
    * but sometime there is exception. This
    * is why both value are parameters.
    */

   /* Identify the minimum number of price bar needed
    * to calculate at least one output.
    */
   lookbackTotal = this._lookback( optInTimePeriod );

   /* Move up the start index if there is not
    * enough initial data.
    */
   if( startIdx < lookbackTotal )
      startIdx = lookbackTotal;

   /* Make sure there is still something to evaluate. */
   if( startIdx > endIdx )
   {
      return outReal;
   }

   /* Do the EMA calculation using tight loops. */
   
   /* The first EMA is calculated differently. It
    * then become the seed for subsequent TA.EMA.
    *
    * The algorithm for this seed vary widely.
    * Only 3 are implemented here:
    *
    * TA_MA_CLASSIC:
    *    Use a simple MA of the first 'period'.
    *    This is the approach most widely documented.
    *
    * TA_MA_METASTOCK:
    *    Use first price bar value as a seed
    *    from the begining of all the available
    *    data.
    *
    * TA_MA_TRADESTATION:
    *    Use 4th price bar as a seed, except when
    *    period is 1 who use 2th price bar or something
    *    like that... (not an obvious one...).
    */
   if( TA.TA_GLOBALS_COMPATIBILITY == TA.TA_COMPATIBILITY_DEFAULT )
   {
      today = startIdx-lookbackTotal;
      i = optInTimePeriod;
      tempReal = 0.0;
      while( i-- > 0 )
         tempReal += dataShape[today++][this.Settings.CandleValueIdx];

      prevMA = tempReal / optInTimePeriod;
   }
   else
   {
      prevMA = dataShape[0][this.Settings.CandleValueIdx];
      today = 1;

      /* !!! Tradestation not supported yet.
      case TA_MA_TRADESTATION:
         prevMA = inReal[startIdx-1];
         if( optInTimePeriod == 1 )
            VALUE_HANDLE_DEREF(outBegIdx)_0 = 1;
         else
            VALUE_HANDLE_DEREF(outBegIdx)_0 = 3;
       */
   }

   /* At this point, prevMA is the first EMA (the seed for
    * the rest).
    * 'today' keep track of where the processing is within the
    * input.
    */

   /* Skip the unstable period. Do the processing 
    * but do not write it in the output.
    */   
   while( today <= startIdx )
      prevMA = ((dataShape[today++][this.Settings.CandleValueIdx]-prevMA)*optInK_1) + prevMA;

   /* Write the first value. */
   outReal[0] = prevMA;
   outIdx = 1;

   /* Calculate the remaining range. */
   while( today <= endIdx ) {
      prevMA = ((dataShape[today++][this.Settings.CandleValueIdx]-prevMA)*optInK_1) + prevMA;
      outReal[outIdx++] = prevMA;
   }

   return outReal;
};

TA.EMA.getValue = function(dataShape, itemIdx, settings) {
    
};

TA.EMA._lookback = function(optInTimePeriod) {
    if ( !optInTimePeriod )
        optInTimePeriod = this.Settings.TimePeriod || this.DefaultSettings.TimePeriod;
    else if (( optInTimePeriod < 2) || ( optInTimePeriod > 100000))
        return -1;


    return optInTimePeriod - 1; // + TA_GLOBALS_UNSTABLE_PERIOD(TA_FUNC_UNST_EMA, Ema);
};

TA.EMA._S = function(startIdx, endIdx, dataShape, settings) {
    var tempReal, prevMA;
    var i, today, outIdx, lookbackTotal;

    lookbackTotal = this._lookback(this.Settings.TimePeriod);
    if (startIdx < lookbackTotal)
        startIdx = lookbackTotal;
    if (startIdx > endIdx) {
        return outReal;
    }
    
    if (TA_GLOBALS_COMPATIBILITY == TA_COMPATIBILITY_DEFAULT) {
        today = startIdx - lookbackTotal;
        i = this.Settings.TimePeriod;
        tempReal = 0.0;
        while (i-- > 0)
            tempReal += dataShape[today++][this.Settings.CandleValueIdx];
        prevMA = tempReal / this.Settings.TimePeriod;
    } else {
        prevMA = dataShape[0][this.Settings.CandleValueIdx];
        today = 1;
    }
    while (today <= startIdx)
        prevMA = ((dataShape[today++][this.Settings.CandleValueIdx] - prevMA) * optInK_1) + prevMA;
    outReal[0] = prevMA;
    outIdx = 1;
    while (today <= endIdx) {
        prevMA = ((inReal[today++] - prevMA) * optInK_1) + prevMA;
        outReal[outIdx++] = prevMA;
    }
    
    return outReal;
};

TA.EMA.initChart = function (dataShape, hcOptions, ticker) {
    INDICATOR_TEMPLATE.initChart.apply(this, arguments);
    
    
};

TA.EMA.SetSettings(TA.EMA.DefaultSettings);

if (!!TA.INDICATOR_TEMPLATE)
    TA.ENV = TA.INDICATOR_TEMPLATE.Create();
else
    TA.ENV = {};

TA.ENV.name = 'ENV';
TA.ENV.type = 'line';

TA.ENV.DefaultSettings = {
    TimePeriod: 20,
    shift: 1,
    CandleValueIdx: TA.CLOSE
};

TA.ENV.Settings = {};

TA.ENV.calculate = function(startIdx, endIdx, dataShape, settings){

    var outputLower = [];
    var outputUpper = [];
    this.SetSettings(settings);

    var localSMA = TA.SMA.Create({TimePeriod: this.Settings.TimePeriod});
    var tempArr = localSMA.calculate(startIdx, endIdx, dataShape, {TimePeriod: this.Settings.TimePeriod, CandleValueIdx: TA.CLOSE});

    var multiplierUpper = 1 + (this.Settings.shift / 100);
    var multiplierLower = 1 - (this.Settings.shift / 100);
    for (var i = 0; i < tempArr.length; i++)
    {
        outputLower[i] = tempArr[i] * multiplierLower;
        outputUpper[i] = tempArr[i] * multiplierUpper;
    }

    return {Lower: outputLower, Upper: outputUpper};
};


TA.ENV._lookback = function(optInTimePeriod) {
    return TA.SMA._lookback(optInTimePeriod);
};


if (!!TA.INDICATOR_TEMPLATE)
    TA.MA = TA.INDICATOR_TEMPLATE.Create();
else
    TA.MA = {};

TA.MA.name = 'MA';
TA.MA.type = 'line';

TA.MA.DefaultSettings = {
	TimePeriod: 30,
	CandleValueIdx: TA.CLOSE,
	MAType: TA.MATypes.SMA
};

TA.MA.Settings = {};

TA.MA.calculate = function (startIdx, endIdx, dataShape, settings) {
	
	this.SetSettings(settings);

	var dummyBuffer = [];
	//ENUM_DECLARATION(RetCode) retCode;

	var outIdx, todayIdx;
	var outReal = [];

	if (startIdx < 0)
		throw 'TA_OUT_OF_RANGE_START_INDEX';
	if ((endIdx < 0) || (endIdx < startIdx))
		throw 'TA_OUT_OF_RANGE_END_INDEX';


	if (!dataShape || !dataShape.length)
		throw 'TA_BAD_PARAM';


	if (!this.Settings.TimePeriod)
		this.Settings.TimePeriod = 30;
	else if ((this.Settings.TimePeriod < 1) || (this.Settings.TimePeriod > 100000))
		throw 'TA_BAD_PARAM';

	if (!this.Settings.MAType)
		this.Settings.MAType = TA.MATypes.SMA;
	else if ((this.Settings.MAType < 0) || (this.Settings.MAType > 8))
		throw 'TA_BAD_PARAM';

	if (this.Settings.TimePeriod == 1) {
		nbElement = endIdx - startIdx + 1;
		for (todayIdx = startIdx, outIdx = 0; outIdx < nbElement; outIdx++, todayIdx++)
			outReal[outIdx] = dataShape[todayIdx][this.Settings.CandleValueIdx];

		return outReal;
	}
	/* Simply forward the job to the corresponding TA function. */
	switch (this.Settings.MAType) {
	case TA.MATypes.SMA:
		outReal = TA.SMA.calculate(startIdx, endIdx, dataShape, this.Settings);
		break;

	case TA.MATypes.EMA:
		outReal = TA.EMA.calculate(startIdx, endIdx, dataShape, this.Settings);
		break;

	case TA.MATypes.WMA:
		outReal = TA.WMA.calculate(startIdx, endIdx, dataShape, this.Settings);
		break;

	case TA.MATypes.DEMA:
		outReal = DEMA.calculate(startIdx, endIdx, dataShape, this.Settings);
		break;

	case TA.MATypes.TEMA:
		outReal = TEMA.calculate(startIdx, endIdx, dataShape, this.Settings);
		break;

	case TA.MATypes.TRIMA:
		outReal = TRIMA.calculate(startIdx, endIdx, dataShape, this.Settings);
		break;

	case TA.MATypes.KAMA:
		outReal = KAMA.calculate(startIdx, endIdx, dataShape, this.Settings);
		break;

	case TA.MATypes.MAMA:
		/* The optInTimePeriod is ignored and the FAMA output of the MAMA
		 * is ignored.
		 */
		/*ARRAY_ALLOC(dummyBuffer, (endIdx - startIdx + 1));


		if (!dummyBuffer)
			return ENUM_VALUE(RetCode, TA_ALLOC_ERR, AllocErr);*/


		outReal = MAMA.calculate(startIdx, endIdx, dataShape, {FastLimit: 0.5, SlowLimit: 0.05});
		break;

	case TA.MATypes.T3:
		outReal = T3.calculate(startIdx, endIdx, dataShape, {TimePeriod: this.Settings.TimePeriod, VFactor: 0.7});
		break;

	default:
		throw 'TA_BAD_PARAM';
		break;
	}

	return outReal;
};

TA.MA.getValue = function(dataShape, itemIdx, settings) {
	
};

TA.MA._lookback = function (optInTimePeriod, optInMAType) {
	var retValue;

	if (!optInTimePeriod)
		optInTimePeriod = this.DefaultSettings.TimePeriod;
	else if ((optInTimePeriod < 1) || (optInTimePeriod > 100000))
		return -1;

	if (!optInMAType)
		optInMAType = this.DefaultSettings.MAType;
	else if ((optInMAType < 0) || (optInMAType > 8))
		return -1;

	if (optInTimePeriod <= 1)
		return 0;

	switch (optInMAType) {
	case TA.MATypes.SMA:
		retValue = TA.SMA._lookback(optInTimePeriod);
		break;

	case TA.MATypes.EMA:
		retValue = TA.EMA._lookback(optInTimePeriod);
		break;

	case TA.MATypes.WMA:
		retValue = TA.WMA._lookback(optInTimePeriod);
		break;

	case TA.MATypes.DEMA:
		retValue = DEMA._lookback(optInTimePeriod);
		break;

	case TA.MATypes.TEMA:
		retValue = TEMA._lookback(optInTimePeriod);
		break;

	case TA.MATypes.TRIMA:
		retValue = TRIMA._lookback(optInTimePeriod);
		break;

	case TA.MATypes.KAMA:
		retValue = KAMA._lookback(optInTimePeriod);
		break;

	case TA.MATypes.MAMA:
		retValue = MAMA._lookback(0.5, 0.05);
		break;

	case TA.MATypes.T3:
		retValue = T3._lookback(optInTimePeriod, 0.7);
		break;

	default:
		retValue = 0;
	}

	return retValue;
};

TA.MA._S = function(startIdx, endIdx, dataShape, settings){
	
};

TA.MA.initChart = function (dataShape, hcOptions, ticker) {
	if(!!INDICATOR_TEMPLATE)
		INDICATOR_TEMPLATE.initChart.apply(this, arguments);
	
	
};

TA.MA.SetSettings(TA.MA.DefaultSettings);

if (!!TA.INDICATOR_TEMPLATE)
    TA.MACD = TA.INDICATOR_TEMPLATE.Create();
else
    TA.MACD = {};

TA.MACD.name = 'MACD';
TA.MACD.type = 'line';

TA.MACD.DefaultSettings = {
    FastPeriod: 12,
    SlowPeriod: 26,
    SignalPeriod: 9,
    CandleValueIdx: TA.CLOSE
};

TA.MACD.Settings = {};

TA.MACD.calculate = function(startIdx, endIdx, dataShape, settings){
    if(!!settings)
        this.SetSettings(settings);
    
    if(!startIdx)
        startIdx = 0;
    
    if(!endIdx)
        endIdx = dataShape.length-1;
    
    if( startIdx < 0 )
       throw 'TA_OUT_OF_RANGE_START_INDEX';
    if( (endIdx < 0) || (endIdx < startIdx))
       throw 'TA_OUT_OF_RANGE_END_INDEX';
 
    if( !dataShape || !dataShape.length )
        throw 'TA_BAD_PARAM';
    
    if( !this.Settings.FastPeriod )
       this.Settings.FastPeriod = this.DefaultSettings.FastPeriod;
    else if( (this.Settings.FastPeriod < 2) || (this.Settings.FastPeriod > 100000) )
       throw 'TA_BAD_PARAM';
 
    
    if( !this.Settings.SlowPeriod )
       this.Settings.SlowPeriod = this.DefaultSettings.SlowPeriod;
    else if( (this.Settings.SlowPeriod < 2) || (this.Settings.SlowPeriod > 100000) )
       throw 'TA_BAD_PARAM';
    if( !this.Settings.SignalPeriod )
       this.Settings.SignalPeriod = this.DefaultSettings.SignalPeriod;
    else if( (this.Settings.SignalPeriod < 1) || (this.Settings.SignalPeriod > 100000) )
       throw 'TA_BAD_PARAM';
 
    var int_macd_settings = $.extend(true, {}, this.Settings);
    int_macd_settings.SignalPeriod_2 = int_macd_settings.SignalPeriod;
    delete int_macd_settings.SignalPeriod;
    
    return TA.INT_MACD.calculate( startIdx, endIdx, dataShape, int_macd_settings);
};

TA.MACD._lookback = function (optInFastPeriod, optInSlowPeriod, optInSignalPeriod) {


    if (!optInFastPeriod)
        optInFastPeriod = this.DefaultSettings.FastPeriod;
    else if ((optInFastPeriod < 2) || (optInFastPeriod > 100000))
        return -1;


    if (!optInSlowPeriod)
        optInSlowPeriod = this.DefaultSettings.SlowPeriod;
    else if ((optInSlowPeriod < 2) || (optInSlowPeriod > 100000))
        return -1;


    if (!optInSignalPeriod)
        optInSignalPeriod = this.DefaultSettings.SignalPeriod;
    else if ((optInSignalPeriod < 1) || (optInSignalPeriod > 100000)) return -1;

    var tempInteger;
    if (optInSlowPeriod < optInFastPeriod) {
        /* swap */
        tempInteger = optInSlowPeriod;
        optInSlowPeriod = optInFastPeriod;
        optInFastPeriod = tempInteger;
    }
    return TA.EMA._lookback(optInSlowPeriod) + TA.EMA._lookback(optInSignalPeriod);
};

TA.MACD.SetSettings(TA.MACD.DefaultSettings);

if (!!TA.INDICATOR_TEMPLATE)
    TA.INT_MACD = TA.INDICATOR_TEMPLATE.Create();
else
    TA.INT_MACD = {};

TA.INT_MACD.name = 'INT_MACD';
TA.INT_MACD.type = 'line';

TA.INT_MACD.DefaultSettings = {
    FastPeriod: 12,
    SlowPeriod: 26,
    SignalPeriod_2: 9,
    CandleValueIdx: TA.CLOSE
};

TA.INT_MACD.Settings = {};

TA.INT_MACD.calculate = function(startIdx, endIdx, dataShape, settings){
    var slowEMABuffer = [],
        fastEMABuffer = [],
        k1, k2, tempInteger,
        lookbackTotal, lookbackSignal,
        i, len;
    
    var outMACD = [],
        outMACDSignal = [],
        outMACDHist = [];
    
    if(!!this.Settings) {
        this.SetSettings(settings);
    }

    /* !!! A lot of speed optimization could be done
    * !!! with this function. 
    * !!!
    * !!! A better approach would be to use TA_INT_EMA
    * !!! just to get the seeding values for the
    * !!! fast and slow EMA. Then process the difference
    * !!! in an allocated buffer until enough data is
    * !!! available for the first signal value.
    * !!! From that point all the processing can
    * !!! be done in a tight loop.
    * !!!
    * !!! That approach will have the following
    * !!! advantage:
    * !!!   1) One mem allocation needed instead of two.
    * !!!   2) The mem allocation size will be only the
    * !!!      signal lookback period instead of the 
    * !!!      whole range of data.
    * !!!   3) Processing will be done in a tight loop.
    * !!!      allowing to avoid a lot of memory store-load
    * !!!      operation.
    * !!!   4) The memcpy at the end will be eliminated!
    * !!!
    * !!! If only I had time....
    */

   /* Make sure slow is really slower than
    * the fast period! if not, swap...
    */
    if( this.Settings.SlowPeriod < this.Settings.FastPeriod )
    {
       /* swap */
       tempInteger              = this.Settings.SlowPeriod;
       this.Settings.SlowPeriod = this.Settings.FastPeriod;
       this.Settings.FastPeriod = tempInteger;
    }

    /* Catch special case for fix 26/12 MACD. */
    if( this.Settings.SlowPeriod != 0 ) {
        k1 = TA.PER_TO_K(this.Settings.SlowPeriod);
    } else {
      this.Settings.SlowPeriod = this.DefaultSettings.SlowPeriod;
      k1 = TA.PER_TO_K(this.Settings.SlowPeriod); /* Fix 26 */
    }

    if( this.Settings.FastPeriod != 0 ) {
        k2 = TA.PER_TO_K(this.Settings.FastPeriod);
    } else {
        this.Settings.FastPeriod = this.DefaultSettings.FastPeriod;
        k2 = TA.PER_TO_K(this.Settings.FastPeriod); /* Fix 12 */
    }

    lookbackSignal = TA.EMA._lookback( this.Settings.SignalPeriod_2 );

    /* Move up the start index if there is not
    * enough initial data.
    */
    lookbackTotal =  lookbackSignal;
    lookbackTotal += TA.EMA._lookback( this.Settings.SlowPeriod );

    if( startIdx < lookbackTotal ) {
        startIdx = lookbackTotal;
    }

    /* Make sure there is still something to evaluate. */
    if( startIdx > endIdx ){
      return {MACD: outMACD, MACDSignal: outMACDSignal, MACDHist: outMACDHist};
    }

    /* Allocate intermediate buffer for fast/slow EMA. */
    tempInteger = (endIdx-startIdx)+1+lookbackSignal;

   /* Calculate the slow EMA. 
    *
    * Move back the startIdx to get enough data
    * for the signal period. That way, once the
    * signal calculation is done, all the output
    * will start at the requested 'startIdx'.
    */
    tempInteger = startIdx-lookbackSignal;
    TA.EMA.SetSettings({CandleValueIdx:this.Settings.CandleValueIdx});
    TA.EMA._int_ema( tempInteger, endIdx, dataShape, this.Settings.SlowPeriod, k1, slowEMABuffer);

    if( !slowEMABuffer || !slowEMABuffer.length ) {
      return {MACD: outMACD, MACDSignal: outMACDSignal, MACDHist: outMACDHist};
    }

    /* Calculate the fast EMA. */
    TA.EMA._int_ema( tempInteger, endIdx, dataShape, this.Settings.FastPeriod, k2, fastEMABuffer );

    if( !fastEMABuffer || !fastEMABuffer.length ) {
       return {MACD: outMACD, MACDSignal: outMACDSignal, MACDHist: outMACDHist};
    }

    /* Calculate (fast EMA) - (slow EMA). */
    for( i=0, len = fastEMABuffer.length; i < len; i++ ) {
        fastEMABuffer[i] = fastEMABuffer[i] - slowEMABuffer[i];
    }

    /* Copy the result into the output for the caller. */
    outMACD = fastEMABuffer.slice(-fastEMABuffer.length+this.Settings.SignalPeriod_2-1);
    /* Calculate the signal/trigger line. */
    var fastEMABufferArr = [];
    for(var i=0; i< fastEMABuffer.length; i++) {
        fastEMABufferArr.push({'7': fastEMABuffer[i]});
    }

    TA.EMA._int_ema(0, fastEMABuffer.length - 1, fastEMABufferArr, this.Settings.SignalPeriod_2, TA.PER_TO_K(this.Settings.SignalPeriod_2), outMACDSignal);

    if( !outMACDSignal || !outMACDSignal.length ) {
        return {MACD: outMACD, MACDSignal: outMACDSignal, MACDHist: outMACDHist};
    }

    /* Calculate the histogram. */
    for( i=0, len = outMACDSignal.length; i < len; i++ ) {
        outMACDHist[i] = outMACD[i] - outMACDSignal[i];
    }

    /* All done! Indicate the output limits and return success. */
    return {MACD: outMACD, MACDSignal: outMACDSignal, MACDHist: outMACDHist};
};

TA.INT_MACD._lookback = function(optInTimePeriod) {
    TA.EMA._lookback(optInTimePeriod);
};

TA.INT_MACD.SetSettings(TA.INT_MACD.DefaultSettings);

if (!!TA.INDICATOR_TEMPLATE)
    TA.MEDPRICE = TA.INDICATOR_TEMPLATE.Create();
else
    TA.MEDPRICE = {};

TA.MEDPRICE.name = 'MEDPRICE';
TA.MEDPRICE.type = 'line';

TA.MEDPRICE.DefaultSettings = {};

TA.MEDPRICE.Settings = {};

TA.MEDPRICE._lookback = function() {
    return 0;
};


TA.MEDPRICE.calculate = function(startIdx, endIdx, dataShape, settings) {
    var outIdx, i, outReal = [];
    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';

    outIdx = 0;
    for (i = startIdx; i <= endIdx; i++) {
        outReal[outIdx++] = (dataShape[i][TA.HIGH] + dataShape[i][TA.LOW]) / 2.0;
    }
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.MFI = TA.INDICATOR_TEMPLATE.Create();
else
    TA.MFI = {};

TA.MFI.name = 'MFI';
TA.MFI.type = 'line';

TA.MFI.DefaultSettings = {
    TimePeriod: 14
};

TA.MFI.Settings = {};

TA.MFI._lookback = function (optInTimePeriod) {
    if (!optInTimePeriod) optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if ((optInTimePeriod < 2) || (optInTimePeriod > 100000)) return -1;
    return optInTimePeriod;
};

TA.MFI.calculate = function (startIdx, endIdx, dataShape, settings) {
    var posSumMF, negSumMF, prevValue;
    var tempValue1, tempValue2;
    var lookbackTotal, outIdx, i, today;
    var outReal = [];

    this.SetSettings(settings);

    var mflow_Idx = 0;
    var mflow = [];
    var maxIdx_mflow = 49;

    if (startIdx < 0) throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx)) throw 'TA_OUT_OF_RANGE_END_INDEX';

    if (!this.Settings.TimePeriod) this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
    else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000)) throw 'TA_BAD_PARAM';

    if(this.Settings.TimePeriod <= 0) {
        return outReal;
    }

    mflow = new Array(this.Settings.TimePeriod);

    for (var i=0; i<mflow.length; i++) {
        mflow[i] = {};
    }

    if(!mflow) {
        return outReal;
    }

    maxIdx_mflow = mflow.length - 1;

    lookbackTotal = this.Settings.TimePeriod;
    if (startIdx < lookbackTotal) startIdx = lookbackTotal;
    if (startIdx > endIdx) {
        return outReal;
    }

    outIdx = 0;
    today = startIdx - lookbackTotal;
    prevValue = (dataShape[today][TA.HIGH] + dataShape[today][TA.LOW] + dataShape[today][TA.CLOSE]) / 3.0;
    posSumMF = 0.0;
    negSumMF = 0.0;
    today++;
    for (i = this.Settings.TimePeriod; i > 0; i--) {
        tempValue1 = (dataShape[today][TA.HIGH] + dataShape[today][TA.LOW] + dataShape[today][TA.CLOSE]) / 3.0;
        tempValue2 = tempValue1 - prevValue;
        prevValue = tempValue1;
        tempValue1 *= dataShape[today++][TA.VOL];
        if (tempValue2 < 0) {
            mflow[mflow_Idx].negative = tempValue1;
            negSumMF += tempValue1;
            mflow[mflow_Idx].positive = 0.0;
        } else if (tempValue2 > 0) {
            mflow[mflow_Idx].positive = tempValue1;
            posSumMF += tempValue1;
            mflow[mflow_Idx].negative = 0.0;
        } else {
            mflow[mflow_Idx].positive = 0.0;
            mflow[mflow_Idx].negative = 0.0;
        }

        mflow_Idx++;
        if(mflow_Idx > maxIdx_mflow) {
            mflow_Idx = 0;
        }
    }

    if (today > startIdx) {
        tempValue1 = posSumMF + negSumMF;
        if (tempValue1 < 1.0) outReal[outIdx++] = 0.0;
        else outReal[outIdx++] = 100.0 * (posSumMF / tempValue1);
    } else {
        while (today < startIdx) {
            posSumMF -= mflow[mflow_Idx].positive;
            negSumMF -= mflow[mflow_Idx].negative;
            tempValue1 = (dataShape[today][TA.HIGH] + dataShape[today][TA.LOW] + dataShape[today][TA.CLOSE]) / 3.0;
            tempValue2 = tempValue1 - prevValue;
            prevValue = tempValue1;
            tempValue1 *= dataShape[today++][TA.VOL];
            if (tempValue2 < 0) {
                mflow[mflow_Idx].negative = tempValue1;
                negSumMF += tempValue1;
                mflow[mflow_Idx].positive = 0.0;
            } else if (tempValue2 > 0) {
                mflow[mflow_Idx].positive = tempValue1;
                posSumMF += tempValue1;
                mflow[mflow_Idx].negative = 0.0;
            } else {
                mflow[mflow_Idx].positive = 0.0;
                mflow[mflow_Idx].negative = 0.0;
            }
            mflow_Idx++;
            if(mflow_Idx > maxIdx_mflow) {
                mflow_Idx = 0;
            }
        }
    }

    while (today <= endIdx) {
        posSumMF -= mflow[mflow_Idx].positive;
        negSumMF -= mflow[mflow_Idx].negative;
        tempValue1 = (dataShape[today][TA.HIGH] + dataShape[today][TA.LOW] + dataShape[today][TA.CLOSE]) / 3.0;
        tempValue2 = tempValue1 - prevValue;
        prevValue = tempValue1;
        tempValue1 *= dataShape[today++][TA.VOL];
        if (tempValue2 < 0) {
            mflow[mflow_Idx].negative = tempValue1;
            negSumMF += tempValue1;
            mflow[mflow_Idx].positive = 0.0;
        } else if (tempValue2 > 0) {
            mflow[mflow_Idx].positive = tempValue1;
            posSumMF += tempValue1;
            mflow[mflow_Idx].negative = 0.0;
        } else {
            mflow[mflow_Idx].positive = 0.0;
            mflow[mflow_Idx].negative = 0.0;
        }
        tempValue1 = posSumMF + negSumMF;
        if (tempValue1 < 1.0) {
            outReal[outIdx++] = 0.0;
        } else {
            outReal[outIdx++] = 100.0 * (posSumMF / tempValue1);
        }
        mflow_Idx++;
        if(mflow_Idx > maxIdx_mflow) {
            mflow_Idx = 0;
        }
    }
    return outReal;
};

if (!!TA.INDICATOR_TEMPLATE)
    TA.MINUS_DI = TA.INDICATOR_TEMPLATE.Create();
else
    TA.MINUS_DI = {};

TA.MINUS_DI.name = 'MINUS_DI';
TA.MINUS_DI.type = 'line';

TA.MINUS_DI.DefaultSettings = {
    TimePeriod: 14
};

TA.MINUS_DI.Settings = {};

TA.MINUS_DI._lookback = function(optInTimePeriod) {
    if (!optInTimePeriod)
        optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if ((optInTimePeriod < 1) || (optInTimePeriod > 100000))
        return -1;
    if (optInTimePeriod > 1)
        return optInTimePeriod;
    else
        return 1;
};


TA.MINUS_DI.calculate = function(startIdx, endIdx, dataShape, settings) {
    var today, lookbackTotal, outIdx;
    var prevHigh, prevLow, prevClose;
    var prevMinusDM, prevTR;
    var tempReal, tempReal2, diffP, diffM;
    var i;

    var outReal = [];
    this.SetSettings(settings);

    function TRUE_RANGE(TH, TL, YC, OUT) {
        return '\
              ' + OUT + ' = ' + TH + '-' + TL + '; \
              tempReal2 = Math.abs(' + TH + '-' + YC + '); \
              if( tempReal2 > ' + OUT + ' ) \
                 ' + OUT + ' = tempReal2; \
              tempReal2 = Math.abs(' + TL + '-' + YC + '); \
              if( tempReal2 > ' + OUT + ' ) \
                 ' + OUT + ' = tempReal2;';
    }

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!this.Settings.TimePeriod)
        this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
    else if ((this.Settings.TimePeriod < 1) || (this.Settings.TimePeriod > 100000))
        throw 'TA_BAD_PARAM';

    function round_pos(x) {
        return x;
    };

    if (this.Settings.TimePeriod > 1)
        lookbackTotal = this.Settings.TimePeriod;
    else
        lookbackTotal = 1;

    if (startIdx < lookbackTotal)
        startIdx = lookbackTotal;
    if (startIdx > endIdx) {
        var outBegIdx;
        var outNBElement;
        return outReal;
    }
    outIdx = 0;
    if (this.Settings.TimePeriod <= 1) {
        var outBegIdx = startIdx;
        today = startIdx - 1;
        prevHigh = dataShape[today][TA.HIGH];
        prevLow = dataShape[today][TA.LOW];
        prevClose = dataShape[today][TA.CLOSE];
        while (today < endIdx) {
            today++;
            tempReal = dataShape[today][TA.HIGH];
            diffP = tempReal - prevHigh;
            prevHigh = tempReal;
            tempReal = dataShape[today][TA.LOW];
            diffM = prevLow - tempReal;
            prevLow = tempReal;
            if ((diffM > 0) && (diffP < diffM)) {
                eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
                if (TA.TA_IS_ZERO(tempReal))
                    outReal[outIdx++] = 0.0;
                else
                    outReal[outIdx++] = diffM / tempReal;
            } else
                outReal[outIdx++] = 0.0;
            prevClose = dataShape[today][TA.CLOSE];
        }
        outNBElement = outIdx;
        return outReal;
    }
    outBegIdx = today = startIdx;
    prevMinusDM = 0.0;
    prevTR = 0.0;
    today = startIdx - lookbackTotal;
    prevHigh = dataShape[today][TA.HIGH];
    prevLow = dataShape[today][TA.LOW];
    prevClose = dataShape[today][TA.CLOSE];
    i = this.Settings.TimePeriod - 1;
    while (i-- > 0) {
        today++;
        tempReal = dataShape[today][TA.HIGH];
        diffP = tempReal - prevHigh;
        prevHigh = tempReal;
        tempReal = dataShape[today][TA.LOW];
        diffM = prevLow - tempReal;
        prevLow = tempReal;
        if ((diffM > 0) && (diffP < diffM)) {
            prevMinusDM += diffM;
        }
        eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
        prevTR += tempReal;
        prevClose = dataShape[today][TA.CLOSE];
    }
    i = 1;
    while (i-- != 0) {
        today++;
        tempReal = dataShape[today][TA.HIGH];
        diffP = tempReal - prevHigh;
        prevHigh = tempReal;
        tempReal = dataShape[today][TA.LOW];
        diffM = prevLow - tempReal;
        prevLow = tempReal;
        if ((diffM > 0) && (diffP < diffM)) {
            prevMinusDM = prevMinusDM - (prevMinusDM / this.Settings.TimePeriod) + diffM;
        } else {
            prevMinusDM = prevMinusDM - (prevMinusDM / this.Settings.TimePeriod);
        }
        eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
        prevTR = prevTR - (prevTR / this.Settings.TimePeriod) + tempReal;
        prevClose = dataShape[today][TA.CLOSE];
    }
    if (!TA.TA_IS_ZERO(prevTR))
        outReal[0] = round_pos(100.0 * (prevMinusDM / prevTR));
    else
        outReal[0] = 0.0;
    outIdx = 1;
    while (today < endIdx) {
        today++;
        tempReal = dataShape[today][TA.HIGH];
        diffP = tempReal - prevHigh;
        prevHigh = tempReal;
        tempReal = dataShape[today][TA.LOW];
        diffM = prevLow - tempReal;
        prevLow = tempReal;
        if ((diffM > 0) && (diffP < diffM)) {
            prevMinusDM = prevMinusDM - (prevMinusDM / this.Settings.TimePeriod) + diffM;
        } else {
            prevMinusDM = prevMinusDM - (prevMinusDM / this.Settings.TimePeriod);
        }
        eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
        prevTR = prevTR - (prevTR / this.Settings.TimePeriod) + tempReal;
        prevClose = dataShape[today][TA.CLOSE];
        if (!TA.TA_IS_ZERO(prevTR))
            outReal[outIdx++] = round_pos(100.0 * (prevMinusDM / prevTR));
        else
            outReal[outIdx++] = 0.0;
    }
    outNBElement = outIdx;
    return outReal;
};

if (!!TA.INDICATOR_TEMPLATE)
    TA.MINUS_DM = TA.INDICATOR_TEMPLATE.Create();
else
    TA.MINUS_DM = {};

TA.MINUS_DM.name = 'MINUS_DM';
TA.MINUS_DM.type = 'line';

TA.MINUS_DM.DefaultSettings = {
    TimePeriod: 14
};

TA.MINUS_DM.Settings = {};

TA.MINUS_DM._lookback = function(optInTimePeriod) {
    if (!optInTimePeriod)
        optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if ((optInTimePeriod < 1) || (optInTimePeriod > 100000))
        return -1;
    if (optInTimePeriod > 1)
        return optInTimePeriod - 1;
    else
        return 1;
};

TA.MINUS_DM.calculate = function(startIdx, endIdx, dataShape, settings) {
    var today, lookbackTotal, outIdx;
    var prevHigh, prevLow, tempReal;
    var prevMinusDM;
    var diffP, diffM;
    var i;

    var outReal = [];

    this.SetSettings(settings);

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!this.Settings.TimePeriod)
        this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
    else if ((this.Settings.TimePeriod < 1) || (this.Settings.TimePeriod > 100000))
        throw 'TA_BAD_PARAM';
    if (this.Settings.TimePeriod > 1)
        lookbackTotal = this.Settings.TimePeriod - 1;
    else
        lookbackTotal = 1;

    if (startIdx < lookbackTotal)
        startIdx = lookbackTotal;
    if (startIdx > endIdx) {
        return outReal;
    }
    outIdx = 0;
    if (this.Settings.TimePeriod <= 1) {
        today = startIdx - 1;
        prevHigh = dataShape[today][TA.HIGH];
        prevLow = dataShape[today][TA.LOW];
        while (today < endIdx) {
            today++;
            tempReal = dataShape[today][TA.HIGH];
            diffP = tempReal - prevHigh;
            prevHigh = tempReal;
            tempReal = dataShape[today][TA.LOW];
            diffM = prevLow - tempReal;
            prevLow = tempReal;
            if ((diffM > 0) && (diffP < diffM)) {
                outReal[outIdx++] = diffM;
            } else
                outReal[outIdx++] = 0;
        }
        return outReal;
    }
    prevMinusDM = 0.0;
    today = startIdx - lookbackTotal;
    prevHigh = dataShape[today][TA.HIGH];
    prevLow = dataShape[today][TA.LOW];
    i = this.Settings.TimePeriod - 1;
    while (i-- > 0) {
        today++;
        tempReal = dataShape[today][TA.HIGH];
        diffP = tempReal - prevHigh;
        prevHigh = tempReal;
        tempReal = dataShape[today][TA.LOW];
        diffM = prevLow - tempReal;
        prevLow = tempReal;
        if ((diffM > 0) && (diffP < diffM)) {
            prevMinusDM += diffM;
        }
    }
    i = 0;
    while (i-- != 0) {
        today++;
        tempReal = dataShape[today][TA.HIGH];
        diffP = tempReal - prevHigh;
        prevHigh = tempReal;
        tempReal = dataShape[today][TA.LOW];
        diffM = prevLow - tempReal;
        prevLow = tempReal;
        if ((diffM > 0) && (diffP < diffM)) {
            prevMinusDM = prevMinusDM - (prevMinusDM / this.Settings.TimePeriod) + diffM;
        } else {
            prevMinusDM = prevMinusDM - (prevMinusDM / this.Settings.TimePeriod);
        }
    }
    outReal[0] = prevMinusDM;
    outIdx = 1;
    while (today < endIdx) {
        today++;
        tempReal = dataShape[today][TA.HIGH];
        diffP = tempReal - prevHigh;
        prevHigh = tempReal;
        tempReal = dataShape[today][TA.LOW];
        diffM = prevLow - tempReal;
        prevLow = tempReal;
        if ((diffM > 0) && (diffP < diffM)) {
            prevMinusDM = prevMinusDM - (prevMinusDM / this.Settings.TimePeriod) + diffM;
        } else {
            prevMinusDM = prevMinusDM - (prevMinusDM / this.Settings.TimePeriod);
        }
        outReal[outIdx++] = prevMinusDM;
    }
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.OBV = TA.INDICATOR_TEMPLATE.Create();
else
    TA.OBV = {};

TA.OBV.name = 'OBV';
TA.OBV.type = 'line';

TA.OBV.DefaultSettings = {
    CandleValueIdx: TA.CLOSE
};

TA.OBV.Settings = {};


TA.OBV._lookback = function() {
    return 0;
};

TA.OBV.calculate = function(startIdx, endIdx, dataShape, settings) {
    var i;
    var outIdx;
    var prevReal, tempReal, prevOBV;
    var outReal = [];

    this.SetSettings(settings);

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!dataShape || !dataShape.length) throw 'TA_BAD_PARAM';

    prevOBV = dataShape[startIdx][TA.VOL];
    prevReal = dataShape[startIdx][this.Settings.CandleValueIdx];
    outIdx = 0;
    for (i = startIdx; i <= endIdx; i++) {
        tempReal = dataShape[i][this.Settings.CandleValueIdx];
        if (tempReal > prevReal)
            prevOBV += dataShape[i][TA.VOL];
        else if (tempReal < prevReal)
            prevOBV -= dataShape[i][TA.VOL];
        outReal[outIdx++] = prevOBV;
        prevReal = tempReal;
    }
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.PCH = TA.INDICATOR_TEMPLATE.Create();
else
    TA.PCH = {};

TA.PCH.name = 'PCH';
TA.PCH.type = 'line';

TA.PCH.DefaultSettings = {
    TimePeriodLower: 13,
    TimePeriodUpper: 13
};

TA.PCH.Settings = {};


TA.PCH._lookback = function(optTimePeriodLower, optTimePeriodUpper) {
    if (!optTimePeriodLower) {
        optTimePeriodLower = this.Settings.TimePeriodLower || this.DefaultSettings.TimePeriodLower;
    }

    if (!optTimePeriodUpper) {
        optTimePeriodUpper = this.Settings.TimePeriodUpper || this.DefaultSettings.TimePeriodUpper;
    }

    var period = Math.min(optTimePeriodLower, optTimePeriodUpper) - 1;

    if ((period < 1) || (period > 100000))
        return -1;
    if (period > 1)
        return period;
    else
        return 1;
};

TA.PCH.calculate = function(startIdx, endIdx, dataShape, settings) {
    var outReal = [];
    var high = [];
    var low = [];
    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';

    this.SetSettings(settings);

    var lookbackLower = this.Settings.TimePeriodLower;
    var lookbackUpper = this.Settings.TimePeriodUpper;

    for(var i = lookbackLower - 1; i<=endIdx; i++) {
        var low20 = dataShape[i][TA.LOW];
        for(var j = i-lookbackLower+1; j<=i; j++) {
            if(dataShape[j][TA.LOW] < low20) {
                low20 = dataShape[j][TA.LOW];
            }
        }
        low.push(low20);
    }

    for(var i = lookbackUpper - 1; i<=endIdx; i++) {
        var high20 = dataShape[i][TA.HIGH];
        for(var j = i-lookbackUpper+1; j<=i; j++) {
            if(dataShape[j][TA.HIGH] > high20) {
                high20 = dataShape[j][TA.HIGH];
            }
        }
        high.push(high20);
    }

    if(lookbackLower > lookbackUpper) {
        for (var i=0; i<(lookbackLower - lookbackUpper); i++) {
            low.splice(0,0,0);
        }

    } else if (lookbackLower > lookbackUpper) {
        for (var i=0; i<(lookbackUpper - lookbackLower); i++) {
            high.splice(0,0,0);
        }
    }

    outReal = {high: high, low: low};

    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.PLUS_DI = TA.INDICATOR_TEMPLATE.Create();
else
    TA.PLUS_DI = {};

TA.PLUS_DI.name = 'PLUS_DI';
TA.PLUS_DI.type = 'line';

TA.PLUS_DI.DefaultSettings = {
    TimePeriod: 14
};

TA.PLUS_DI.Settings = {};

TA.PLUS_DI._lookback = function(optInTimePeriod) {
    if (!optInTimePeriod)
        optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if ((optInTimePeriod < 1) || (optInTimePeriod > 100000))
        return -1;
    if (optInTimePeriod > 1)
        return optInTimePeriod;
    else
        return 1;
};

TA.PLUS_DI.calculate = function(startIdx, endIdx, dataShape, settings) {
    var today, lookbackTotal, outIdx;
    var prevHigh, prevLow, prevClose;
    var prevPlusDM, prevTR;
    var tempReal, tempReal2, diffP, diffM;
    var i;

    var outReal = [];
    this.SetSettings(settings);

    function TRUE_RANGE(TH, TL, YC, OUT) {
        return '\
              ' + OUT + ' = ' + TH + '-' + TL + '; \
              tempReal2 = Math.abs(' + TH + '-' + YC + '); \
              if( tempReal2 > ' + OUT + ' ) \
                 ' + OUT + ' = tempReal2; \
              tempReal2 = Math.abs(' + TL + '-' + YC + '); \
              if( tempReal2 > ' + OUT + ' ) \
                 ' + OUT + ' = tempReal2;';
    }

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!this.Settings.TimePeriod)
        this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
    else if ((this.Settings.TimePeriod < 1) || (this.Settings.TimePeriod > 100000))
        throw 'TA_BAD_PARAM';

    function round_pos(x) {
        return x;
    };

    if (this.Settings.TimePeriod > 1)
        lookbackTotal = this.Settings.TimePeriod;
    else
        lookbackTotal = 1;

    if (startIdx < lookbackTotal)
        startIdx = lookbackTotal;
    if (startIdx > endIdx) {
        var outBegIdx = 0;
        var outNBElement = 0;
        return outReal;
    }
    outIdx = 0;
    if (this.Settings.TimePeriod <= 1) {
        var outBegIdx = startIdx;
        today = startIdx - 1;
        prevHigh = dataShape[today][TA.HIGH];
        prevLow = dataShape[today][TA.LOW];
        prevClose = dataShape[today][TA.CLOSE];
        while (today < endIdx) {
            today++;
            tempReal = dataShape[today][TA.HIGH];
            diffP = tempReal - prevHigh;
            prevHigh = tempReal;
            tempReal = dataShape[today][TA.LOW];
            diffM = prevLow - tempReal;
            prevLow = tempReal;
            if ((diffP > 0) && (diffP > diffM)) {
                eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
                if (TA.TA_IS_ZERO(tempReal))
                    outReal[outIdx++] = 0.0;
                else
                    outReal[outIdx++] = diffP / tempReal;
            } else
                outReal[outIdx++] = 0.0;
            prevClose = dataShape[today][TA.CLOSE];
        }
        outNBElement = outIdx;
        return outReal;
    }
    outBegIdx = today = startIdx;
    prevPlusDM = 0.0;
    prevTR = 0.0;
    today = startIdx - lookbackTotal;
    prevHigh = dataShape[today][TA.HIGH];
    prevLow = dataShape[today][TA.LOW];
    prevClose = dataShape[today][TA.CLOSE];
    i = this.Settings.TimePeriod - 1;
    while (i-- > 0) {
        today++;
        tempReal = dataShape[today][TA.HIGH];
        diffP = tempReal - prevHigh;
        prevHigh = tempReal;
        tempReal = dataShape[today][TA.LOW];
        diffM = prevLow - tempReal;
        prevLow = tempReal;
        if ((diffP > 0) && (diffP > diffM)) {
            prevPlusDM += diffP;
        }
        eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
        prevTR += tempReal;
        prevClose = dataShape[today][TA.CLOSE];
    }
    i = /*TA_GLOBALS_UNSTABLE_PERIOD(TA_FUNC_UNST_PLUS_DI, PlusDI) +*/ 1;
    while (i-- != 0) {
        today++;
        tempReal = dataShape[today][TA.HIGH];
        diffP = tempReal - prevHigh;
        prevHigh = tempReal;
        tempReal = dataShape[today][TA.LOW];
        diffM = prevLow - tempReal;
        prevLow = tempReal;
        if ((diffP > 0) && (diffP > diffM)) {
            prevPlusDM = prevPlusDM - (prevPlusDM / this.Settings.TimePeriod) + diffP;
        } else {
            prevPlusDM = prevPlusDM - (prevPlusDM / this.Settings.TimePeriod);
        }
        eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
        prevTR = prevTR - (prevTR / this.Settings.TimePeriod) + tempReal;
        prevClose = dataShape[today][TA.CLOSE];
    }
    if (!TA.TA_IS_ZERO(prevTR)) {
        outReal[0] = round_pos(100.0 * (prevPlusDM / prevTR));
    } else {
        outReal[0] = 0.0;
    }
    outIdx = 1;
    while (today < endIdx) {
        today++;
        tempReal = dataShape[today][TA.HIGH];
        diffP = tempReal - prevHigh;
        prevHigh = tempReal;
        tempReal = dataShape[today][TA.LOW];
        diffM = prevLow - tempReal;
        prevLow = tempReal;
        if ((diffP > 0) && (diffP > diffM)) {
            prevPlusDM = prevPlusDM - (prevPlusDM / this.Settings.TimePeriod) + diffP;
        } else {
            prevPlusDM = prevPlusDM - (prevPlusDM / this.Settings.TimePeriod);
        }
        eval(TRUE_RANGE('prevHigh', 'prevLow', 'prevClose', 'tempReal'));
        prevTR = prevTR - (prevTR / this.Settings.TimePeriod) + tempReal;
        prevClose = dataShape[today][TA.CLOSE];
        if (!TA.TA_IS_ZERO(prevTR)) {
            outReal[outIdx++] = round_pos(100.0 * (prevPlusDM / prevTR));
        } else {
            outReal[outIdx++] = 0.0;
        }
    }
    outNBElement = outIdx;
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    var PPO = TA.INDICATOR_TEMPLATE.Create();
else
    var PPO = {};


PPO.DefaultSettings = {
    "CandleValueIdx": TA.CLOSE,
    "FastPeriod": 12,
    "SlowPeriod": 26,
    "MAType": TA.MATypes.SMA
};

PPO.Settings = {};

PPO.name = 'PPO';
PPO.type = 'line';

PPO._lookback = function (optInFastPeriod, optInSlowPeriod, optInMAType) {
    if (!optInFastPeriod)
        optInFastPeriod = this.DefaultSettings.FastPeriod;
    else if ((optInFastPeriod < 2) || (optInFastPeriod > 100000))
        return -1;
    if (!optInSlowPeriod)
        optInSlowPeriod = this.DefaultSettings.SlowPeriod;
    else if ((optInSlowPeriod < 2) || (optInSlowPeriod > 100000))
        return -1;
    if (!optInMAType)
        optInMAType = this.DefaultSettings.MAType;
    else if ((optInMAType < 0) || (optInMAType > 8))
        return -1;
    return MA._lookback(Math.max(optInSlowPeriod, optInFastPeriod), optInMAType);
};

PPO.calculate = function (startIdx, endIdx, dataShape, settings) {
        var outBegIdx, outNBElement,
            tempBuffer = [],
            retCode, outReal = [];

        this.SetSettings(settings);

        if (startIdx < 0)
            throw 'TA_OUT_OF_RANGE_START_INDEX';
        if ((endIdx < 0) || (endIdx < startIdx))
            throw 'TA_OUT_OF_RANGE_END_INDEX';
        if (!dataShape || !dataShape.length) throw 'TA_BAD_PARAM';
        if (!this.Settings.FastPeriod)
            this.Settings.FastPeriod = this.DefaultSettings.FastPeriod;
        else if ((this.Settings.FastPeriod < 2) || (this.Settings.FastPeriod > 100000))
            throw 'TA_BAD_PARAM';
        if (!this.Settings.SlowPeriod)
            this.Settings.SlowPeriod = this.DefaultSettings.SlowPeriod;
        else if ((this.Settings.SlowPeriod < 2) || (this.Settings.SlowPeriod > 100000))
            throw 'TA_BAD_PARAM';
        if (!this.Settings.MAType)
            this.Settings.MAType = this.DefaultSettings.MAType;
        else if ((this.Settings.MAType < 0) || (this.Settings.MAType > 8))
            throw 'TA_BAD_PARAM';
        if (!outReal)
            throw 'TA_BAD_PARAM';


        outReal = APO.INT_PO(startIdx, endIdx, dataShape, this.Settings.FastPeriod, this.Settings.SlowPeriod, this.Settings.MAType, outReal, tempBuffer, 1);

        return outReal;
};

PPO.SetSettings(PPO.DefaultSettings);
if (!!TA.INDICATOR_TEMPLATE)
    TA.ROC = TA.INDICATOR_TEMPLATE.Create();
else
    TA.ROC = {};

TA.ROC.name = 'ROC';
TA.ROC.type = 'line';

TA.ROC.DefaultSettings = {
    CandleValueIdx: TA.CLOSE,
    TimePeriod: 10
};

TA.ROC.Settings = {};

TA.ROC._lookback = function(optInTimePeriod) {
    if (!optInTimePeriod)
        optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if ((optInTimePeriod < 1) || (optInTimePeriod > 100000))
        return -1;
    return optInTimePeriod;
};

TA.ROC.calculate = function(startIdx, endIdx, dataShape, settings) {
    var inIdx, outIdx, trailingIdx,
        tempReal, outReal = [];

    this.SetSettings(settings);

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!dataShape || !dataShape.length) throw 'TA_BAD_PARAM';
    if (!this.Settings.TimePeriod)
        this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
    else if ((this.Settings.TimePeriod < 1) || (this.Settings.TimePeriod > 100000))
        throw 'TA_BAD_PARAM';
    if (!outReal)
        throw 'TA_BAD_PARAM';

    if (startIdx < this.Settings.TimePeriod)
        startIdx = this.Settings.TimePeriod;
    if (startIdx > endIdx) {
        return outReal;
    }

    outIdx = 0;
    inIdx = startIdx;
    trailingIdx = startIdx - this.Settings.TimePeriod;
    while (inIdx <= endIdx) {
        tempReal = dataShape[trailingIdx++][TA.CLOSE];
        if (tempReal != 0.0) {
            outReal[outIdx++] = ((dataShape[inIdx][TA.CLOSE] / tempReal) - 1.0) * 100.0;
        } else {
            outReal[outIdx++] = 0.0;
        }
        inIdx++;
    }
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.RSI = TA.INDICATOR_TEMPLATE.Create();
else
    TA.RSI = {};

TA.RSI.name = 'RSI';
TA.RSI.type = 'line';

TA.RSI.DefaultSettings = {
	TimePeriod: 14,
    CandleValueIdx: TA.CLOSE
};

TA.RSI.Settings = {};


TA.RSI.calculate = function (startIdx, endIdx, dataShape, settings) {

    this.SetSettings(settings);

	var outIdx;

	var today, lookbackTotal, unstablePeriod, i;
	var prevGain, prevLoss, prevValue, savePrevValue;
	var tempValue1, tempValue2;

	var outReal = [];

	if (!startIdx)
		startIdx = 0;

	if (!endIdx)
		endIdx = dataShape.length - 1;

	if (startIdx < 0)
		throw 'TA_OUT_OF_RANGE_START_INDEX';
	if ((endIdx < 0) || (endIdx < startIdx))
		throw 'TA_OUT_OF_RANGE_END_INDEX';

	if (!dataShape || !dataShape.length) throw 'TA_BAD_PARAM';

	if (!this.Settings.TimePeriod)
		this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
	else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
		throw 'TA_BAD_PARAM';

	/* Insert TA function code here. */

	/* The following algorithm is base on the original 
	 * work from Wilder's and shall represent the
	 * original idea behind the classic RSI.
	 *
	 * Metastock is starting the calculation one price
	 * bar earlier. To make this possible, they assume
	 * that the very first bar will be identical to the
	 * previous one (no gain or loss).
	 */

	/* If changing this function, please check also CMO 
	 * which is mostly identical (just different in one step
	 * of calculation).
	 */

	/* Adjust startIdx to account for the lookback period. */
	lookbackTotal = this._lookback(this.Settings.TimePeriod);

	if (startIdx < lookbackTotal)
		startIdx = lookbackTotal;

	/* Make sure there is still something to evaluate. */
	if (startIdx > endIdx)
		return outReal;

	outIdx = 0; /* Index into the output. */

	/* Trap special case where the period is '1'.
	 * In that case, just copy the input into the
	 * output for the requested range (as-is !)
	 */
	if (this.Settings.TimePeriod == 1) {

		outReal = dataShape.slice(startIdx);
		
		return outReal;
	}

	/* Accumulate Wilder's "Average Gain" and "Average Loss" 
	 * among the initial period.
	 */
	today = startIdx - lookbackTotal;
	prevValue = dataShape[today][this.Settings.CandleValueIdx];

	unstablePeriod = 0; //TA_GLOBALS_UNSTABLE_PERIOD(TA_FUNC_UNST_RSI, Rsi);

	
//	/* If there is no unstable period,
//	 * calculate the 'additional' initial
//	 * price bar who is particuliar to
//	 * metastock.
//	 * If there is an unstable period,
//	 * no need to calculate since this
//	 * first value will be surely skip.
//	 */
//	if ((unstablePeriod == 0) &&
//		(TA_GLOBALS_COMPATIBILITY == ENUM_VALUE(Compatibility, TA_COMPATIBILITY_METASTOCK, Metastock))) {
//		/* Preserve prevValue because it may get 
//		 * overwritten by the output.
//		 *(because output ptr could be the same as input ptr).
//		 */
//		savePrevValue = prevValue;
//
//		/* No unstable period, so must calculate first output
//		 * particular to Metastock.
//		 * (Metastock re-use the first price bar, so there
//		 *  is no loss/gain at first. Beats me why they
//		 *  are doing all this).
//		 */
//		prevGain = 0.0;
//		prevLoss = 0.0;
//		for (i = optInTimePeriod; i > 0; i--) {
//			tempValue1 = inReal[today++];
//			tempValue2 = tempValue1 - prevValue;
//			prevValue = tempValue1;
//			if (tempValue2 < 0)
//				prevLoss -= tempValue2;
//			else
//				prevGain += tempValue2;
//		}
//
//
//		tempValue1 = prevLoss / optInTimePeriod;
//		tempValue2 = prevGain / optInTimePeriod;
//
//		/* Write the output. */
//		tempValue1 = tempValue2 + tempValue1;
//		if (!TA_IS_ZERO(tempValue1))
//			outReal[outIdx++] = 100 * (tempValue2 / tempValue1);
//		else
//			outReal[outIdx++] = 0.0;
//
//		/* Are we done? */
//		if (today > endIdx) {
//			VALUE_HANDLE_DEREF(outBegIdx) = startIdx;
//			VALUE_HANDLE_DEREF(outNBElement) = outIdx;
//			return ENUM_VALUE(RetCode, TA_SUCCESS, Success);
//		}
//
//		/* Start over for the next price bar. */
//		today -= optInTimePeriod;
//		prevValue = savePrevValue;
//	}


	/* Remaining of the processing is identical
	 * for both Classic calculation and Metastock.
	 */
	prevGain = 0.0;
	prevLoss = 0.0;
	today++;
	for (i = this.Settings.TimePeriod; i > 0; i--) {
		tempValue1 = dataShape[today++][this.Settings.CandleValueIdx];
		tempValue2 = tempValue1 - prevValue;
		prevValue = tempValue1;
        if (tempValue2 < 0)
			prevLoss -= tempValue2;
		else
			prevGain += tempValue2;
	}


	/* Subsequent prevLoss and prevGain are smoothed
	 * using the previous values (Wilder's approach).
	 *  1) Multiply the previous by 'period-1'.
	 *  2) Add today value.
	 *  3) Divide by 'period'.
	 */
	prevLoss /= this.Settings.TimePeriod;
	prevGain /= this.Settings.TimePeriod;

	/* Often documentation present the RSI calculation as follow:
	 *    RSI = 100 - (100 / 1 + (prevGain/prevLoss))
	 *
	 * The following is equivalent:
	 *    RSI = 100 * (prevGain/(prevGain+prevLoss))
	 *
	 * The second equation is used here for speed optimization.
	 */

	if (today > startIdx) {
		tempValue1 = prevGain + prevLoss;
		if (!TA.TA_IS_ZERO(tempValue1))
			outReal[outIdx++] = 100.0 * (prevGain / tempValue1);
		else
			outReal[outIdx++] = 0.0;
	} else {
		/* Skip the unstable period. Do the processing 
		 * but do not write it in the output.
		 */
		while (today < startIdx) {
			tempValue1 = dataShape[today][this.Settings.CandleValueIdx];
			tempValue2 = tempValue1 - prevValue;
			prevValue = tempValue1;

			prevLoss *= (this.Settings.TimePeriod - 1);
			prevGain *= (this.Settings.TimePeriod - 1);
			if (tempValue2 < 0)
				prevLoss -= tempValue2;
			else
				prevGain += tempValue2;

			prevLoss /= this.Settings.TimePeriod;
			prevGain /= this.Settings.TimePeriod;

			today++;
		}
	}

	/* Unstable period skipped... now continue
	 * processing if needed.
	 */
	while (today <= endIdx) {
		tempValue1 = dataShape[today++][this.Settings.CandleValueIdx];
		tempValue2 = tempValue1 - prevValue;
		prevValue = tempValue1;

		prevLoss *= (this.Settings.TimePeriod - 1);
		prevGain *= (this.Settings.TimePeriod - 1);
		if (tempValue2 < 0)
			prevLoss -= tempValue2;
		else
			prevGain += tempValue2;

		prevLoss /= this.Settings.TimePeriod;
		prevGain /= this.Settings.TimePeriod;
		tempValue1 = prevGain + prevLoss;
		if (!TA.TA_IS_ZERO(tempValue1))
			outReal[outIdx++] = 100.0 * (prevGain / tempValue1);
		else
			outReal[outIdx++] = 0.0;
	}

	return outReal;

};

TA.RSI.getValue = function (dataShape, itemIdx, settings) {

};

TA.RSI._lookback = function (optInTimePeriod) {
	if (!optInTimePeriod)
		optInTimePeriod = this.Settings.TimePeriod || this.DefaultSettings.TimePeriod;
	else if ((optInTimePeriod < 2) || (optInTimePeriod > 100000))
		return -1;

	return optInTimePeriod;
};

TA.RSI._S = function (startIdx, endIdx, dataShape, settings) {

};

TA.RSI.initChart = function (dataShape, hcOptions, ticker) {
	if (!!TA.INDICATOR_TEMPLATE)
		TA.INDICATOR_TEMPLATE.initChart.apply(this, arguments);
};

TA.RSI.SetSettings(TA.RSI.DefaultSettings);

if (!!TA.INDICATOR_TEMPLATE)
    TA.SAR = TA.INDICATOR_TEMPLATE.Create();
else
    TA.SAR = {};

TA.SAR.name = 'SAR';
TA.SAR.type = 'line';

TA.SAR.DefaultSettings = {
    "Acceleration": 0.02,
    "Maximum": 0.2
};

TA.SAR.Settings = {};

TA.SAR._lookback = function(optInAcceleration, optInMaximum) {
    if (!optInAcceleration)
        optInAcceleration = this.DefaultSettings.Acceleration;
    else if ((optInAcceleration < 0.000000e+0) || (optInAcceleration > 3.000000e+37))
        return -1;
    if (!optInMaximum)
        optInMaximum = this.DefaultSettings.Maximum;
    else if ((optInMaximum < 0.000000e+0) || (optInMaximum > 3.000000e+37))
        return -1;
    return 1;
};

TA.SAR.calculate = function(startIdx, endIdx, dataShape, settings) {
    var isLong;
    var todayIdx, outIdx;
    var newHigh, newLow, prevHigh, prevLow;
    var af, ep, sar;

    var outReal = [];
    this.SetSettings(settings);

    var ep_temp;

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!this.Settings.Acceleration)
        this.Settings.Acceleration = this.DefaultSettings.Acceleration;
    else if ((this.Settings.Acceleration < 0.000000e+0) || (this.Settings.Acceleration > 3.000000e+37))
        throw 'TA_BAD_PARAM';
    if (!this.Settings.Maximum)
        this.Settings.Maximum = this.DefaultSettings.Maximum;
    else if ((this.Settings.Maximum < 0.000000e+0) || (this.Settings.Maximum > 3.000000e+37))
        throw 'TA_BAD_PARAM';

    if (startIdx < 1)
        startIdx = 1;
    if (startIdx > endIdx) {
        return outReal;
    }

    af = this.Settings.Acceleration;
    if (af > this.Settings.Maximum) {
        af = this.Settings.Acceleration = this.Settings.Maximum;
    }

    ep_temp = TA.MINUS_DM.calculate(startIdx, startIdx, dataShape, {TimePeriod: 1});
    if (ep_temp[0] > 0) {
        isLong = 0;
    } else {
        isLong = 1;
    }

    outIdx = 0;
    todayIdx = startIdx;
    newHigh = dataShape[todayIdx - 1][TA.HIGH];
    newLow = dataShape[todayIdx - 1][TA.LOW];
    if (isLong == 1) {
        ep = dataShape[todayIdx][TA.HIGH];
        sar = newLow;
    } else {
        ep = dataShape[todayIdx][TA.LOW];
        sar = newHigh;
    }
    newLow = dataShape[todayIdx][TA.LOW];
    newHigh = dataShape[todayIdx][TA.HIGH];
    while (todayIdx <= endIdx) {
        prevLow = newLow;
        prevHigh = newHigh;
        newLow = dataShape[todayIdx][TA.LOW];
        newHigh = dataShape[todayIdx][TA.HIGH];
        todayIdx++;
        if (isLong == 1) {
            if (newLow <= sar) {
                isLong = 0;
                sar = ep;
                if (sar < prevHigh)
                    sar = prevHigh;
                if (sar < newHigh)
                    sar = newHigh;
                outReal[outIdx++] = sar;
                af = this.Settings.Acceleration;
                ep = newLow;
                sar = sar + af * (ep - sar);
                if (sar < prevHigh)
                    sar = prevHigh;
                if (sar < newHigh)
                    sar = newHigh;
            } else {
                outReal[outIdx++] = sar;
                if (newHigh > ep) {
                    ep = newHigh;
                    af += this.Settings.Acceleration;
                    if (af > this.Settings.Maximum)
                        af = this.Settings.Maximum;
                }
                sar = sar + af * (ep - sar);
                if (sar > prevLow)
                    sar = prevLow;
                if (sar > newLow)
                    sar = newLow;
            }
        } else {
            if (newHigh >= sar) {
                isLong = 1;
                sar = ep;
                if (sar > prevLow)
                    sar = prevLow;
                if (sar > newLow)
                    sar = newLow;
                outReal[outIdx++] = sar;
                af = this.Settings.Acceleration;
                ep = newHigh;
                sar = sar + af * (ep - sar);
                if (sar > prevLow)
                    sar = prevLow;
                if (sar > newLow)
                    sar = newLow;
            } else {
                outReal[outIdx++] = sar;
                if (newLow < ep) {
                    ep = newLow;
                    af += this.Settings.Acceleration;
                    if (af > this.Settings.Maximum)
                        af = this.Settings.Maximum;
                }
                sar = sar + af * (ep - sar);
                if (sar < prevHigh)
                    sar = prevHigh;
                if (sar < newHigh)
                    sar = newHigh;
            }
        }
    }
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
	TA.SMA = TA.INDICATOR_TEMPLATE.Create();
else
	TA.SMA = {};

TA.SMA.name = 'SMA';
TA.SMA.type = 'line';

TA.SMA.DefaultSettings = {
	TimePeriod: 30,
	CandleValueIdx: TA.CLOSE
};

TA.SMA.Settings = {};

TA.SMA.calculate = function (startIdx, endIdx, dataShape, settings, dontFillTotalArray) {
	var periodTotal, tempReal;
	var i, outIdx, trailingIdx, lookbackTotal;
	var outReal = [];

	this.SetSettings(settings);
	
	if(!startIdx)
		startIdx = 0;
	
	if(!endIdx)
		endIdx = dataShape.length - 1;
		
	/* Identify the minimum number of price bar needed
	 * to calculate at least one output.
	 */
	lookbackTotal = (this.Settings.TimePeriod - 1);

	/* Move up the start index if there is not
	 * enough initial data.
	 */
	if (startIdx < lookbackTotal)
		startIdx = lookbackTotal;

	/* Make sure there is still something to evaluate. */
	if (startIdx > endIdx) {
		return outReal;
	}

	/* Do the MA calculation using tight loops. */
	/* Add-up the initial period, except for the last value. */
	periodTotal = 0;
	trailingIdx = startIdx - lookbackTotal;

	i = trailingIdx;
	if (this.Settings.TimePeriod > 1) {
		while (i < startIdx)
			periodTotal += dataShape[i++][this.Settings.CandleValueIdx];
	}

	/* Proceed with the calculation for the requested range.
	 * Note that this algorithm allows the inReal and
	 * outReal to be the same buffer.
	 */
	outIdx = 0;
	do {
		periodTotal += dataShape[i++][this.Settings.CandleValueIdx];
		tempReal = periodTotal;
		periodTotal -= dataShape[trailingIdx++][this.Settings.CandleValueIdx];
		outReal[outIdx++] = tempReal / this.Settings.TimePeriod;
	} while (i <= endIdx);

    /*
	if(!dontFillTotalArray) {
		if(outReal.length >= dataShape.length)
			throw 'Ошибка расчета ADX';
		else if(outReal.length <= dataShape.length)
			while(outReal.length != dataShape.length){
				outReal.unshift(0);
			}
	}
	*/
	return outReal;
};

TA.SMA.getValue = function(dataShape, itemIdx, settings) {
	
};

TA.SMA._lookback = function(optInTimePeriod) {
    
    if( !optInTimePeriod )
       optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if( (optInTimePeriod < 2) || (optInTimePeriod > 100000) )
       return -1;
 
 	return optInTimePeriod - 1;
};

TA.SMA._S = function(startIdx, endIdx, dataShape, settings){
	
};

TA.SMA.initChart = function (dataShape, hcOptions, ticker) {
	if(!!INDICATOR_TEMPLATE)
		INDICATOR_TEMPLATE.initChart.apply(this, arguments);
	
	
};

TA.SMA.SetSettings(TA.SMA.DefaultSettings);

if (!!TA.INDICATOR_TEMPLATE)
    TA.STDDEV = TA.INDICATOR_TEMPLATE.Create();
else
    TA.STDDEV = {};

TA.STDDEV.name = 'STDDEV';
TA.STDDEV.type = 'line';

TA.STDDEV.DefaultSettings = {
	TimePeriod: 10,
	Deviations: 1,
	CandleValueIdx: TA.CLOSE
};

TA.STDDEV.Settings = {};

TA.STDDEV.calculate = function (startIdx, endIdx, dataShape, settings) {
	var i;
	var tempReal;
	var outReal = [];
	var outNBElement;

    this.SetSettings(settings);

	if (!startIdx)
		startIdx = 0;

	if (!endIdx)
		endIdx = dataShape.length - 1;

	if (startIdx < 0)
		throw 'TA_OUT_OF_RANGE_START_INDEX';
	if ((endIdx < 0) || (endIdx < startIdx))
		throw 'TA_OUT_OF_RANGE_END_INDEX';

	if (!dataShape || !dataShape.length)
		throw 'TA_BAD_PARAM';

	if (!this.Settings.TimePeriod)
		this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
	else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
		throw 'TA_BAD_PARAM';

	if (!this.Settings.Deviations)
		this.Settings.Deviations = this.DefaultSettings.Deviations;
	else if ((this.Settings.Deviations < -3.000000e+37) || (this.Settings.Deviations > 3.000000e+37))
		throw 'TA_BAD_PARAM';

	/* Insert TA function code here. */

	/* Calculate the variance. */
	var localINTVAR = TA.INT_VAR.Create({
		TimePeriod: this.Settings.TimePeriod,
		CandleValueIdx: this.Settings.CandleValueIdx
	});
	outReal = localINTVAR.calculate(startIdx, endIdx, dataShape, {TimePeriod: this.Settings.TimePeriod,CandleValueIdx: this.Settings.CandleValueIdx});

	if (!outReal || !outReal.length)
		return outReal;

	/* Calculate the square root of each variance, this
	 * is the standard deviation.
	 *
	 * Multiply also by the ratio specified.
	 */
	if (this.Settings.Deviations != 1.0) {
		for (i = 0; i < outNBElement; i++) {
			tempReal = outReal[i];
			if (!!tempReal)
				outReal[i] = Math.sqrt(tempReal) * this.Settings.Deviations;
			else
				outReal[i] = 0.0;
		}
	} else {
		for (i = 0; i < outReal.length; i++) {
			tempReal = outReal[i];
			if (!!tempReal)
				outReal[i] = Math.sqrt(tempReal);
			else
				outReal[i] = 0.0;
		}
	}

	return outReal;

};

TA.STDDEV.getValue = function(dataShape, itemIdx, settings) {
	
};

TA.STDDEV._lookback = function (optInTimePeriod, optInNbDev) {

	if ( !optInTimePeriod )
		optInTimePeriod = this.DefaultSettings.TimePeriod;
	else if ((optInTimePeriod < 2) || (optInTimePeriod > 100000))
		return -1;

	if ( !optInNbDev)
		optInNbDev = this.DefaultSettings.Deviations;
	else if ((optInNbDev < -3.000000e+37) || (optInNbDev > 3.000000e+37))
		return -1;


	return TA.VAR._lookback(optInTimePeriod, optInNbDev);
};

TA.STDDEV._S = function(startIdx, endIdx, dataShape, settings){
	
};

TA.STDDEV.initChart = function (dataShape, hcOptions, ticker) {
	if(!!TA.INDICATOR_TEMPLATE)
		TA.INDICATOR_TEMPLATE.initChart.apply(this, arguments);
	
	
};

TA.STDDEV.SetSettings(TA.STDDEV.DefaultSettings);

if (!!TA.INDICATOR_TEMPLATE)
    TA.STOCH = TA.INDICATOR_TEMPLATE.Create();
else
    TA.STOCH = {};

TA.STOCH.name = 'STOCH';
TA.STOCH.type = 'line';

TA.STOCH.DefaultSettings = {
    PeriodFastK: 5,
    PeriodSlowK: 3,
    PeriodSlowD: 3,
    SlowKMAType: TA.MATypes.SMA,
    SlowDMAType: TA.MATypes.SMA
};

TA.STOCH.Settings = {};

TA.STOCH.calculate = function(startIdx, endIdx, dataShape, settings) {
    var outSlowK = [];
    var outSlowD = [];

    var lowest, highest, tmp, diff;
    var tempBuffer = [];
    var outIdx, lowestIdx, highestIdx;
    var lookbackTotal, lookbackK, lookbackKSlow, lookbackDSlow;
    var trailingIdx, today, i;

    if(!!settings)
        this.SetSettings(settings);

    if(!startIdx)
        startIdx = 0;

    if(!endIdx)
        endIdx = dataShape.length-1;

    if( startIdx < 0 )
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if( (endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';

    if( !dataShape || !dataShape.length )
        throw 'TA_BAD_PARAM';

    if( !this.Settings.PeriodFastK )
        this.Settings.PeriodFastK = this.DefaultSettings.PeriodFastK;
    else if( (this.Settings.PeriodFastK < 1) || (this.Settings.PeriodFastK > 100000) )
        throw 'TA_BAD_PARAM';


    if( !this.Settings.PeriodSlowK )
        this.Settings.PeriodSlowK = this.DefaultSettings.PeriodSlowK;
    else if( (this.Settings.PeriodSlowK < 1) || (this.Settings.PeriodSlowK > 100000) )
        throw 'TA_BAD_PARAM';


    if( !this.Settings.PeriodSlowD )
        this.Settings.PeriodSlowD = this.DefaultSettings.PeriodSlowD;
    else if( (this.Settings.PeriodSlowD < 1) || (this.Settings.PeriodSlowD > 100000) )
        throw 'TA_BAD_PARAM';

    if (this.Settings.SlowKMAType)
        this.Settings.SlowKMAType = this.DefaultSettings.SlowKMAType;
    else if ((this.Settings.SlowKMAType < 0) || (this.Settings.SlowKMAType > 8))
        throw 'TA_BAD_PARAM';

    if (this.Settings.SlowDMAType)
        this.Settings.SlowDMAType = this.DefaultSettings.SlowDMAType;
    else if ((this.Settings.SlowDMAType < 0) || (this.Settings.SlowDMAType > 8))
        throw 'TA_BAD_PARAM';

    if (!outSlowK)
        throw 'TA_BAD_PARAM';

    if (!outSlowD)
        throw 'TA_BAD_PARAM';

    lookbackK      = this.Settings.PeriodFastK - 1;
    lookbackKSlow  = TA.MA._lookback( this.Settings.PeriodSlowK, this.Settings.SlowKMAType );
    lookbackDSlow  = TA.MA._lookback( this.Settings.PeriodSlowD, this.Settings.SlowDMAType );
    lookbackTotal  = lookbackK + lookbackDSlow + lookbackKSlow;

    /* Move up the start index if there is not
     * enough initial data.
     */
    if( startIdx < lookbackTotal )
        startIdx = lookbackTotal;

    /* Make sure there is still something to evaluate. */
    if( startIdx > endIdx )
    {
        /* Succeed... but no data in the output. */
        return {slowK: [], slowD: []};
    }

    /* Proceed with the calculation for the requested range.
     * Note that this algorithm allows the input and
     * output to be the same buffer.
     */
    outIdx = 0;

    /* Calculate just enough K for ending up with the caller
     * requested range. (The range of k must consider all
     * the lookback involve with the smoothing).
     */
    trailingIdx = startIdx-lookbackTotal;
    today       = trailingIdx+lookbackK;
    lowestIdx   = highestIdx = -1;
    diff = highest = lowest  = 0.0;

    /* Do the K calculation */
    while( today <= endIdx )
    {
        /* Set the lowest low */
        tmp = dataShape[today][TA.LOW];
        if( lowestIdx < trailingIdx )
        {
            lowestIdx = trailingIdx;
            lowest = dataShape[lowestIdx][TA.LOW];
            i = lowestIdx;
            while( ++i<=today )
            {
                tmp = dataShape[i][TA.LOW];
                if( tmp < lowest )
                {
                    lowestIdx = i;
                    lowest = tmp;
                }
            }
            diff = (highest - lowest)/100.0;
        }
        else if( tmp <= lowest )
        {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest)/100.0;
        }

        /* Set the highest high */
        tmp = dataShape[today][TA.HIGH];
        if( highestIdx < trailingIdx )
        {
            highestIdx = trailingIdx;
            highest = dataShape[highestIdx][TA.HIGH];
            i = highestIdx;
            while( ++i<=today )
            {
                tmp = dataShape[i][TA.HIGH];
                if( tmp > highest )
                {
                    highestIdx = i;
                    highest = tmp;
                }
            }
            diff = (highest - lowest)/100.0;
        }
        else if( tmp >= highest )
        {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest)/100.0;
        }

        /* Calculate stochastic. */
        if( diff != 0.0 )
            tempBuffer[outIdx++] = [(dataShape[today][TA.CLOSE]-lowest)/diff];
        else
            tempBuffer[outIdx++] = [0.0];

        trailingIdx++;
        today++;
    }

    var localMA = TA.MA.Create({TimePeriod: this.Settings.PeriodSlowK, MAType: this.Settings.SlowKMAType});
    outSlowK = localMA.calculate(0, outIdx-1, tempBuffer, {TimePeriod: this.Settings.PeriodSlowK, MAType: this.Settings.SlowKMAType, CandleValueIdx: 0});

    var outNBElement = outSlowK.length;

    outSlowK.forEach(function(n,i){tempBuffer[i] = [n]});

    var localMA = TA.MA.Create({TimePeriod: this.Settings.PeriodSlowK, MAType: this.Settings.SlowKMAType});
    outSlowD = localMA.calculate(0, outNBElement-1, tempBuffer, {TimePeriod: this.Settings.PeriodSlowD, MAType: this.Settings.SlowDMAType, CandleValueIdx: 0});

    //outSlowD.forEach(function(n,i){outSlowD[i] = [n]});

    outSlowK = outSlowK.slice(lookbackDSlow);

    return {slowK: outSlowK, slowD: outSlowD};
};

TA.STOCH._lookback = function( optInPeriodFastK, optInPeriodSlowK, optInPeriodSlowD, optInSlowKMAType, optInSlowDMAType ) {

    if( !optInPeriodFastK )
        optInPeriodFastK = this.DefaultSettings.PeriodFastK;
    else if( (optInPeriodFastK < 1) || (optInPeriodFastK > 100000) )
        return -1;

    if( !optInPeriodSlowK )
        optInPeriodSlowK = this.DefaultSettings.PeriodSlowK;
    else if( (optInPeriodSlowK < 1) || (optInPeriodSlowK > 100000) )
        return -1;

    if( !optInSlowKMAType)
        optInSlowKMAType = this.DefaultSettings.SlowKMAType;
    else if( (optInSlowKMAType < 0) || (optInSlowKMAType > 8) )
        return -1;

    if( !optInPeriodSlowD )
        optInPeriodSlowD = this.DefaultSettings.PeriodSlowD;
    else if( (optInPeriodSlowD < 1) || (optInPeriodSlowD > 100000) )
        return -1;

    if( !optInSlowDMAType)
        optInSlowDMAType = this.DefaultSettings.SlowDMAType;
    else if( (optInSlowDMAType < 0) || (optInSlowDMAType > 8) )
        return -1;

    var retValue = optInPeriodFastK - 1;
    retValue += TA.MA._lookback( optInPeriodSlowK, optInSlowKMAType );
    retValue += TA.MA._lookback( optInPeriodSlowD, optInSlowDMAType );

    return retValue;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.TEMA = TA.INDICATOR_TEMPLATE.Create();
else
    TA.TEMA = {};

TA.TEMA.name = 'TEMA';
TA.TEMA.type = 'line';

TA.TEMA.DefaultSettings = {
    CandleValueIdx: TA.CLOSE,
    TimePeriod: 12
};

TA.TEMA.Settings = {};


TA.TEMA._lookback = function(optInTimePeriod) {
    var retValue;
    if (!optInTimePeriod)
        optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if ((optInTimePeriod < 2) || (optInTimePeriod > 100000))
        return -1;
    retValue = TA.EMA._lookback(optInTimePeriod);
    return retValue * 3;
};

TA.TEMA.calculate = function(startIdx, endIdx, dataShape, settings) {
    var outBegIdx, outNBElement,
        firstEMA = [],
        secondEMA = [],
        k,
        firstEMABegIdx,
        firstEMANbElement,
        secondEMABegIdx,
        secondEMANbElement,
        thirdEMABegIdx,
        thirdEMANbElement,
        tempInt, outIdx, lookbackTotal, lookbackEMA,
        firstEMAIdx, secondEMAIdx,
        retCode, outReal = [];

    this.SetSettings(settings);

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!dataShape || !dataShape.length) throw 'TA_BAD_PARAM';
    if (!this.Settings.TimePeriod)
        this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
    else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
        throw 'TA_BAD_PARAM';

    lookbackEMA = TA.EMA._lookback(this.Settings.TimePeriod);

    lookbackTotal = lookbackEMA * 3;
    if (startIdx < lookbackTotal)
        startIdx = lookbackTotal;
    if (startIdx > endIdx) {
        return outReal;
    }

    tempInt = lookbackTotal + (endIdx - startIdx) + 1;

    k = TA.PER_TO_K(this.Settings.TimePeriod);

    var localEMA = TA.EMA.Create({TimePeriod: this.Settings.TimePeriod});

    localEMA._int_ema(startIdx - (lookbackEMA * 3), endIdx, dataShape,
        this.Settings.TimePeriod, k, firstEMA);

    if (!firstEMA.length) {
        return outReal;
    }

    var firstEMAArr = [];
    for(var i=0; i< firstEMA.length; i++) {
        firstEMAArr.push([firstEMA[i]]);
    }
    localEMA.SetSettings({CandleValueIdx: 0});
    localEMA._int_ema(0, firstEMAArr.length - 1, firstEMAArr,
        this.Settings.TimePeriod, k, secondEMA);

    if (!secondEMA.length) {
        return outReal;
    }

    var secondEMAArr = [];
    for(var i=0; i< secondEMA.length; i++) {
        secondEMAArr.push([secondEMA[i]]);
    }

    localEMA.SetSettings({CandleValueIdx: 0});
    localEMA._int_ema(0, secondEMAArr.length - 1, secondEMAArr, this.Settings.TimePeriod, k, outReal);

    if (!outReal.length) {
        return outReal;
    }

    firstEMAIdx = lookbackEMA * 2;
    secondEMAIdx = lookbackEMA;
    outIdx = 0;

    while (outIdx < outReal.length) {
        outReal[outIdx] += (3.0 * firstEMA[firstEMAIdx++]) - (3.0 * secondEMA[secondEMAIdx++]);
        outIdx++;
    }

    return outReal;

};
if (!!TA.INDICATOR_TEMPLATE)
    TA.TRANGE = TA.INDICATOR_TEMPLATE.Create();
else
    TA.TRANGE = {};

TA.TRANGE.name = 'AROON';
TA.TRANGE.type = 'line';

TA.TRANGE.DefaultSettings = {
};

TA.TRANGE.Settings = {};

TA.TRANGE._lookback = function() {
    return 1;
};
TA.TRANGE.calculate = function(startIdx, endIdx, dataShape, settings) {
    var outBegIdx, outNBElement,
        today, outIdx,
        val2, val3, greatest,
        tempCY, tempLT, tempHT,
        outReal = [];

    this.SetSettings(settings);

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (startIdx < 1)
        startIdx = 1;
    if (startIdx > endIdx) {
        return outReal;
    }
    outIdx = 0;
    today = startIdx;
    while (today <= endIdx) {
        tempLT = dataShape[today][TA.LOW];
        tempHT = dataShape[today][TA.HIGH];
        tempCY = dataShape[today][TA.CLOSE];
        greatest = tempHT - tempLT;
        val2 = Math.abs(tempCY - tempHT);
        if (val2 > greatest)
            greatest = val2;
        val3 = Math.abs(tempCY - tempLT);
        if (val3 > greatest)
            greatest = val3;
        outReal[outIdx++] = greatest;
        today++;
    }
    outNBElement = outIdx;
    outBegIdx = startIdx;
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.TRIMA = TA.INDICATOR_TEMPLATE.Create();
else
    TA.TRIMA = {};

TA.TRIMA.name = 'TRIMA';
TA.TRIMA.type = 'line';

TA.TRIMA.DefaultSettings = {
    CandleValueIdx: TA.CLOSE,
    TimePeriod: 20
};

TA.TRIMA.Settings = {};


TA.TRIMA._lookback = function(optInTimePeriod) {
    if (!optInTimePeriod)
        optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if ((optInTimePeriod < 2) || (optInTimePeriod > 100000))
        return -1;
    return optInTimePeriod - 1;
};

TA.TRIMA.calculate = function(startIdx, endIdx, dataShape, settings) {
    var lookbackTotal;
    var numerator;
    var numeratorSub;
    var numeratorAdd;
    var i, outIdx, todayIdx, trailingIdx, middleIdx;
    var factor, tempReal;
    var outReal = [];

    this.SetSettings(settings);

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!dataShape || !dataShape.length) throw 'TA_BAD_PARAM';
    if (!this.Settings.TimePeriod)
        this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
    else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
        throw 'TA_BAD_PARAM';

    lookbackTotal = (this.Settings.TimePeriod - 1);
    if (startIdx < lookbackTotal)
        startIdx = lookbackTotal;
    if (startIdx > endIdx) {
        return outReal;
    }
    outIdx = 0;
    if ((this.Settings.TimePeriod % 2) == 1) {
        i = (this.Settings.TimePeriod >> 1);
        factor = (i + 1) * (i + 1);
        factor = 1.0 / factor;
        trailingIdx = startIdx - lookbackTotal;
        middleIdx = trailingIdx + i;
        todayIdx = middleIdx + i;
        numerator = 0.0;
        numeratorSub = 0.0;
        for (i = middleIdx; i >= trailingIdx; i--) {
            tempReal = dataShape[i][this.Settings.CandleValueIdx];
            numeratorSub += tempReal;
            numerator += numeratorSub;
        }
        numeratorAdd = 0.0;
        middleIdx++;
        for (i = middleIdx; i <= todayIdx; i++) {
            tempReal = dataShape[i][this.Settings.CandleValueIdx];
            numeratorAdd += tempReal;
            numerator += numeratorAdd;
        }
        outIdx = 0;
        tempReal =  dataShape[trailingIdx++][this.Settings.CandleValueIdx];
        outReal[outIdx++] = numerator * factor;
        todayIdx++;
        while (todayIdx <= endIdx) {
            numerator -= numeratorSub;
            numeratorSub -= tempReal;
            tempReal = dataShape[middleIdx++][this.Settings.CandleValueIdx];
            numeratorSub += tempReal;
            numerator += numeratorAdd;
            numeratorAdd -= tempReal;
            tempReal = dataShape[todayIdx++][this.Settings.CandleValueIdx];
            numeratorAdd += tempReal;
            numerator += tempReal;
            tempReal = dataShape[trailingIdx++][this.Settings.CandleValueIdx];
            outReal[outIdx++] = numerator * factor;
        }
    } else {
        i = (this.Settings.TimePeriod >> 1);
        factor = i * (i + 1);
        factor = 1.0 / factor;
        trailingIdx = startIdx - lookbackTotal;
        middleIdx = trailingIdx + i - 1;
        todayIdx = middleIdx + i;
        numerator = 0.0;
        numeratorSub = 0.0;
        for (i = middleIdx; i >= trailingIdx; i--) {
            tempReal = dataShape[i][this.Settings.CandleValueIdx];
            numeratorSub += tempReal;
            numerator += numeratorSub;
        }

        numeratorAdd = 0.0;
        middleIdx++;
        for (i = middleIdx; i <= todayIdx; i++) {
            tempReal = dataShape[i][this.Settings.CandleValueIdx];
            numeratorAdd += tempReal;
            numerator += numeratorAdd;
        }
        outIdx = 0;
        tempReal = dataShape[trailingIdx++][this.Settings.CandleValueIdx];
        outReal[outIdx++] = numerator * factor;
        todayIdx++;
        while (todayIdx <= endIdx) {
            numerator -= numeratorSub;
            numeratorSub -= tempReal;
            tempReal = dataShape[middleIdx++][this.Settings.CandleValueIdx];
            numeratorSub += tempReal;
            numeratorAdd -= tempReal;
            numerator += numeratorAdd;
            tempReal = dataShape[todayIdx++][this.Settings.CandleValueIdx];
            numeratorAdd += tempReal;
            numerator += tempReal;
            tempReal = dataShape[trailingIdx++][this.Settings.CandleValueIdx];
            outReal[outIdx++] = numerator * factor;
        }
    }
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.TYPPRICE = TA.INDICATOR_TEMPLATE.Create();
else
    TA.TYPPRICE = {};

TA.TYPPRICE.name = 'TYPPRICE';
TA.TYPPRICE.type = 'line';

TA.TYPPRICE.DefaultSettings = {
};

TA.TYPPRICE.Settings = {};


TA.TYPPRICE._lookback = function() {
    return 0;
};

TA.TYPPRICE.calculate = function(startIdx, endIdx, dataShape, settings) {
    var outIdx, i, outReal = [];
    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';

    outIdx = 0;
    for (i = startIdx; i <= endIdx; i++) {
        outReal[outIdx++] = (dataShape[i][TA.HIGH] +
            dataShape[i][TA.LOW] +
            dataShape[i][TA.CLOSE]) / 3.0;
    }
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.VAR = TA.INDICATOR_TEMPLATE.Create();
else
    TA.VAR = {};

TA.VAR.name = 'VAR';
TA.VAR.type = 'line';

TA.VAR.DefaultSettings = {
	TimePeriod: 2,
	Deviations: 1,
	CandleValueIdx: TA.CLOSE
};

TA.VAR.Settings = {};

TA.VAR.calculate = function (startIdx, endIdx, dataShape, settings) {
	var tempReal, periodTotal1, periodTotal2, meanValue1, meanValue2;
	var i, outIdx, trailingIdx, nbInitialElementNeeded;
	var outReal = [];

    this.SetSettings(settings);

	if (!startIdx)
		startIdx = 0;

	if (!endIdx)
		endIdx = dataShape.length - 1;

	nbInitialElementNeeded = (this.Settings.TimePeriod - 1);

	if (startIdx < nbInitialElementNeeded)
		startIdx = nbInitialElementNeeded;

	if (startIdx > endIdx) {
		return outReal;
	}

	/* Do the MA calculation using tight loops. */
	/* Add-up the initial periods, except for the last value. */
	periodTotal1 = 0;
	periodTotal2 = 0;
	trailingIdx = startIdx - nbInitialElementNeeded;

	i = trailingIdx;
	if (this.Settings.TimePeriod > 1) {
		while (i < startIdx) {
			tempReal = dataShape[i++][this.Settings.CandleValueIdx];
			periodTotal1 += tempReal;
			tempReal *= tempReal;
			periodTotal2 += tempReal;
		}
	}

	/* Proceed with the calculation for the requested range.
	 * Note that this algorithm allows the inReal and
	 * outReal to be the same buffer.
	 */
	outIdx = 0;
	do {
		tempReal = dataShape[i++][this.Settings.CandleValueIdx];

		/* Square and add all the deviation over
		 * the same periods.
		 */

		periodTotal1 += tempReal;
		tempReal *= tempReal;
		periodTotal2 += tempReal;

		/* Square and add all the deviation over
		 * the same period.
		 */

		meanValue1 = periodTotal1 / this.Settings.CandleValueIdx;
		meanValue2 = periodTotal2 / this.Settings.CandleValueIdx;

		tempReal = dataShape[trailingIdx++][this.Settings.CandleValueIdx];
		periodTotal1 -= tempReal;
		tempReal *= tempReal;
		periodTotal2 -= tempReal;

		outReal[outIdx++] = meanValue2 - meanValue1 * meanValue1;
	} while (i <= endIdx);

	return outReal;
};

TA.VAR.getValue = function(dataShape, itemIdx, settings) {
	
};

TA.VAR._lookback = function(optInTimePeriod, optInNbDev) {
    
    if( !optInTimePeriod )
       optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if( (optInTimePeriod < 1) || (optInTimePeriod > 100000) )
       return -1;
 
    if( !optInNbDev )
       optInNbDev = this.DefaultSettings.Deviations;
    else if( (optInNbDev < -3.000000e+37) ||  (optInNbDev > 3.000000e+37) )
       return -1;
 
   return optInTimePeriod-1;
};

TA.VAR._S = function(startIdx, endIdx, dataShape, settings){
	
};

TA.VAR.initChart = function (dataShape, hcOptions, ticker) {
	if(!!INDICATOR_TEMPLATE)
		INDICATOR_TEMPLATE.initChart.apply(this, arguments);
	
	
};

TA.VAR.SetSettings(TA.VAR.DefaultSettings);


TA.INT_VAR = TA.VAR.Create();

TA.INT_VAR.calculate = function (startIdx, endIdx, dataShape, settings) {
	
	var tempReal, periodTotal1, periodTotal2, meanValue1, meanValue2;
	var i, outIdx, trailingIdx, nbInitialElementNeeded;
	var outReal = [];

    this.SetSettings(settings);

	if (!startIdx)
		startIdx = 0;

	if (!endIdx)
		endIdx = dataShape.length - 1;
	
	nbInitialElementNeeded = (this.Settings.TimePeriod - 1);
	if (startIdx < nbInitialElementNeeded)
		startIdx = nbInitialElementNeeded;
	if (startIdx > endIdx) {
		return outReal;
	}
	
	periodTotal1 = 0;
	periodTotal2 = 0;
	trailingIdx = startIdx - nbInitialElementNeeded;
	i = trailingIdx;
	if (this.Settings.TimePeriod > 1) {
		while (i < startIdx) {
			tempReal = dataShape[i++][this.Settings.CandleValueIdx];
			periodTotal1 += tempReal;
			tempReal *= tempReal;
			periodTotal2 += tempReal;
		}
	}
	outIdx = 0;
	do {
		tempReal = dataShape[i++][this.Settings.CandleValueIdx];
		periodTotal1 += tempReal;
		tempReal *= tempReal;
		periodTotal2 += tempReal;
		meanValue1 = periodTotal1 / this.Settings.TimePeriod;
		meanValue2 = periodTotal2 / this.Settings.TimePeriod;
		tempReal = dataShape[trailingIdx++][this.Settings.CandleValueIdx];
		periodTotal1 -= tempReal;
		tempReal *= tempReal;
		periodTotal2 -= tempReal;
		outReal[outIdx++] = meanValue2 - meanValue1 * meanValue1;
	} while (i <= endIdx);
	
	return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.VPT = TA.INDICATOR_TEMPLATE.Create();
else
    TA.VPT = {};

TA.VPT.name = 'VPT';
TA.VPT.type = 'line';

TA.VPT.DefaultSettings = {
};

TA.VPT.Settings = {};


TA.VPT._lookback = function() {
    return 0;
};

TA.VPT.calculate = function(startIdx, endIdx, dataShape, settings) {
    var outReal = [];
    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';

    var previousClose = dataShape[startIdx][TA.CLOSE];
    outReal[0] = 0;
    for (var i = startIdx + 1; i <= endIdx; ++i)
    {
        outReal[i - startIdx] = outReal[i - startIdx - 1] + (dataShape[i][TA.VOL] * (dataShape[i][TA.CLOSE] - previousClose) / previousClose);
        previousClose = dataShape[i][TA.CLOSE];
    }

    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.WCLPRICE = TA.INDICATOR_TEMPLATE.Create();
else
    TA.WCLPRICE = {};

TA.WCLPRICE.name = 'WCLPRICE';
TA.WCLPRICE.type = 'line';

TA.WCLPRICE.DefaultSettings = {};

TA.WCLPRICE.Settings = {};

TA.WCLPRICE._lookback = function() {
    return 0;
};
TA.WCLPRICE.calculate = function(startIdx, endIdx, dataShape, settings) {
    var outIdx, i, outReal = [];

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';

    outIdx = 0;
    for (i = startIdx; i <= endIdx; i++) {
        outReal[outIdx++] = (dataShape[i][TA.HIGH] +
            dataShape[i][TA.LOW] +
            (dataShape[i][TA.CLOSE] * 2.0)) / 4.0;
    }
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.WILLR = TA.INDICATOR_TEMPLATE.Create();
else
    TA.WILLR = {};

TA.WILLR.name = 'WILLR';
TA.WILLR.type = 'line';

TA.WILLR.DefaultSettings = {
    TimePeriod: 14
};

TA.WILLR.Settings = {};

TA.WILLR._lookback = function(optInTimePeriod) {
    if (!optInTimePeriod)
        optInTimePeriod = this.DefaultSettings.TimePeriod;
    else if ((optInTimePeriod < 2) || (optInTimePeriod > 100000))
        return -1;
    return (optInTimePeriod - 1);
};

TA.WILLR.calculate = function(startIdx, endIdx, dataShape, settings) {
    var lowest, highest, tmp, diff;
    var outIdx, nbInitialElementNeeded;
    var trailingIdx, lowestIdx, highestIdx;
    var today, i;
    var outReal = [];

    this.SetSettings(settings);

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!this.Settings.TimePeriod)
        this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
    else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
        throw 'TA_BAD_PARAM';


    nbInitialElementNeeded = (this.Settings.TimePeriod - 1);
    if (startIdx < nbInitialElementNeeded) {
        startIdx = nbInitialElementNeeded;
    }
    if (startIdx > endIdx) {
        return outReal;
    }

    diff = 0.0;
    outIdx = 0;
    today = startIdx;
    trailingIdx = startIdx - nbInitialElementNeeded;
    lowestIdx = highestIdx = -1;
    diff = highest = lowest = 0.0;
    while (today <= endIdx) {
        tmp = dataShape[today][TA.LOW];
        if (lowestIdx < trailingIdx) {
            lowestIdx = trailingIdx;
            lowest = dataShape[lowestIdx][TA.LOW];
            i = lowestIdx;
            while (++i <= today) {
                tmp = dataShape[i][TA.LOW];
                if (tmp < lowest) {
                    lowestIdx = i;
                    lowest = tmp;
                }
            }
            diff = (highest - lowest) / (-100.0);
        } else if (tmp <= lowest) {
            lowestIdx = today;
            lowest = tmp;
            diff = (highest - lowest) / (-100.0);
        }
        tmp = dataShape[today][TA.HIGH];
        if (highestIdx < trailingIdx) {
            highestIdx = trailingIdx;
            highest = dataShape[highestIdx][TA.HIGH];
            i = highestIdx;
            while (++i <= today) {
                tmp = dataShape[i][TA.HIGH];
                if (tmp > highest) {
                    highestIdx = i;
                    highest = tmp;
                }
            }
            diff = (highest - lowest) / (-100.0);
        } else if (tmp >= highest) {
            highestIdx = today;
            highest = tmp;
            diff = (highest - lowest) / (-100.0);
        }
        if (diff != 0.0) {
            outReal[outIdx++] = (highest - dataShape[today][TA.CLOSE]) / diff;
        } else {
            outReal[outIdx++] = 0.0;
        }
        trailingIdx++;
        today++;
    }
    return outReal;
};
if (!!TA.INDICATOR_TEMPLATE)
    TA.WMA = TA.INDICATOR_TEMPLATE.Create();
else
    TA.WMA = {};

TA.WMA.name = 'WMA';
TA.WMA.type = 'line';

TA.WMA.DefaultSettings = {
	TimePeriod: 30,
	CandleValueIdx: TA.CLOSE
};

TA.WMA.Settings = {};

TA.WMA.calculate = function (startIdx, endIdx, dataShape, settings, dontFillTotalArray) {
	var inIdx, outIdx, i, trailingIdx, divider;
	var periodSum, periodSub, tempReal, trailingValue;
	var lookbackTotal;


	var outReal = [];

    this.SetSettings(settings);

	if(!startIdx)
		startIdx = 0;
	
	if(!endIdx)
		endIdx = dataShape.length - 1;

	if (startIdx < 0)
		throw 'TA_OUT_OF_RANGE_START_INDEX';
	if ((endIdx < 0) || (endIdx < startIdx))
		throw 'TA_OUT_OF_RANGE_END_INDEX';

	if (!dataShape || !dataShape.length)
		throw 'TA_BAD_PARAM';

	if (!this.Settings.TimePeriod)
		this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
	else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
		throw 'TA_BAD_PARAM';

	if (!outReal)
		throw 'TA_BAD_PARAM';

	lookbackTotal = this.Settings.TimePeriod - 1;

/* Move up the start index if there is not
    * enough initial data.
    */
   if( startIdx < lookbackTotal )
      startIdx = lookbackTotal;

   /* Make sure there is still something to evaluate. */
   if( startIdx > endIdx ) {
      return outReal;
   }

   /* To make the rest more efficient, handle exception
    * case where the user is asking for a period of '1'.
    * In that case outputs equals inputs for the requested
    * range.
    */
   if( this.Settings.TimePeriod == 1 ) 
   {      
      return outReal;
   }

   /* Calculate the divider (always an integer value).
    * By induction: 1+2+3+4+'n' = n(n+1)/2
    * '>>1' is usually faster than '/2' for unsigned.
    */

   divider = (this.Settings.TimePeriod*( +(this.Settings.TimePeriod) + 1))/2;

   /* The algo used here use a very basic property of
    * multiplication/addition: (x*2) = x+x
    *   
    * As an example, a 3 period weighted can be 
    * interpreted in two way:
    *  (x1*1)+(x2*2)+(x3*3)
    *      OR
    *  x1+x2+x2+x3+x3+x3 (this is the periodSum)
    *   
    * When you move forward in the time serie
    * you can quickly adjust the periodSum for the
    * period by substracting:
    *   x1+x2+x3 (This is the periodSub)
    * Making the new periodSum equals to:
    *   x2+x3+x3
    *
    * You can then add the new price bar
    * which is x4+x4+x4 giving:
    *   x2+x3+x3+x4+x4+x4
    *
    * At this point one iteration is completed and you can
    * see that we are back to the step 1 of this example.
    *
    * Why making it so un-intuitive? The number of memory
    * access and floating point operations are kept to a
    * minimum with this algo.
    */
   outIdx      = 0;
   trailingIdx = startIdx - lookbackTotal;

   /* Evaluate the initial periodSum/periodSub and trailingValue. */
   periodSum = periodSub = 0.0;
   inIdx=trailingIdx;
   i = 1;
   while( inIdx < startIdx )
   {
      tempReal = dataShape[inIdx++][this.Settings.CandleValueIdx];
      periodSub += tempReal;
      periodSum += tempReal*i;
      i++;
   }
   trailingValue = 0.0;

   /* Tight loop for the requested range. */
   while( inIdx <= endIdx )
   {
      /* Add the current price bar to the sum
       * who are carried through the iterations.
       */
      tempReal = dataShape[inIdx++][this.Settings.CandleValueIdx];
      periodSub += tempReal;
      periodSub -= trailingValue;
      periodSum += tempReal*this.Settings.TimePeriod;

      /* Save the trailing value for being substract at
       * the next iteration.
       * (must be saved here just in case outReal and
       *  inReal are the same buffer).
       */
      trailingValue = dataShape[trailingIdx++][this.Settings.CandleValueIdx];

      /* Calculate the WMA for this price bar. */
      outReal[outIdx++] = periodSum / divider;

      /* Prepare the periodSum for the next iteration. */
      periodSum -= periodSub;
   }

   /* Set output limits. */
    /*
   if(!dontFillTotalArray) {
		if(outReal.length >= dataShape.length)
			throw 'Ошибка расчета ADX';
		else if(outReal.length <= dataShape.length)
			while(outReal.length != dataShape.length){
				outReal.unshift(0);
			}
	}
	*/

   return outReal;
};

TA.WMA.getValue = function (dataShape, itemIdx, settings) {

};

TA.WMA._lookback = function (optInTimePeriod) {

	if (!optInTimePeriod)
		optInTimePeriod = 30;
	else if ((optInTimePeriod < 2) || (optInTimePeriod > 100000))
		return -1;

	return optInTimePeriod - 1;
};

TA.WMA._S = function (startIdx, endIdx, dataShape, settings) {

};

TA.WMA.initChart = function (dataShape, hcOptions, ticker) {
	if (!!INDICATOR_TEMPLATE)
		INDICATOR_TEMPLATE.initChart.apply(this, arguments);


};

TA.WMA.SetSettings(TA.WMA.DefaultSettings);

if (!!TA.INDICATOR_TEMPLATE)
    TA.ZLEMA = TA.INDICATOR_TEMPLATE.Create();
else
    TA.ZLEMA = {};

TA.ZLEMA.name = 'ZLEMA';
TA.ZLEMA.type = 'line';

TA.ZLEMA.DefaultSettings = {
    CandleValueIdx: TA.CLOSE,
    TimePeriod: 12
};

TA.ZLEMA.Settings = {};


TA.ZLEMA._lookback = function(optInTimePeriod) {
    return 0;
};

TA.ZLEMA.calculate = function(startIdx, endIdx, dataShape, settings) {
    var firstEMA = [],
        secondEMA = [],
        tempBuffer = [],
        zlema = [],
        lookbackTotal, lookbackEMA,
        outReal = zlema;

    this.SetSettings(settings);

    if (startIdx < 0)
        throw 'TA_OUT_OF_RANGE_START_INDEX';
    if ((endIdx < 0) || (endIdx < startIdx))
        throw 'TA_OUT_OF_RANGE_END_INDEX';
    if (!dataShape || !dataShape.length) throw 'TA_BAD_PARAM';
    if (!this.Settings.TimePeriod)
        this.Settings.TimePeriod = this.DefaultSettings.TimePeriod;
    else if ((this.Settings.TimePeriod < 2) || (this.Settings.TimePeriod > 100000))
        throw 'TA_BAD_PARAM';

    lookbackEMA = TA.EMA._lookback(this.Settings.TimePeriod);

    lookbackTotal = lookbackEMA;
    if (startIdx < lookbackTotal)
        startIdx = lookbackTotal;
    if (startIdx > endIdx) {
        return outReal;
    }

    var k = TA.PER_TO_K(this.Settings.TimePeriod);
    var lag = Math.ceil((this.Settings.TimePeriod-1) / 2.0);
    var zlema = [];

    for (var i = 0; i<=endIdx; i++) {
        if(i < lag) {
            zlema[i] = dataShape[i][TA.CLOSE];
        } else {
            zlema[i] = k * (2 * dataShape[i][TA.CLOSE] - dataShape[i - lag][TA.CLOSE]) + (1 - k) * zlema[i -1];
        }
    }

    return zlema;

};


/*
TA.INDICATOR_TEMPLATE = function() {
    this.name = '';
    this.type = '';
    this.DefaultSettings = {};
    this.Settings = {};
};

TA.INDICATOR_TEMPLATE.prototype.SetSettings = function (settings) {
    var name;

    if (!!settings) {
        if (settings != this.DefaultSettings) {
            this.SetSettings(this.DefaultSettings);
        }

        for (name in settings) {
            this.Settings[name] = settings[name];
        }
    }
};
*/

(function (){

    "use strict";

    var series = {
        "chartType": "Line",
        "enabled": true,
        "formatProvider": {
            "decimalPlaces": "2",
            "decimalPrecision": null
        },
        "indicatorIndex": 0,
        "indicatorIndex2": 0,
        "kind": "TA_LIB",
        "name": "",
        "overlay": true,
        "points": [],
        "valuesPerPoint": 1,
        "isStartedFromZero": false,
        "color": "",
        "width": 2,
        "chartArea": "ChartArea1",
        "enableMerge": true,
        "index": 2,
        "closeValueIndex": 0,
        "lowValueIndex": 0,
        "highValueIndex": 0,
        "labels": []
    };


    iChart.Charting.TA = function (settings) {
        this.chart = settings.chart;
    };

    /**
     * Добавляет пользовательскую серию на график
     * @param {!bool}   enable  признак - надо добавить серию или удалить.
     * @param {!number} index   порядковый номер индикатора в хеше графика
     * @param {!{?title: string, data: array, ?color: string, ?width: number}} params  параметры выводимого индикатора
     */
    iChart.Charting.TA.prototype.addCustomIndicatorSerie = function (enable, index, params) {
        if (arguments.length < 3) {
            throw _t('14949', 'Неверные параметры для вывода пользовательской серии.');
        }

        if(enable) {

            this.removeIndicator(index);

            var indicatorArea = new iChart.Charting.ChartArea({ "chart": this.chart }),
                indicatorName   = 'ChartAreaI' + index,
                indicatorTitle  = (params.title || indocatorName),
                taData          = params.data,
                taDataLength    = taData.length;

            indicatorArea.axisX.showLabels  = false;
            indicatorArea.enabled           = true;
            indicatorArea.xSeries           = this.chart.areas[0].xSeries;
            indicatorArea.ySeries           = [];
            indicatorArea.name              = indicatorName;

            indicatorArea.title = indicatorTitle;

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = [];

            Series[0] = $.extend(true, {}, series);
            Series[0].indicatorIndex = index || 0;

            Series[0].color = params.color || this.chart.chartOptions.indicatorColors[index][0];
            Series[0].width = params.width || 2;

            Series[0].name      = indicatorTitle;
            Series[0].labels    = this.getLabels(Series[0], []);

            var chartSeries = this.getData();

            for(var j=0; j < taDataLength; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            //console.log(indicatorArea);
            this.chart.areas.push(indicatorArea);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: indicatorArea.title, params: null, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.getDefaultParams = function (indicator) {
        var result = {};
        $.each(iChart.indicators[indicator].parameters, function(i, param){
            result[param.Code] = param.Value;
        });

        return result;
    };

    iChart.Charting.TA.prototype.getSeries = function (indicator, params) {

        indicator = indicator || "Volume";
        params = params || "";

        var areas = this.chart.areas;
        for(var i=0; i<areas.length; i++) {
            var found = -1;
            for(var j=0; j<areas[i].ySeries.length; j++) {
                if(areas[i].ySeries[j].kind === "TechnicalAnalysis") {
                    var sNameMatch = areas[i].ySeries[j].name.match(/(.+)\s\((.*)\)/);
                    if(sNameMatch && sNameMatch[1] === indicator && sNameMatch[2] == params) {
                        found = j;
                        break;
                    }
                } else if (areas[i].ySeries[j].kind === indicator) {
                    found = j;
                    break;
                }
            }
            if(found >= 0) {
                break;
            }
        }

        if(found >= 0) {
            //console.log(i,j);
            return {
                xSeries:  this.chart.areas[i].xSeries.slice(0,this.chart.areas[i].xSeries.length - this.chart.chartOptions.futureAmount),
                ySeries:  this.chart.areas[i].ySeries[j].points.slice(0,this.chart.areas[i].xSeries.length - this.chart.chartOptions.futureAmount)
            };
        }

        return false;
    };

    iChart.Charting.TA.prototype.getData = function () {

        var xSeries = this.chart.areas[0].xSeries;
        var ySeries = this.chart.areas[0].ySeries[0];
        var valueSeries = this.getSeries('Volume');

        if(!valueSeries) {
            valueSeries = {};
            valueSeries.ySeries = [];
        }

        var dataShape = [];

        for(var i=0; i<xSeries.length - this.chart.chartOptions.futureAmount; i++) {
            var dateTime = new Date(xSeries[i] * 1000);
            iChart.formatDateTime(dateTime);
            var data = [
                "",
                this.chart._dataSettings.timeframe,
                iChart.formatDateTime(dateTime, 'yyyyMMdd'),
                iChart.formatDateTime(dateTime, 'HHmmss'),
                ySeries['points'][i] != null ? ySeries['points'][i][2] : dataShape[i-1][4],
                ySeries['points'][i] != null ? ySeries['points'][i][0] : dataShape[i-1][5],
                ySeries['points'][i] != null ? ySeries['points'][i][1] : dataShape[i-1][6],
                ySeries['points'][i] != null ? ySeries['points'][i][3] : dataShape[i-1][7],
                valueSeries.ySeries[i] != null ? valueSeries.ySeries[i][0] : 0,
                iChart.formatDateTime(dateTime, 'yyyy-MM-ddTHH:mm:ss'),
                dateTime.getTime(),
                iChart.formatDateTime(dateTime, 'yyyy-MM-ddTHH:mm:ss')
            ];
            dataShape[i] = data;
        }
        //["MTLR","15","20150105","101500",24.5,24.51,23.43,23.91,91345,"2015-01-05T07:15:00.000Z",1420442100000,"2015-01-05T10:15:00"]

        return dataShape;
    };

    iChart.Charting.TA.prototype.mapParam = function (param) {
        var map = {
            "TimePeriod":       'Period',
            "PeriodROC":        'PeriodROC',
            "shift":            'Shift',
            "DeviationsUp":     'StdDevUp',
            "DeviationsDown":   'StdDevDown'
        };
        var result = map[param] || '';

        return result;
    };

    iChart.Charting.TA.prototype.test = function () {
        var TimePeriod = parseInt(this.chart._dataSettings.i0_Period);
        var data = this.getData();
        var result = EMA.calculate(null, null, data, {TimePeriod: TimePeriod});
        var empty = Array(TimePeriod-1);

        result = empty.concat(result);

        var values = this.getSeries('EMA', TimePeriod).ySeries;
        for(var i=0; i<values.length; i++) {
            console.log(i, values[i], result[i], "cl=" + data[i][CLOSE], 'dt=' + (100-values[i]/result[i]*100));
        }

        //console.log(result);
        //return result;
    };

    /**
     * Удалить области индикаторов с графика
     * @param index индеск индикатора.
     * undefined - Удалить все
     */
    iChart.Charting.TA.prototype.removeIndicator = function (index) {
        if(typeof this.chart != "undefined" && !$.isEmptyObject(this.chart.areas)) {
            for (var i = 0; i < this.chart.areas.length; ++i) {
                var a = this.chart.areas[i];

                var indicatorIndex = [];
                for (var j = 0; j < a.ySeries.length; ++j) {
                    if (a.ySeries[j].kind === "TA_LIB" && (a.ySeries[j].indicatorIndex == index || typeof index == 'undefined')) {
                        indicatorIndex.push(a.ySeries[j].indicatorIndex);
                        a.ySeries.splice(j, 1);
                        --j;
                    }
                }
                if (indicatorIndex.length) {
                    if (a.ySeries.length === 0) {
                        if(typeof a.overlay != "undefined") {
                            $(a.overlay.canvas).remove();
                        }
                        var removed = this.chart.areas.splice(i, 1);
                        removed[0].dispose();
                        --i;
                    } else {
                        if(a.title) {
                            a.title = '';
                            $.each(a.ySeries, function (i, series) {
                                if (series.kind === "TA_LIB") {
                                    var legendParams = Object.keys(series.params).map(function (key) {
                                        return series.params[key]
                                    });
                                    a.title += (a.title ? ', ' : '') + (series.name + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));
                                }
                            });
                        }
                    }
                }
            }
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        }
    };

    iChart.Charting.TA.prototype.findArea = function (name) {
        if(typeof this.chart != "undefined" && !$.isEmptyObject(this.chart.areas)) {
            for (var i = 0; i < this.chart.areas.length; ++i) {
                var area = this.chart.areas[i];

                if(area.name == name) {
                    return area;
                }
            }
        }
        return false;
    };

    iChart.Charting.TA.prototype.TRPLN = function (enable, index) {
        if(enable) {
            var amount = 80;
            var c = $('<canvas>').get(0);
            var ctx = iChart.getContext(c);
            var grd = ctx.createLinearGradient(0, 0, amount, 0);
            grd.addColorStop(1, "#016D06");
            grd.addColorStop(0.5, "#FF9B08");
            grd.addColorStop(0, "#FF1608");
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, amount, 1);
            var imgData=ctx.getImageData(0,0,amount,1);
            var colors = [];
            for (var i=0;i<imgData.data.length;i+=4)
            {
                var color = "rgb(" + imgData.data[i] + "," + imgData.data[i+1] + "," + imgData.data[i+2] + ")";
                colors.push(color);
            }

            var chartSeries = this.getData();
            var step = 2;
            var taData = Array(amount);
            for(var i=0; i<amount; i++) {
                taData[i] = TA.SMA.justifyCalculate(0, chartSeries.length-1, chartSeries, {TimePeriod: step}, 1);
                var iSeries = $.extend(true, {}, series);
                iSeries.name = "TRPLN" + (i < amount-1 ? '_' + i : ''); //Последняя линия даст команду на пересчет индикатора при обновлении данных
                iSeries.indicatorIndex = index;
                iSeries.color = colors[i];
                iSeries.width = 1;

                for(var j=0; j<taData[i].length; j++) {
                    iSeries.points.push([taData[i][j] === 0 ? null : taData[i][j]]);
                }

                this.chart.areas[0].ySeries.push(iSeries);

                step = step + (step < 100 ? 2 : 3);
            }
            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: "TRPLN", params: null, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.createSeries = function (indicator, index) {
        var iSeries = [];
        index = index || 0;
        for (var i=0; i<this.chart.env.viewData.indicators[indicator].output; i++) {
            iSeries[i] = $.extend(true, {}, series);
            iSeries[i].indicatorIndex = index;

            var colorIndex = index%(this.chart.chartOptions.indicatorColors.length-1);
            var color = this.chart.chartOptions.indicatorColors[colorIndex][i];

            if (this.chart.env.userSettings.chartSettings.indicatorsColor[indicator] &&
                this.chart.env.userSettings.chartSettings.indicatorsColor[indicator][index] &&
                this.chart.env.userSettings.chartSettings.indicatorsColor[indicator][index][i]
            ){
                color = this.chart.env.userSettings.chartSettings.indicatorsColor[indicator][index][i];
            }

            var width = 2;
            if (this.chart.env.userSettings.chartSettings.indicatorsWidth[indicator] &&
                this.chart.env.userSettings.chartSettings.indicatorsWidth[indicator][index] &&
                this.chart.env.userSettings.chartSettings.indicatorsWidth[indicator][index][i]
            ){
                width = this.chart.env.userSettings.chartSettings.indicatorsWidth[indicator][index][i];
            }

            iSeries[i].color = color;
            iSeries[i].width = width;
            iSeries[i].name = indicator;

        }
        return iSeries;
    };

    iChart.Charting.TA.prototype.getLabels = function (Series, params, sufix) {
        var legendParams = [];
        sufix = sufix || '';
        for(var k in params) {
            legendParams.push(params[k])
        }
        legendParams = legendParams.length ? "(" + legendParams.join(",") + ")" : '';

        var color = Series.color.replace(/rgba\((.+),[^,]+\)/, "rgb($1)");
        var $label = $("<span/>", { "class": "m-chart-legend-color" }).css({ "background-color": color }).html("&nbsp;");
        $label = $label.add($("<span/>", { "class": "m-chart-legend-name" }).css({ "color": color }).text(Series.name + legendParams + sufix));
        var labelHtml = $("<div/>").append($label).html();
        return [[0, labelHtml, Series.name + legendParams + sufix]];

    };

    iChart.Charting.TA.prototype.BBANDS = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'BBANDS',
            params = params || this.getDefaultParams(INDICATOR);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params);

            var Series = this.createSeries(INDICATOR, index);
            //------------------------------------------------------------------------------------------------------------------------
            Series[0].labels = this.getLabels(Series[0], params, ' Upper');
            Series[0].params = params;
            //Series[0].chartType = "Point";

            for (var j = 0; j < taData['UpperBand'].length; j++) {
                Series[0].points.push([taData['UpperBand'][j] === 0 ? null : taData['UpperBand'][j]]);
            }
            this.chart.areas[0].ySeries.push(Series[0]);

            //------------------------------------------------------------------------------------------------------------------------
            Series[1].labels = this.getLabels(Series[1], params, ' Middle');
            Series[1].params = params;

            for (var j = 0; j < taData['MiddleBand'].length; j++) {
                Series[1].points.push([taData['MiddleBand'][j] === 0 ? null : taData['MiddleBand'][j]]);
            }
            this.chart.areas[0].ySeries.push(Series[1]);

            //------------------------------------------------------------------------------------------------------------------------
            Series[2].labels = this.getLabels(Series[2], params, ' Lower');
            Series[2].params = params;

            for (var j = 0; j < taData['LowerBand'].length; j++) {
                Series[2].points.push([taData['LowerBand'][j] === 0 ? null : taData['LowerBand'][j]]);
            }
            this.chart.areas[0].ySeries.push(Series[2]);
            //------------------------------------------------------------------------------------------------------------------------

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.AD = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'AD',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            var indicatorArea = new iChart.Charting.ChartArea({ "chart": this.chart });
            indicatorArea.axisX.showLabels = false;
            indicatorArea.enabled = true;
            indicatorArea.xSeries = this.chart.areas[0].xSeries;
            indicatorArea.ySeries = [];
            indicatorArea.name = areaName;
            indicatorArea.title = INDICATOR;

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            this.chart.areas.push(indicatorArea);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.ADOSC = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'ADOSC',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.ADX = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'ADX',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.ADXDI = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'ADXDI',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);

            Series[0].params = params;
            Series[0].chartArea = indicatorArea.name;
            Series[0].labels = this.getLabels(Series[0], params);

            var taData = {};
            var chartSeries = this.getData();
            taData['ADX'] = TA.ADX.justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData['ADX'].length; j++) {
                Series[0].points.push([taData['ADX'][j] === 0 ? null : taData['ADX'][j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            Series[1].name = "ADXDI";
            Series[1].params = params;
            Series[1].chartArea = indicatorArea.name;
            Series[1].labels = this.getLabels(Series[1], params, ' +DI');

            var chartSeries = this.getData();
            taData['PLUS_DI'] = TA.PLUS_DI.justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData['PLUS_DI'].length; j++) {
                Series[1].points.push([taData['PLUS_DI'][j] === 0 ? null : taData['PLUS_DI'][j]]);
            }

            indicatorArea.ySeries.push(Series[1]);

            Series[2].name = "ADXDI";
            Series[2].params = params;
            Series[2].chartArea = indicatorArea.name;
            Series[2].labels = this.getLabels(Series[2], params, ' -DI');

            var chartSeries = this.getData();
            taData['MINUS_DI'] = TA.MINUS_DI.justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData['MINUS_DI'].length; j++) {
                Series[2].points.push([taData['MINUS_DI'][j] === 0 ? null : taData['MINUS_DI'][j]]);
            }

            indicatorArea.ySeries.push(Series[2]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.AROON = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'AROON',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params);

            var Series = this.createSeries(INDICATOR, index);

            Series[0].chartArea = indicatorArea.name;
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params, ' Down');

            for (var j = 0; j < taData['AroonDown'].length; j++) {
                Series[0].points.push([taData['AroonDown'][j] === 0 ? null : taData['AroonDown'][j]]);
            }
            indicatorArea.ySeries.push(Series[0]);

            //----------------------------------------------------------------------------------
            Series[1].chartArea = indicatorArea.name;
            Series[1].params = params;
            Series[1].labels = this.getLabels(Series[1], params, ' Up');

            for (var j = 0; j < taData['AroonUp'].length; j++) {
                Series[1].points.push([taData['AroonUp'][j] === 0 ? null : taData['AroonUp'][j]]);
            }

            indicatorArea.ySeries.push(Series[1]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.ATR = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'ATR',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.CCI = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'CCI',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.CHV = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'CHV',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.DPO = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'DPO',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.EMA = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'EMA';
            params = params || this.getDefaultParams(INDICATOR);

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params);
            for (var j = 0; j < taData.length; j++) {

                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            this.chart.areas[0].ySeries.push(Series[0]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.ENV = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'ENV';
            params = params || this.getDefaultParams(INDICATOR);
            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params, 1);

            var Series = this.createSeries(INDICATOR, index);
            //------------------------------------------------------------------------------------------------------------------------

            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[1], params, ' Upper');

            for (var j = 0; j < taData['Upper'].length; j++) {
                Series[0].points.push([taData['Upper'][j] === 0 ? null : taData['Upper'][j]]);
            }
            this.chart.areas[0].ySeries.push(Series[0]);

            //------------------------------------------------------------------------------------------------------------------------

            Series[1].labels = this.getLabels(Series[0], params, ' Lower');

            for (var j = 0; j < taData['Lower'].length; j++) {
                Series[1].points.push([taData['Lower'][j] === 0 ? null : taData['Lower'][j]]);
            }
            this.chart.areas[0].ySeries.push(Series[1]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.MACD = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'MACD',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params);

            var indicatorArea = new iChart.Charting.ChartArea({ "chart": this.chart });
            indicatorArea.axisX.showLabels = false;
            indicatorArea.enabled = true;
            indicatorArea.xSeries = this.chart.areas[0].xSeries;
            indicatorArea.ySeries = [];
            indicatorArea.name = areaName;
            indicatorArea.title = '';

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);

            //------------------------------------------------------------------------------------------------------------------------
            Series[0].params = params;
            Series[0].indicatorIndex = index;
            Series[0].labels = this.getLabels(Series[0], params);

            for (var j = 0; j < taData['MACD'].length; j++) {
                Series[0].points.push([taData['MACD'][j] === 0 ? null : taData['MACD'][j]]);
            }
            indicatorArea.ySeries.push(Series[0]);

            //------------------------------------------------------------------------------------------------------------------------
            Series[1].params = params;
            Series[1].indicatorIndex = index;
            Series[1].labels = this.getLabels(Series[1], params);

            for (var j = 0; j < taData['MACDSignal'].length; j++) {
                Series[1].points.push([taData['MACDSignal'][j] === 0 ? null : taData['MACDSignal'][j]]);
            }
            indicatorArea.ySeries.push(Series[1]);

            //------------------------------------------------------------------------------------------------------------------------
            Series[2].params = params;
            Series[2].indicatorIndex = index;
            Series[2].chartType = "Column";
            Series[2].labels = this.getLabels(Series[2], params);

            for (var j = 0; j < taData['MACDHist'].length; j++) {
                Series[2].points.push([taData['MACDHist'][j] === 0 ? null : taData['MACDHist'][j]]);
            }
            indicatorArea.ySeries.push(Series[2]);
            //------------------------------------------------------------------------------------------------------------------------
            this.chart.areas.push(indicatorArea);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }
            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.MEDPRICE = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'MEDPRICE';
            params = params || this.getDefaultParams(INDICATOR);

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params);
            for (var j = 0; j < taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            this.chart.areas[0].ySeries.push(Series[0]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.MFI = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'MFI',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.OBV = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'OBV',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
            indicatorArea.axisX.showLabels = false;
            indicatorArea.enabled = true;
            indicatorArea.xSeries = this.chart.areas[0].xSeries;
            indicatorArea.ySeries = [];
            indicatorArea.name = areaName;
            indicatorArea.title = '';
            this.chart.areas.push(indicatorArea);

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.PSAR = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'PSAR';
            params = params || this.getDefaultParams(INDICATOR);

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);
            Series[0].chartType = "Point";

            var chartSeries = this.getData();
            var taData = TA.SAR.justifyCalculate(0, chartSeries.length - 1, chartSeries, params);
            for (var j = 0; j < taData.length; j++) {

                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            this.chart.areas[0].ySeries.push(Series[0]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.ROC = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'ROC',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);
            Series[0].chartArea = indicatorArea.name;

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.RSI = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'RSI',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                indicatorArea.overlay = new iChart.Charting.ChartAreaLayer(this.chart);

                var element = indicatorArea.overlay.createElement("HorizontalLine");
                element.points = [{'x':$.now(), 'y':30}];
                element.hasSettings = true;
                element.setSettings({drawLabel: false, strokeStyle: "#ff5555", lineWidth: 1});
                indicatorArea.overlay.history.push(element);

                var element = indicatorArea.overlay.createElement("HorizontalLine");
                element.points = [{'x':$.now(), 'y':70}];
                element.hasSettings = true;
                element.setSettings({drawLabel: false, strokeStyle: "#ff5555", lineWidth: 1});
                indicatorArea.overlay.history.push(element);

                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params);

            for(var j=0; j<taData.length; j++) {

                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            //console.log(indicatorArea);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: "RSI", params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.SMA = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'SMA';
            params = params || this.getDefaultParams(INDICATOR);

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params, 1);
            for (var j = 0; j < taData.length; j++) {

                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            this.chart.areas[0].ySeries.push(Series[0]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.STDDEV = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'STDDEV',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);
            Series[0].chartArea = indicatorArea.name;

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.TEMA = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'TEMA';
            params = params || this.getDefaultParams(INDICATOR);

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            this.chart.areas[0].ySeries.push(Series[0]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.TRIMA = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'TRIMA';
            params = params || this.getDefaultParams(INDICATOR);

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params);
            for (var j = 0; j < taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            this.chart.areas[0].ySeries.push(Series[0]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.TYPPRICE = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'TYPPRICE';
            params = params || this.getDefaultParams(INDICATOR);

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params);
            for (var j = 0; j < taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            this.chart.areas[0].ySeries.push(Series[0]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.VPT = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'VPT',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
            indicatorArea.axisX.showLabels = false;
            indicatorArea.enabled = true;
            indicatorArea.xSeries = this.chart.areas[0].xSeries;
            indicatorArea.ySeries = [];
            indicatorArea.name = areaName;
            indicatorArea.title = '';
            this.chart.areas.push(indicatorArea);

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);
            Series[0].indicatorIndex = index;

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.WCLPRICE = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'WCLPRICE';
            params = params || this.getDefaultParams(INDICATOR);

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params);
            for (var j = 0; j < taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            this.chart.areas[0].ySeries.push(Series[0]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.WILLR = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'WILLR',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            indicatorArea = this.findArea(areaName);

            if(!indicatorArea) {
                var indicatorArea = new iChart.Charting.ChartArea({"chart": this.chart});
                indicatorArea.axisX.showLabels = false;
                indicatorArea.enabled = true;
                indicatorArea.xSeries = this.chart.areas[0].xSeries;
                indicatorArea.ySeries = [];
                indicatorArea.name = areaName;
                indicatorArea.title = '';
                this.chart.areas.push(indicatorArea);
            }

            var legendParams = Object.keys(params).map(function (key) {return params[key]});
            indicatorArea.title += (indicatorArea.title ? ', ' : '') +  (INDICATOR + (legendParams.length ? "(" + legendParams.join(",") + ")" : ''));

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);
            Series[0].indicatorIndex = index;

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length-1, chartSeries, params, 1);
            for(var j=0; j<taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            indicatorArea.ySeries.push(Series[0]);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.WMA = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'WMA';
            params = params || this.getDefaultParams(INDICATOR);

            var Series = this.createSeries(INDICATOR, index);
            Series[0].params = params;
            Series[0].labels = this.getLabels(Series[0], params);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params, 1);

            for (var j = 0; j < taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }

            this.chart.areas[0].ySeries.push(Series[0]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.STOCH = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'STOCH',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            var indicatorArea = new iChart.Charting.ChartArea({ "chart": this.chart });
            indicatorArea.axisX.showLabels = false;
            indicatorArea.enabled = true;
            indicatorArea.xSeries = this.chart.areas[0].xSeries;
            indicatorArea.ySeries = [];
            indicatorArea.name = areaName;
            indicatorArea.title = INDICATOR;
            indicatorArea.overlay = new iChart.Charting.ChartAreaLayer(this.chart);

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params);

            var Series = this.createSeries(INDICATOR, index);

            Series[0].params = params;
            Series[0].indicatorIndex = index;
            Series[0].labels = this.getLabels(Series[0], params, 'K');

            for (var j = 0; j < taData['slowK'].length; j++) {
                Series[0].points.push([taData['slowK'][j] === 0 ? null : taData['slowK'][j]]);
            }
            indicatorArea.ySeries.push(Series[0]);

            //------------------------------------------------------------------------------------------------------------------------
            Series[1].params = params;
            Series[1].indicatorIndex = index;
            Series[1].labels = this.getLabels(Series[1], params, "D");

            for (var j = 0; j < taData['slowD'].length; j++) {
                Series[1].points.push([taData['slowD'][j] === 0 ? null : taData['slowD'][j]]);
            }
            indicatorArea.ySeries.push(Series[1]);

            var element = indicatorArea.overlay.createElement("HorizontalLine");
            element.points = [{'x':$.now(), 'y':20}];
            element.hasSettings = true;
            element.setSettings({drawLabel: false, strokeStyle: "#ff5555", lineWidth: 1});
            indicatorArea.overlay.history.push(element);

            var element = indicatorArea.overlay.createElement("HorizontalLine");
            element.points = [{'x':$.now(), 'y':80}];
            element.hasSettings = true;
            element.setSettings({drawLabel: false, strokeStyle: "#ff5555", lineWidth: 1});
            indicatorArea.overlay.history.push(element);

            this.chart.areas.push(indicatorArea);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.ELDR = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'ELDR',
                areaName = 'ChartAreaI_' + index + '_' + INDICATOR;
            params = params || this.getDefaultParams(INDICATOR);

            var indicatorArea = new iChart.Charting.ChartArea({ "chart": this.chart });
            indicatorArea.axisX.showLabels = false;
            indicatorArea.enabled = true;
            indicatorArea.xSeries = this.chart.areas[0].xSeries;
            indicatorArea.ySeries = [];
            indicatorArea.name = areaName;
            indicatorArea.title = INDICATOR;

            indicatorArea.onClose = function ()
            {
                this.chart.clearIndicators(this);
            };

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params);

            var Series = this.createSeries(INDICATOR, index);


            Series[0].params = params;
            Series[0].indicatorIndex = index;
            Series[0].chartType = "Column";
            Series[0].labels = this.getLabels(Series[0], params);

            for (var j = 0; j < taData['ELDR'].length; j++) {
                Series[0].points.push([taData['ELDR'][j] === 0 ? null : taData['ELDR'][j]]);
            }
            indicatorArea.ySeries.push(Series[0]);

            //------------------------------------------------------------------------------------------------------------------------
            Series[1].params = params;
            Series[1].indicatorIndex = index;
            Series[1].name = 'Signal';
            Series[1].labels = this.getLabels(Series[1], params);

            for (var j = 0; j < taData['Signal'].length; j++) {
                Series[1].points.push([taData['Signal'][j] === 0 ? null : taData['Signal'][j]]);
            }
            indicatorArea.ySeries.push(Series[1]);

            //------------------------------------------------------------------------------------------------------------------------
            Series[2].params = params;
            Series[2].indicatorIndex = index;
            Series[2].name = 'Smooth';
            Series[2].labels = this.getLabels(Series[2], {p:2});

            for (var j = 0; j < taData['Smooth'].length; j++) {
                Series[2].points.push([taData['Smooth'][j] === 0 ? null : taData['Smooth'][j]]);
            }
            indicatorArea.ySeries.push(Series[2]);

            //------------------------------------------------------------------------------------------------------------------------
            Series[3].params = params;
            Series[3].indicatorIndex = index;
            Series[3].name = 'EMA';
            Series[3].labels = this.getLabels(Series[3], params);

            for (var j = 0; j < taData['EMA'].length; j++) {
                Series[3].points.push([taData['EMA'][j] === 0 ? null : taData['EMA'][j]]);
            }

            this.chart.areas[0].ySeries.push(Series[3]);

            this.chart.areas.push(indicatorArea);

            for (var i = 0; i < this.chart.areas.length; ++i)
            {
                this.chart.areas[i].setMinMax();
            }

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({ "forceRecalc": true, "resetViewport": false, "testForIntervalChange": false });

        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.ZLEMA = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'ZLEMA';
            params = params || this.getDefaultParams(INDICATOR);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params);

            var Series = this.createSeries(INDICATOR, index);
            //------------------------------------------------------------------------------------------------------------------------
            Series[0].labels = this.getLabels(Series[0], params);
            Series[0].params = params;

            for (var j = 0; j < taData.length; j++) {
                Series[0].points.push([taData[j] === 0 ? null : taData[j]]);
            }
            this.chart.areas[0].ySeries.push(Series[0]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

    iChart.Charting.TA.prototype.PCH = function (enable, index, params) {
        if(enable) {
            var INDICATOR = 'PCH';
            params = params || this.getDefaultParams(INDICATOR);

            var chartSeries = this.getData();
            var taData = TA[INDICATOR].justifyCalculate(0, chartSeries.length - 1, chartSeries, params);

            var Series = this.createSeries(INDICATOR, index);
            //------------------------------------------------------------------------------------------------------------------------
            Series[0].labels = this.getLabels(Series[0], params, ' Lower');
            Series[0].params = params;
            //Series[0].chartType = "Point";

            for (var j = 0; j < taData['low'].length; j++) {
                Series[0].points.push([taData['low'][j] === 0 ? null : taData['low'][j]]);
            }
            this.chart.areas[0].ySeries.push(Series[0]);

            //------------------------------------------------------------------------------------------------------------------------
            Series[1].labels = this.getLabels(Series[1], params, ' Upper');
            Series[1].params = params;

            for (var j = 0; j < taData['high'].length; j++) {
                Series[1].points.push([taData['high'][j] === 0 ? null : taData['high'][j]]);
            }
            this.chart.areas[0].ySeries.push(Series[1]);

            $(this.chart.env.container).trigger('iguanaChartEvents', ['indicatorDataReady', {name: INDICATOR, params: params, data:taData}]);
            this.chart.render({"forceRecalc": true, "resetViewport": false, "testForIntervalChange": false});
        } else {
            this.removeIndicator(index);
        }
    };

})();


/**
 * Created by gti on 09.02.17.
 */

iChart.Charting.TA.prototype.analyseResistSupport = function (TimePeriod , offset) {

    TimePeriod = TimePeriod || 8;
    offset = offset || 0;

    var data = this.getData();
    var data = data.slice(0,data.length-offset);
    var low = [], high = [];

    var dataRsi = [];

    try {
        var dataRsi = TA.RSI.justifyCalculate(0, data.length-1, data, {TimePeriod: TimePeriod});
    } catch (e) {
        console.log(e);
    }


    $.each(data, function(i,n) {
        low.push(n[TA.LOW]);
        high.push(n[TA.HIGH]);
    });

    var Distans = 13.0;     // Смещение уровня RSI
    var Period_Trade = 1;//this.chart..userSettings.dataSettings.timeframe;
    var Low_RSI = 35.0;  // Нижний уровень RSI для нахождения экстремумов
    var High_RSI= 65.0;  // Верхний уровень RSI для нахождения экстремумов

    var First_Ext;

    var Candles_Ext = {
        p_1: false,
        p_2: false,
        p_3: false,
        p_4: false
    };

    function Ext_1( low, high, candles, dataRsi, distans)
    {
        var m_rsi = [], m_high = [], m_low = []; //инициализация массивов

        for(var i=candles.length-1; i>=0; i--) {
            m_low.push(candles[i][TA.LOW]);
            m_high.push(candles[i][TA.HIGH]);
            m_rsi.push(dataRsi[i]);
        };

        //console.log(m_low, m_high, m_rsi);

        var index = -1;     //инициализация переменной, которая будет содержать индекс искомого бара
        var flag=false;        //эта переменная нужна, чтобы не анализировать свечи на текущем незавершенном тренде
        var ext_max = true;    //переменные типа bool используются для того, чтобы в нужный момент прекратить анализ баров
        var ext_min = true;
        var min=100000000.0;  //переменные для выявления максимальных и минимальных цен
        var max= 0.0;

        for(var i=0;i<candles.length;i++) //цикл по барам
        {
            var rsi = m_rsi[i];                                   //получаем значения индикатора RSI
            var price_max = m_high[i]; //NormalizeDouble(m_high[i], digits);   //цены High
            var price_min = m_low[i]; //NormalizeDouble(m_low[i], digits);    //цены Low выбранного бара

            if(flag==false) //условие для того, чтобы не начать искать экстремум на незавершившемся тренде
            {
                if(rsi<=low||rsi>=high) //если первые бары в зонах перекупл. или перепрод.,
                    continue;            //то переходим к следующему бару
                else flag = true;       //если нет, то продолжаем анализ
            }
            if(rsi<low) //если найдено пересечение RSI c уровнем low
            {
                if(ext_min==true) //если RSI еще не пересекал уровень high
                {
                    if(ext_max==true) //если еще не выставлен запрет на поиск максимального экстремума,
                    {
                        ext_max=false; //то запрещаем искать максимальный экстремум
                        if(distans>=0) high=high-distans; //изменяем уровень high, по которому потом
                    }                                  //будет производиться поиск второго бара
                    if(price_min<min) //ищем и замоминаем индекс первого бара
                    {               //сравнивая цены Low свечей
                        min=price_min;
                        index=i;
                    }
                }
                else break; //Выходим из цикла, поскольку раз искать минимальный экстремум уже запрещено,значит найден уже максимальный
            }
            if(rsi>high) //далее алгоритм тот же, только по поиску максимального экстремума
            {
                if(ext_max==true)
                {
                    if(ext_min==true)
                    {
                        ext_min=false; //если нужно, запрещаем искать минимальный экстремум
                        if(distans>=0) low=low+distans;
                    }
                    if(price_max>max) //ищем и запоминаем экстремум
                    {
                        max=price_max;
                        index=i;
                    }
                }
                else break; //Выходим из цикла, поскольку раз искать максимальный экстремум уже запрещено, значит найден уже минимальный
            }
        }
        //console.log(index, m_rsi[index]);
        return(index);
    }

    function Ext_2( low, high, candles, dataRsi, candles_ext, n_bar, distans, first_ext)
    {
        var m_rsi = [], m_high = [], m_low = []; //инициализация массивов

        var rev_candles = [];
        for(var i=candles.length-1; i>=0; i--) {
            rev_candles.push(candles[i]);
        }
        candles = rev_candles;

        for(var i=0; i<candles.length; i++) {
            m_low.push(candles[i][TA.LOW]);
            m_high.push(candles[i][TA.HIGH]);
            m_rsi.push(dataRsi[dataRsi.length-1 - i]);
        };

        //console.log(m_low, m_high, m_rsi);

        var index=-1;
        var p_1=-1;    //индекс искомого бара, индекс предыдущего бара
        var high_level=false; //переменные для определения типа искомого бара
        var low_level = false;
        var _start=false;    //переменные типа bool используются для того, чтобы в нужный момент прекратить анализ баров
        var rsi,min,max,price_max,price_min;
        min=100000000.0; max=0.0;

        //--- в данном блоке определяем, на какой линии (сопротивления или поддержки) должен лежать искомый экстремум
        if(n_bar!=3)
        {
            if(first_ext==true)//если первая точка была максимальной
            {
                low_level=true;//то эта должна быть минимальной
                if(distans>=0) low=low+distans;
            }
            else //если минимальной
            {
                high_level = true;
                if(distans>=0) high = high-distans;
            }
        }
        else
        {
            if(first_ext==false)//если первая точка была минимальной
            {
                low_level=true;//то  и эта должна быть минимальной
                if(distans>=0) high=high-distans;
            }
            else //если максимальной
            {
                high_level = true;
                if(distans>=0) low = low+distans;
            }
        }

        switch(n_bar) //находим индекс предыдущего бара
        {
            case 2: p_1 = candles_ext.p_1; break;
            case 3: p_1 = candles_ext.p_2; break;
            case 4: p_1 = candles_ext.p_3; break;
        }

        for(var i=p_1;i<candles.length;i++) //анализируем оставшиеся бары
        {
            rsi=m_rsi[i];
            price_max = m_high[i];
            price_min = m_low[i];
            if(_start==true && ((low_level==true && rsi>=high) || (high_level==true && rsi<=low)))
            {
                break; //выходим из цикла, если второй экстремум уже найден, а RSI уже пересек противоположный уровень
            }
            if(low_level==true) //если ищем минимальный экстремум
            {
                if(rsi<=low)
                {
                    if(_start==false) _start=true;
                    if(price_min<min)
                    {
                        min=price_min;
                        index=i;
                    }
                }
            }
            else //если ищем максимальный экстремум
            {
                if(rsi>=high)
                {
                    if(_start==false) _start=true;
                    if(price_max>=max)
                    {
                        max=price_max;
                        index=i;
                    }
                }
            }
        }

        return(index);
    }

    function One_ext(candles_ext, //переменная типа структуры для получения индекса первого бара
                     dataRsi,         //хэндл индикатора
                     low)        //заданный уровень перепроданности RSI (можно использовать и high уровень)
    {
        var m_rsi = [];               //инициализация массива данных индикатора

        for(var i=dataRsi.length-1; i>=0; i--) {
            if(typeof dataRsi[i] != "undefined") {
                m_rsi.push(dataRsi[i]);
            }
        }


        var rsi=m_rsi[candles_ext.p_1]; //определяем значение RSI на баре с первым экстремумом

        if(rsi<=low)                      //если значение меньше нижнего уровня,
            return(false);                 //то первый экстремум был минимальным
        else                              //если нет,
            return(true);                     //то максимальным
    }


    function calculate()
    {
        Candles_Ext.p_1=Ext_1(Low_RSI,High_RSI,data,dataRsi,Distans,Period_Trade); //находим индекс бара первого экстремума
        if(Candles_Ext.p_1<0)
        {
            console.log("analyseResistSupport: В истории недостаточно баров для анализа 1");
            return 0;
        }
        if(Candles_Ext.p_1>0) First_Ext=One_ext(Candles_Ext, dataRsi,Low_RSI,Period_Trade);
        Candles_Ext.p_2=Ext_2(Low_RSI,High_RSI,data,dataRsi,Candles_Ext,2,Distans,First_Ext,Period_Trade); //находим индекс бара второго экстремума
        if(Candles_Ext.p_2<0)
        {
            console.log("analyseResistSupport: В истории недостаточно баров для анализа 2");
            return 0;
        }
        Candles_Ext.p_3=Ext_2(Low_RSI,High_RSI,data,dataRsi,Candles_Ext,3,Distans,First_Ext,Period_Trade); //находим индекс бара третьего экстремума
        if(Candles_Ext.p_3<0)
        {
            console.log("analyseResistSupport: В истории недостаточно баров для анализа 3");
            return 0;
        }
        Candles_Ext.p_4=Ext_2(Low_RSI,High_RSI,data,dataRsi,Candles_Ext,4,Distans,First_Ext,Period_Trade); //находим индекс бара последнего экстремума
        if(Candles_Ext.p_4<0)
        {
            console.log("analyseResistSupport: В истории недостаточно баров для анализа 4");
            return 0;
        }
        return 1;
    }

    //Candles_Ext.p_1=Ext_1(Low_RSI,High_RSI,data,dataRsi,Distans,Period_Trade); //находим индекс бара первого экстремума
    //
    //if(Candles_Ext.p_1>0) {
    //    First_Ext=One_ext(Candles_Ext, dataRsi,Low_RSI,Period_Trade);
    //}
    //
    //Candles_Ext.p_2=Ext_2(Low_RSI,High_RSI,data,dataRsi,Candles_Ext,2,Distans,First_Ext,Period_Trade); //находим индекс бара второго экстремума
    //console.log(Candles_Ext, First_Ext);

    //var idx = Ext_1(Low_RSI, High_RSI, data, dataRsi, Distans, Period_Trade);

    function findChannel (data, section) {
        var channelHeight = 0;
        for(var i=section[0].x; i<= Math.min(section[1].x,data.length-1); i++) {
            var linePt = iChart.getThirdPoint({'x':section[0].x, 'y':section[0].y}, {'x':section[1].x, 'y':section[1].y}, i);
            channelHeight = Math.max(channelHeight, Math.abs(linePt.y - (data[i][TA.OPEN] + data[i][TA.CLOSE])/2));
        }
        return channelHeight;
    }

    function findExts (data, section, sectionType, param, accuracy) {

        param = param || "d";
        var dParam = "d" + param;

        var prevPoint = {},
            currPoint = {},
            extPionts = [],
            needTurn = false;

        var channelHeight = findChannel(data, section);

        for(var i=data.length-1; i>=section[0].x; i--) {
            currPoint = {
                index: i,
                time: data[i][TA.FULLTIME],
                h: data[i][TA.HIGH],
                l: data[i][TA.LOW],
                o: data[i][TA.OPEN],
                c: data[i][TA.CLOSE],
                av1: (data[i][TA.OPEN] + data[i][TA.CLOSE]) / 2,
                av2: (data[i][TA.HIGH] + data[i][TA.LOW]) / 2
            };

            var linePt = iChart.getThirdPoint({'x':section[0].x, 'y':section[0].y}, {'x':section[1].x, 'y':section[1].y}, i);
            currPoint['dh'] =  Math.abs(linePt.y - currPoint.h);
            currPoint['dl'] =  Math.abs(linePt.y - currPoint.l);
            currPoint['do'] =  Math.abs(linePt.y - currPoint.o);
            currPoint['dc'] =  Math.abs(linePt.y - currPoint.c);
            currPoint['dav1'] =  Math.abs(linePt.y - currPoint.av1);
            currPoint['dav2'] =  Math.abs(linePt.y - currPoint.av2);


            if(i == section[2].x || i == section[3].x) {
                extPionts.push(currPoint);
                prevPoint = $.extend({}, currPoint);
                needTurn = true;
                i--;
            } else {

                if ($.isEmptyObject(prevPoint)) {
                    prevPoint = $.extend({}, currPoint);
                    if (currPoint[dParam] / channelHeight < accuracy) {
                        extPionts.push(currPoint);
                        needTurn = true;
                    }
                    continue;
                } else {

                    if (currPoint[dParam] > prevPoint[dParam] && !needTurn) {
                        if (prevPoint[dParam] / channelHeight < accuracy) {
                            extPionts.push(prevPoint);
                            needTurn = true;
                        }
                    }

                    if(sectionType == "support") {
                        if (currPoint[dParam] < prevPoint[dParam] && needTurn) {
                            if (Math.abs(extPionts[extPionts.length - 1][param] - prevPoint[param]) / channelHeight > 0.15) {
                                needTurn = false;
                            }
                        }
                    } else if(sectionType == "resist") {
                        if (currPoint[dParam] > prevPoint[dParam] && needTurn) {
                            if (Math.abs(extPionts[extPionts.length - 1][param] - prevPoint[param]) / channelHeight > 0.15) {
                                needTurn = false;
                            }
                        }
                    }

                    prevPoint = $.extend({}, currPoint);
                }
            }

        }

        if(sectionType == "support") {
            //удаление точек у которых разница с соседними очень мала
            for (var i = 0; i < extPionts.length; i++) {
                if ((typeof data[extPionts[i].index - 1] != "undefined" && Math.abs(data[extPionts[i].index - 1][TA.HIGH] - extPionts[i].l) / channelHeight < 0.005) ||
                    (typeof data[extPionts[i].index + 1] != "undefined" && Math.abs(data[extPionts[i].index + 1][TA.HIGH] - extPionts[i].l) / channelHeight < 0.005)
                ) {
                    extPionts.splice(i, 1);
                    --i;
                }
            }
        } else if(sectionType == "resist") {
            //удаление точек у которых разница с соседними очень мала
            for (var i = 0; i < extPionts.length; i++) {
                if ((typeof data[extPionts[i].index - 1] != "undefined" && Math.abs(data[extPionts[i].index - 1][TA.HIGH] - extPionts[i].l) / channelHeight < 0.005) ||
                    (typeof data[extPionts[i].index + 1] != "undefined" && Math.abs(data[extPionts[i].index + 1][TA.HIGH] - extPionts[i].l) / channelHeight < 0.005)
                ) {
                    extPionts.splice(i, 1);
                    --i;
                }
            }

        }

        return extPionts;
    }

    if(calculate()) {
        //console.log(Candles_Ext);
        var points = [];

        if(First_Ext) {
            points[0] = [data[data.length - 1 - Candles_Ext.p_1][TA.FULLTIME], data[data.length - 1 - Candles_Ext.p_1][TA.HIGH], data.length - 1 - Candles_Ext.p_1];
            points[1] = [data[data.length - 1 - Candles_Ext.p_2][TA.FULLTIME], data[data.length - 1 - Candles_Ext.p_2][TA.LOW], data.length - 1 - Candles_Ext.p_2];
            points[2] = [data[data.length - 1 - Candles_Ext.p_3][TA.FULLTIME], data[data.length - 1 - Candles_Ext.p_3][TA.HIGH], data.length - 1 - Candles_Ext.p_3];
            points[3] = [data[data.length - 1 - Candles_Ext.p_4][TA.FULLTIME], data[data.length - 1 - Candles_Ext.p_4][TA.LOW], data.length - 1 - Candles_Ext.p_4];
        } else {
            points[0] = [data[data.length - 1 - Candles_Ext.p_1][TA.FULLTIME], data[data.length - 1 - Candles_Ext.p_1][TA.LOW], data.length - 1 - Candles_Ext.p_1];
            points[1] = [data[data.length - 1 - Candles_Ext.p_2][TA.FULLTIME], data[data.length - 1 - Candles_Ext.p_2][TA.HIGH], data.length - 1 - Candles_Ext.p_2];
            points[2] = [data[data.length - 1 - Candles_Ext.p_3][TA.FULLTIME], data[data.length - 1 - Candles_Ext.p_3][TA.LOW], data.length - 1 - Candles_Ext.p_3];
            points[3] = [data[data.length - 1 - Candles_Ext.p_4][TA.FULLTIME], data[data.length - 1 - Candles_Ext.p_4][TA.HIGH], data.length - 1 - Candles_Ext.p_4];
        }

        var itPnts = iChart.getIntersection(
            {'x':points[0][2], 'y':points[0][1]},
            {'x':points[2][2], 'y':points[2][1]},
            {'x':points[1][2], 'y':points[1][1]},
            {'x':points[3][2], 'y':points[3][1]}
        );

        //console.log('points', points);
        //console.log('Intersection', itPnts);

        var fromAll = points[3][2] - (points[0][2]-points[3][2]);
        fromAll = Math.max(fromAll, 0);
        var to = points[0][2] + (points[0][2]-points[3][2]);
        to = Math.min(to, this.chart.areas[0].xSeries.length-1);

        var restrict1 = 0,
            restrict2 = this.chart.areas[0].xSeries.length-1;

        //пересечение слева
        if(itPnts.x < points[3][2]) {
            restrict1 = itPnts.x;
        }

        //пересечение справа
        if(itPnts.x > points[0][2]) {
            restrict2 = itPnts.x;
        }

        fromAll = Math.floor(Math.max(fromAll, restrict1));
        to = Math.ceil(Math.min(to, restrict2, this.chart.areas[0].xSeries.length-1, (restrict1 ? (data.length + 15) : data.length + 30)));

        //console.log(fromAll, to);

        var supportFound = false,
            supportPoints = [],
            resistFound = false,
            resistPoints = [];

        if(First_Ext) {
            for(var i=points[3][2]; i>=fromAll; i--) {
                var supportTest = iChart.getThirdPoint({'x':points[1][2], 'y':points[1][1]}, {'x':points[3][2], 'y':points[3][1]}, i);
                if(Math.max(data[i][TA.OPEN], data[i][TA.CLOSE]) < supportTest.y) {
                    supportFound = true;
                }
                if(!supportFound) {
                    supportTest['time'] = data[i][TA.FULLTIME];
                    supportPoints[0] = supportTest;
                }

                var resistTest = iChart.getThirdPoint({'x':points[0][2], 'y':points[0][1]}, {'x':points[2][2], 'y':points[2][1]}, i);
                if(!resistFound) {
                    resistTest['time'] = data[i][TA.FULLTIME];
                    resistPoints[0] = resistTest;
                }
                if(Math.min(data[i][TA.OPEN], data[i][TA.CLOSE]) > resistTest.y) {
                    resistFound = true;
                }

            }

            supportPoints[1] = iChart.getThirdPoint({'x':points[1][2], 'y':points[1][1]}, {'x':points[3][2], 'y':points[3][1]}, to);
            supportPoints[1]['time'] = this.chart.areas[0].xSeries[to]*1000;
            supportPoints[2] = {'x':points[1][2], 'y':points[1][1], time: points[1][0]};
            supportPoints[3] = {'x':points[3][2], 'y':points[3][1], time: points[3][0]};
            resistPoints[1] = iChart.getThirdPoint({'x':points[0][2], 'y':points[0][1]}, {'x':points[2][2], 'y':points[2][1]}, to);
            resistPoints[1]['time'] = this.chart.areas[0].xSeries[to]*1000;
            resistPoints[2] = {'x':points[0][2], 'y':points[0][1], time: points[0][0]};
            resistPoints[3] = {'x':points[2][2], 'y':points[2][1], time: points[2][0]};

        } else {
            for(var i=points[3][2]; i>=fromAll; i--) {
                var supportTest = iChart.getThirdPoint({'x':points[0][2], 'y':points[0][1]}, {'x':points[2][2], 'y':points[2][1]}, i);
                if(!supportFound) {
                    supportTest['time'] = data[i][TA.FULLTIME];
                    supportPoints[0] = supportTest;
                }

                if(Math.max(data[i][TA.OPEN], data[i][TA.CLOSE]) < supportTest.y || supportTest.y < 0) {
                    supportFound = true;
                }

                var resistTest = iChart.getThirdPoint({'x':points[1][2], 'y':points[1][1]}, {'x':points[3][2], 'y':points[3][1]}, i);
                if(Math.min(data[i][TA.OPEN], data[i][TA.CLOSE]) > resistTest.y) {
                    resistFound = true;
                }
                if(!resistFound) {
                    resistTest['time'] = data[i][TA.FULLTIME];
                    resistPoints[0] = resistTest;
                }
            }

            supportPoints[1] = iChart.getThirdPoint({'x':points[0][2], 'y':points[0][1]}, {'x':points[2][2], 'y':points[2][1]}, to);
            supportPoints[1]['time'] = this.chart.areas[0].xSeries[to]*1000;
            supportPoints[2] = {'x':points[0][2], 'y':points[0][1], time: points[0][0]};
            supportPoints[3] = {'x':points[2][2], 'y':points[2][1], time: points[2][0]};
            resistPoints[1] = iChart.getThirdPoint({'x':points[1][2], 'y':points[1][1]}, {'x':points[3][2], 'y':points[3][1]}, to);
            resistPoints[1]['time'] = this.chart.areas[0].xSeries[to]*1000;
            resistPoints[2] = {'x':points[1][2], 'y':points[1][1], time: points[1][0]};
            resistPoints[3] = {'x':points[3][2], 'y':points[3][1], time: points[3][0]};

        }

        var channelHeightSup = findChannel(data, supportPoints);
        var channelHeightRes = findChannel(data, resistPoints);

        //console.log(supportPoints, resistPoints);
        //console.log(channelHeightSup, channelHeightRes);

        var extTypeSup = "l",
            extTypeRes = "h",
            accuracy = 0.05,
            extSupportPionts = findExts(data, supportPoints, 'support', extTypeSup, accuracy),
            extResistPionts = findExts(data, resistPoints, 'resist', extTypeRes, accuracy);


        /*
         //SupportChannel
         var element = this.chart.overlay.createElement("Line");
         element.settings = {fillStyle: '#FF0000',
         strokeStyle: '#FF0000',
         lineWidth: 2};
         element.points = [{'x':supportPoints[0].time, 'y':supportPoints[0].y+channelHeightSup},{'x':supportPoints[1].time,'y':supportPoints[1].y+channelHeightSup}];

         this.chart.overlay.history.push(element);

         //ResistChannel
         var element = this.chart.overlay.createElement("Line");
         element.settings = {fillStyle: '#FF0000',
         strokeStyle: '#FF0000',
         lineWidth: 2};
         element.points = [{'x':resistPoints[0].time, 'y':resistPoints[0].y-channelHeightRes},{'x':resistPoints[1].time,'y':resistPoints[1].y-channelHeightRes}];

         this.chart.overlay.history.push(element);
         */

        //console.log(idx, dataRsi[idx]);
        return {
            extremeSupports: extSupportPionts,
            extremeResist: extResistPionts,
            supportPoints: supportPoints,
            resistPoints: resistPoints,
            points: points,
            lastPoint: {x: data.length - 1, y: data[data.length - 1][TA.CLOSE], time: data[data.length - 1][TA.FULLTIME]}
        };
    } else {
        return false;
    }
};

iChart.Charting.TA.prototype.autoResistSupport = function (debug, offset) {
    debug = !!debug;
    var dataRS = this.analyseResistSupport(8, offset);
    if(dataRS) {
        this.clearResistSupport();
        var extTypeSup = "l",
            extTypeRes = "h";

        if(dataRS.extremeSupports.length > 2 || debug) {
            var element = this.chart.overlay.createElement("Line");
            element.points = [{'x': dataRS.supportPoints[0].time, 'y': dataRS.supportPoints[0].y}, {
                'x': dataRS.supportPoints[1].time,
                'y': dataRS.supportPoints[1].y
            }];
            element.drawType = 'auto';
            element.storageEnable = false;
            element.controlEnable = false;
            element.id = 'SR_analyzer';
            this.chart.overlay.history.push(element);
        }

        if(dataRS.extremeResist.length > 2 || debug) {
            var element = this.chart.overlay.createElement("Line");
            element.points = [{'x': dataRS.resistPoints[0].time, 'y': dataRS.resistPoints[0].y}, {
                'x': dataRS.resistPoints[1].time,
                'y': dataRS.resistPoints[1].y
            }];
            element.drawType = 'auto';
            element.storageEnable = false;
            element.controlEnable = false;
            element.id = 'SR_analyzer';
            this.chart.overlay.history.push(element);
        }

        this.analyser(dataRS);

        if (debug) {

            var data = this.getData();
            var data = data.slice(0,data.length-offset);


            var element = this.chart.overlay.createElement("Event");
            element.hasSettings = true;
            element.drawType = 'auto';
            element.settings = {
                color: 'blue',
                size: 5,
                shape: 'triangle'
            };

            element.id = 'SR_analyzer';
            element.points = [{'x': dataRS.lastPoint.time, 'y': dataRS.lastPoint.y}];
            this.chart.overlay.history.push(element);


            var element = this.chart.overlay.createElement("Polygon");
            element.points = [
                {'x': dataRS.points[2][0], 'y': dataRS.points[2][1]},
                {'x': dataRS.points[0][0], 'y': dataRS.points[0][1]},
                {'x': dataRS.points[1][0], 'y': dataRS.points[1][1]},
                {'x': dataRS.points[3][0], 'y': dataRS.points[3][1]}
            ];
            element.storageEnable = false;
            element.drawType = 'auto';
            element.id = 'SR_analyzer';
            this.chart.overlay.history.push(element);


            for (var i = 0; i < dataRS.extremeSupports.length; i++) {
                var element = this.chart.overlay.createElement("Trade");
                element.hasSettings = true;
                element.settings = {
                    "type_id": 1,
                    "qb": "",
                    "mode": 1,
                    "date_time": '',
                    summ: dataRS.extremeSupports[i]["d" + extTypeSup] / dataRS.extremeSupports[i][extTypeSup] * 100
                };
                element.points = [{'x': dataRS.extremeSupports[i].time, 'y': dataRS.extremeSupports[i][extTypeSup]}];
                element.id = 'SR_analyzer';
                this.chart.overlay.history.push(element);
            }


            for (var i = 0; i < dataRS.extremeResist.length; i++) {
                var element = this.chart.overlay.createElement("Trade");
                element.hasSettings = true;
                element.drawType = 'auto';
                element.settings = {
                    "type_id": 0,
                    "qb": "",
                    "mode": 1,
                    "date_time": '',
                    summ: dataRS.extremeResist[i]["d" + extTypeRes] / dataRS.extremeResist[i][extTypeRes] * 100
                };

                element.points = [{'x': dataRS.extremeResist[i].time, 'y': dataRS.extremeResist[i][extTypeRes]}];
                element.id = 'SR_analyzer';
                this.chart.overlay.history.push(element);
            }
        }

        this.chart.overlay.render();
    }
};

iChart.Charting.TA.prototype.clearResistSupport = function () {
    var overlayHistory = this.chart.overlay.history;
    for(var i=0; i < overlayHistory.length; i++) {
        var element = overlayHistory[i];
        if(element.id == "SR_analyzer") {
            overlayHistory.splice(i, 1);
            i--;
        }
    }
    this.chart.overlay.render();
};


iChart.Charting.TA.prototype.testInPast = function (offset) {
    this.clearResistSupport();
    this.autoResistSupport(1, offset);
};

iChart.Charting.TA.prototype.analyser = function (dataRS, invert) {
    invert = invert || 0;

    var pResist = iChart.getLineEquation(dataRS.resistPoints[0], dataRS.resistPoints[1], dataRS.lastPoint.x);
    var pSupport = iChart.getLineEquation(dataRS.supportPoints[0], dataRS.supportPoints[1], dataRS.lastPoint.x);



    var dtResistSupport = Math.abs(pResist.y - pSupport.y);

    var dtResist = pResist.y - dataRS.lastPoint.y;
    var dtSupport = dataRS.lastPoint.y - pSupport.y;

    var dtpResist = dtResist / dtResistSupport * 100;
    var dtpSupport = dtSupport / dtResistSupport * 100;

    // console.log(pSupport);
    // console.log(dataRS.resistPoints[0], dataRS.resistPoints[1]);
    // console.log(dataRS.supportPoints[0], dataRS.supportPoints[1]);
    // console.log(dtpResist, dtpSupport);

    // if(dtpResist < 10 && dtpResist > 0) {
    //     return invert ? 2 : 1;
    // } else if (dtpSupport < 10 && dtpSupport > 0) {
    //     return invert ? 1: 2;
    // }
    if(Math.abs(dtpResist) < 10) {
        return invert ? 2 : 1;
    } else if (Math.abs(dtpSupport) < 10) {
        return invert ? 1: 2;
    }

    return false;
};

iChart.Charting.TA.prototype.analyserSearch = function (offset, invert) {
    offset = offset || this.chart.areas[0].xSeries.length - 100;

    var currentSignal = 0;
    var firstSignal = 0;
    var lastSignal = 0;
    var summ = 0;
    var lastSumm = 0;

    for(var i=offset;i>0;i--) {
        var dataRS = this.analyseResistSupport(8, i);

        if(!dataRS) {
            continue;
        }

        var advice = this.analyser(dataRS, invert);
        if(advice) {

            if(!firstSignal) {
                firstSignal = advice;
            }

            var element = this.chart.overlay.createElement("Event");
            element.hasSettings = true;
            element.drawType = 'auto';
            element.setSettings({
                color: advice == 1 ? '#f742d0' : '#085fff',
                size: 5,
                shape: 'triangle',
                dataRS: dataRS,
                pointFormatter: function () {
                    //console.log(this.dataRS);
                },
                onHover: function () {
                    var element = this.layer.chart.overlay.createElement("Line");
                    element.points = [{'x': this.settings.dataRS.resistPoints[0].time, 'y': this.settings.dataRS.resistPoints[0].y}, {
                        'x': this.settings.dataRS.resistPoints[1].time,
                        'y': this.settings.dataRS.resistPoints[1].y
                    }];
                    element.drawType = 'auto';
                    element.storageEnable = false;
                    element.controlEnable = false;
                    element.id = 'SR_view';
                    this.layer.chart.overlay.history.push(element);

                    var element = this.layer.chart.overlay.createElement("Line");
                    element.points = [{'x': this.settings.dataRS.supportPoints[0].time, 'y': this.settings.dataRS.supportPoints[0].y}, {
                        'x': this.settings.dataRS.supportPoints[1].time,
                        'y': this.settings.dataRS.supportPoints[1].y
                    }];
                    element.drawType = 'auto';
                    element.storageEnable = false;
                    element.controlEnable = false;
                    element.id = 'SR_view';
                    this.layer.chart.overlay.history.push(element);

                    var extTypeSup = "l",
                        extTypeRes = "h";

                    for (var i = 0; i < this.settings.dataRS.extremeSupports.length; i++) {
                        var element = this.layer.chart.overlay.createElement("Trade");
                        element.hasSettings = true;
                        element.settings = {
                            "type_id": 1,
                            "qb": "",
                            "mode": 1,
                            "date_time": '',
                            summ: this.settings.dataRS.extremeSupports[i]["d" + extTypeSup] / this.settings.dataRS.extremeSupports[i][extTypeSup] * 100
                        };
                        element.points = [{'x': this.settings.dataRS.extremeSupports[i].time, 'y': this.settings.dataRS.extremeSupports[i][extTypeSup]}];
                        element.id = 'SR_view';
                        this.layer.chart.overlay.history.push(element);
                    }


                    for (var i = 0; i < this.settings.dataRS.extremeResist.length; i++) {
                        var element = this.layer.chart.overlay.createElement("Trade");
                        element.hasSettings = true;
                        element.drawType = 'auto';
                        element.settings = {
                            "type_id": 0,
                            "qb": "",
                            "mode": 1,
                            "date_time": '',
                            summ: this.settings.dataRS.extremeResist[i]["d" + extTypeRes] / this.settings.dataRS.extremeResist[i][extTypeRes] * 100
                        };

                        element.points = [{'x': this.settings.dataRS.extremeResist[i].time, 'y': this.settings.dataRS.extremeResist[i][extTypeRes]}];
                        element.id = 'SR_view';
                        this.layer.chart.overlay.history.push(element);
                    }


                },
                onOut: function () {
                    var overlayHistory = this.layer.chart.overlay.history;
                    for(var i=0; i < overlayHistory.length; i++) {
                        var element = overlayHistory[i];
                        if(element.id == "SR_view") {
                            overlayHistory.splice(i, 1);
                            i--;
                        }
                    }
                    this.layer.chart.overlay.render();
                }
            });

            element.id = 'SR_analyserSearch';
            element.points = [{'x': dataRS.lastPoint.time, 'y': dataRS.lastPoint.y}];
            this.chart.overlay.history.push(element);


            if(currentSignal != advice) {

                if(advice == 1) {
                    summ += dataRS.lastPoint.y
                } else {
                    summ -= dataRS.lastPoint.y
                }
                console.log(advice, dataRS.lastPoint, summ);
                lastSumm = dataRS.lastPoint.y;

                currentSignal = advice;
                lastSignal = advice;
            }

            this.chart.overlay.render();
        }
    }

    if(firstSignal == lastSignal) {
        if(firstSignal == 1) {
            summ -= lastSumm;
        } else {
            summ += lastSumm;
        }
    }


    console.log("Profit: ", summ);

};


